---
title: CLOSE_WAIT和TIME_WAIT
date: 2023-12-01
tags:
 - 计算机基础
 - 计算机网络
categories:
 - 计算机网络
---

<!-- more -->

### 为什么 TIME_WAIT 等待的时间是 2MSL？

MSL时报文的最大生存时间，超过这个时间就会丢弃这个报文

IP头中有一个有一个TTL字段，是IP数据报文可以跳跃的最大路由数，每经过一个路由就会减一，直到为0

所以 **MSL 应该要大于等于 TTL 消耗为 0 的时间**，以确保报文已被自然消亡。

**TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了**。

**2MSL时长** 这其实是相当于**至少允许报文丢失一次**。从**客户端接收到 FIN 后发送 ACK 开始计时的**。

###  为什么需要 TIME_WAIT 状态？

- 防止历史连接中的数据，被后面相同四元组的连接错误的接收：

  2MSL**足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。**

- 保证「被动关闭连接」的一方，能被正确的关闭：

  **等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。**

**序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据**。

2MSL**足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。**

### TIME_WAIT 过多有什么危害？

**如果客户端（主动发起关闭连接方）的 TIME_WAIT 状态过多**，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接了

**如果服务端（主动发起关闭连接方）的 TIME_WAIT 状态过多**，TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等

### 如何优化 TIME_WAIT？

**如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT**

### 服务器出现大量 TIME_WAIT 状态的原因有哪些？

服务器主动断开了很多TCP连接

**什么场景下服务端会主动断开连接呢？**

- 第一个场景：HTTP 没有使用长连接

  使用的是短链接，过程就是 建立 TCP -> 请求资源 -> 响应资源 -> 释放连接

  **根据大多数 Web 服务的实现，不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接**

  > 客户端禁用了 HTTP Keep-Alive，服务端开启 HTTP Keep-Alive，谁是主动关闭方？
  >
  > HTTP Keep-Alive的设计初衷就是为用户的后续请求重用连接，当用户端禁用时，服务端在响应完就关闭连接，灰常合理

  > 客户端开启了 HTTP Keep-Alive，服务端关闭 HTTP Keep-Alive，谁是主动关闭方？
  >
  > 这时服务端在发完 HTTP 响应后，服务端也会主动关闭连接

- 第二个场景：HTTP 长连接超时

  **如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间一到，nginx 就会触发回调函数来关闭该连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接**。

- 第三个场景：HTTP 长连接的请求数量达到上限

  Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。

### 服务器出现大量 CLOSE_WAIT 状态的原因有哪些？

**当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接**。

一个普通的 TCP 服务端的流程：

1. 创建服务端 socket，bind 绑定端口、listen 监听端口
2. 将服务端 socket 注册到 epoll
3. epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket
4. 将已连接的 socket 注册到 epoll
5. epoll_wait 等待事件发生
6. 对方连接关闭时，我方调用 close

**当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close**。