---
title: TCP连接的断开
date: 2023-11-25
tags:
 - 计算机基础
 - 计算机网络
 - TCP
categories:
 - 计算机网络
---

<!-- more -->

## TCP断开连接

### TCP的四次挥手：

第一次挥手，客户端主动想要断开连接，向服务器发送一个FIN报文，之后客户端进入FIN_WAIT_1状态

第二次挥手，服务端收到该报文，向客户端发送一个ACK报文，服务端进入CLOSE_WAIT状态，客户端接收之后进入FIN_WAIT_2状态

第三次挥手，服务端可能还有数据需要处理和发送，等服务端不再发送数据时，发送FIN报文，之后服务端进入LAST_ACK状态

第四次挥手，客户端向服务端发送ACK报文，服务端接收到报文之后进入CLOSE状态，而客户端则会TIME_WAIT(2MSL)之后进入CLOSE状态

**主动关闭连接的，才有 TIME_WAIT 状态。**

### 第一次挥手丢失：

客户端向服务端发送FIN报文，之后进入FIN_WAIT_1状态

第一次挥手丢失，客户端会触发超时重传，当重传次数超出上限，客户端就会直接进入CLOSE状态

### 第二次挥手丢失：

服务端向客户端发送ACK报文，之后进入CLOSE_WAIT状态

当第二次挥手丢失之后，由于ACK报文不会重传，于是会触发第一次挥手的重传机制，当重传次数超出上限，客户端就会直接进入CLOSE状态

> 客户端接收到第二次挥手的时候，进入FIN_WAIT_2状态
>
> 如果关闭方使用的是Close函数（无法再接收和发送数据），所以FIN_WAIT_2状态不能持续太久，一般在60s内不能接收到FIN报文，就会直接进入CLOSE状态
>
> 如果关闭方使用的是shutdown函数（无法在发送数据，但是可以接受数据），如果一直没有接收到FIN报文就会一直死等

### 第三次挥手丢失：

由于服务端超时间没有收到ACK报文，就会触发超时重传，达到最大次数之后服务端就直接进入CLOSE状态

而客户端使用CKLOSE函数超过60s没有接收FIN报文，也会进入CLOSE状态

### 第四次挥手丢失

客户端的ACK报文丢失，服务端长时间没有收到ACK就会触发第三次挥手的重传机制

- 客户端在发送ACK之后进入TIME_WAIT状态，开启2MSL计时器，如果中途再次接收到FIN报文，就会重置计时器，当等待时间超过2MSL，客户端就直接进入CLOSE状态
- 服务端超过最大重传次数之后，直接进入CLOSE状态

## TCP四次挥手可以变成三次吗？

> FIN 报文一定得调用关闭连接的函数，才会发送吗？

不一定。

如果进程退出了，不管是不是正常退出，还是异常退出（如进程崩溃），内核都会发送 FIN 报文，与对方完成四次挥手

#### 粗暴关闭VS优雅关闭：

粗暴关闭（close）：

- close 函数，同时 socket 关闭发送方向和读取方向，也就是 socket 不再有发送和接收数据的能力。如果有多进程/多线程共享同一个 socket，如果有一个进程调用了 close 关闭只是让 socket 引用计数 -1，并不会导致 socket 不可用，同时也不会发出 FIN 报文，其他进程还是可以正常读写该 socket，直到引用计数变为 0，才会发出 FIN 报文。

如果客户端是用 close 函数来关闭连接，那么在 TCP 四次挥手过程中，如果收到了服务端发送的数据，由于客户端已经不再具有发送和接收数据的能力，所以客户端的内核会回 RST 报文给服务端，然后内核会释放连接，这时就不会经历完成的 TCP 四次挥手，所以我们常说，调用 close 是粗暴的关闭。

优雅关闭（shutdown）：

- shutdown 函数，可以指定 socket 只关闭发送方向而不关闭读取方向，也就是 socket 不再有发送数据的能力，但是还是具有接收数据的能力。如果有多进程/多线程共享同一个 socket，shutdown 则不管引用计数，直接使得该 socket 不可用，然后发出 FIN 报文，如果有别的进程企图使用该 socket，将会受到影响。

#### 什么情况下会出现三次挥手？

当被动关闭方在 TCP 挥手过程中，「**没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。**

> 什么是 TCP 延迟确认机制？

当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。 为了解决 ACK 传输效率低问题，所以就衍生出了 **TCP 延迟确认**。 TCP 延迟确认的策略：

- 当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方
- 当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送
- 如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK

## 四次挥手中收到乱序的FIN包怎么办

如果FIN报文比数据包提前到达客户端，此时FIN是一个乱序的报文，客户端不会从FIN_WAIT_2状态变成TIME_WAIT状态

而是把它放到乱序队列，等收到数据包之后才会从这个队列中找是否有可用的数据包，如果能找到这个数据包序列号保持顺序的报文，然后就会查看这个报文，如果有FIN字段就会进入TIME_WAIT状态

## 在TIME_WAIT状态的TCP接收到SYN报文会怎么样？

#### SYN合法：

针对开启了TCP时间戳的TCP：

- 客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要**大**，**并且** SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要**大**。

此时如果收到相同四元组的SYN包就会跳过2MSL,直接跳到SYN_RECV状态继续建立连接

#### SYN非法：

- **非法 SYN**：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要**小**，**或者** SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要**小**。

收到非法的SYN包回发送一个第四次挥手的ACK，然后客户端发现不是自己的，就会回复RST

#### 在 TIME_WAIT 状态，收到 RST 会断开连接吗？

看这个内核参数net.ipv4.tcp_rfc1337为1就丢掉


### 如果已经建立了链接，客户端突然挂怎么办

TCP的保活机制：

定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡

### 如果已经建立了链接，服务端突然挂怎么办

 **kill 掉进程后，服务端会（内核）发送 FIN 报文，与客户端进行四次挥手**。

 ## TCP连接，一端断电和进程崩溃有什么区别？

![](2024-05-16-20-37-31.png)

主机崩溃：

> 在没有开启 TCP keepalive，且双方一直没有数据交互的情况下，如果客户端的「主机崩溃」了，会发生什么。

客户端主机崩溃了，服务端是**无法感知到的**，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，**服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态**，直到服务端重启进程。

> 那题目中的「进程崩溃」的情况呢？

即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。

#### 客户端主机宕机又重启？

无论重启之后主机上是否还有这个进程的目标端口号，都会返回一个RST报文