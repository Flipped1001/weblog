---
title: HTTP和HTTPS的区别
date: 2023-11-22
tags:
 - 计算机基础
 - 计算机网络
 - HTTP
 - HTTPS
categories:
 - 计算机网络
---

<!-- more -->

## HTTP和HTTPS：

### 1.HTTP和HTTPS的区别：

1. 安全性：HTTP是明文传输不安全，HTTPS在**TCP和HTTTP网络层**之间加入了**SSL/TLS协议**（报文可以加密传输）更安全
2. 建立连接的复杂程度上：HTTP连接简单**三次握手之后**就可以进行报文的传输，而HTTPS在**三次握手之后还需要进行一次SSL/TLS的握手**过程之后可以进行加密传输
3. 默认端口：HTTP是80，HTTPS是443
4. HTTPS需要向CA申请数字证书，来保证服务器的身份是可信的

### 2.HTTPS解决了HTTP的那些问题?

- 安全上:**通信加密**(防止信息泄露),**校验机制**(防止通信内容被篡改),**身份验证**(防止被假网站骗)

#### 如何解决的?

- **混合加密**:在通信建立之前使用非对称加密,通信过程中使用对称加密

1. **对称加密和非对称加密**

   对称加密:加密和解密使用相同的密钥,加密速度非常快,但是双方需要**共享密钥**容易造成**密钥的丢失**
   非对称加密:公钥加密私钥解密,加密和解密过程慢,但是只有对应的**私钥**才能解密更安全

- 摘要算法+数字签名:

  1.摘要算法:对内容进行哈希,计算出一个唯一的哈希值(可以保证内容不被篡改,但是如果连哈希值和内容一起被篡改,还是会造成内容的篡改)
  2.数字签名:采用非对称加密算法,公钥和私钥可以双向解密
  **私钥加密，公钥解密**。这个目的是为了**保证消息不会被冒充**，非对称加密的用途主要在于**通过「私钥加密，公钥解密」的方式，来确认消息的身份**,加密的不是内容而是**哈希值**

- 数字证书:

  防止公钥是假的

### 3.HTTPS是如何建立连接的,期间交互了什么?

SSL/TLS 协议基本流程：

- 客户端向服务器索要并验证服务器的公钥。
- 双方协商生产「会话秘钥」。
- 双方采用「会话秘钥」进行加密通信。

**TLS四次握手:（RSA）**

RSA算法的缺陷：不支持向前保密

**首先客户端发送`ClientHello`(加密通信)请求**

（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。

（2）客户端生产的随机数（`Client Random`），后面用于生成「会话秘钥」条件之一。

（3）客户端支持的密码套件列表，如RSA 加密算法。

**服务器收到客户端请求后，向客户端发出响应 `SeverHello`**

（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。

（2）服务器生产的随机数（`Server Random`），也是后面用于生产「会话秘钥」条件之一。

（3）确认的密码套件列表，如 RSA 加密算法。**密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法**（握手时密钥交换算法和签名算法都是使用 RSA）

（4）服务器的数字证书「**Server Certificate**」。

「**Server Hello Done**」结束

**客户端收到服务器的回应之后，确认服务器的数字证书的真实性。从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息「**Client Key Exchange**」：**

（1）一个随机数（`pre-master key`）。该随机数会被服务器公钥加密。

（2）加密通信算法改变通知「**Change Cipher Spec**」，表示随后的信息都将用「会话秘钥」加密通信。

（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时「**Encrypted Handshake Message（Finishd）**把**之前所有内容的发生的数据做个摘要，用来供服务端校验。**

**服务器收到客户端的第三个随机数（`pre-master key`）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。**

（1）加密通信算法改变通知「**Change Cipher Spec**」，**Encrypted Handshake Message**验证，表示随后的信息都将用「会话秘钥」加密通信。

（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。



**TLS四次握手:（ECDHE）**

**可以不用等最后一次握手结束就可以传输消息**

**DH 算法分为两种实现：**

- static DH 算法，一方的私钥是静态的，不具有前向安全性；
- DHE 算法，两方的密钥全部随机，现在常用的，计算性能不佳；
- ECDHE算法， ECC 椭圆曲线特性，可以用更少的计算量计算出公钥

**使用了 ECDHE，在 TLS 第四次握手前，客户端就已经发送了加密的 HTTP 数据**，而对于 RSA 握手过程，必须要完成 TLS 四次握手，才能传输应用数据。

**首先客户端发送`ClientHello`(加密通信)请求**

（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。

（2）客户端生产的随机数（`Client Random`），后面用于生成「会话秘钥」条件之一。

（3）客户端支持的密码套件列表，如RSA 加密算法。

**服务器收到客户端请求后，向客户端发出响应 `SeverHello`**

（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。

（2）服务器生产的随机数（`Server Random`）

（4）确认的密码套件列表，如 RSA 加密算法。**密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法**

- 密钥协商算法使用 ECDHE；
- 签名算法使用 RSA

（5）服务器的数字证书「**Certificate**」消息，会把证书也发给客户端，「**Server Key Exchange**」这个过程中
服务器生产的随机数（`Server Random`）作为服务端的私钥，基点 G 和私钥计算出**服务端的椭圆曲线公钥**。。

「**Server Hello Done**」结束

第二轮结束后共享的消息：**Client Random、Server Random 、使用的椭圆曲线、椭圆曲线基点 G、服务端椭圆曲线的公钥**

**客户端收到服务器的回应之后，确认服务器的数字证书的真实性。从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息「**Client Key Exchange**」：**

（1）一个随机数（`pre-master key`）作为客户端椭圆曲线的私钥。生成**客户端的椭圆曲线公钥**。

（2）**最终的会话密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三个材料生成的**。

（3）加密通信算法改变通知「**Change Cipher Spec**」，表示随后的信息都将用「会话秘钥」加密通信。

（4）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时「**Encrypted Handshake Message（Finishd）**把**之前所有内容的发生的数据做个摘要，用来供服务端校验。**

**服务器收到客户端的第三个随机数（`pre-master key`）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。**

（1）加密通信算法改变通知「**Change Cipher Spec**，表示随后的信息都将用「会话秘钥」加密通信。

（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。



### 4.HTTPS的应用数据时如保证完整性的

TLS 在实现上分为**握手协议**和**记录协议**两层：

- TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；
- TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；

**HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全**。

假基站和抓包工具
