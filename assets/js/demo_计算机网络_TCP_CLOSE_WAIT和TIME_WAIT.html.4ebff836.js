"use strict";(self.webpackChunkvuepress_theme_hope_template=self.webpackChunkvuepress_theme_hope_template||[]).push([[4061],{6786:(e,t)=>{t.A=(e,t)=>{const i=e.__vccOpts||e;for(const[e,p]of t)i[e]=p;return i}},3626:(e,t,i)=>{i.r(t),i.d(t,{comp:()=>o,data:()=>n});var p=i(2758);const l=(0,p.Fv)('<h3 id="为什么-time-wait-等待的时间是-2msl" tabindex="-1"><a class="header-anchor" href="#为什么-time-wait-等待的时间是-2msl"><span>为什么 TIME_WAIT 等待的时间是 2MSL？</span></a></h3><p>MSL时报文的最大生存时间，超过这个时间就会丢弃这个报文</p><p>IP头中有一个有一个TTL字段，是IP数据报文可以跳跃的最大路由数，每经过一个路由就会减一，直到为0</p><p>所以 <strong>MSL 应该要大于等于 TTL 消耗为 0 的时间</strong>，以确保报文已被自然消亡。</p><p><strong>TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了</strong>。</p><p><strong>2MSL时长</strong> 这其实是相当于<strong>至少允许报文丢失一次</strong>。从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。</p><h3 id="为什么需要-time-wait-状态" tabindex="-1"><a class="header-anchor" href="#为什么需要-time-wait-状态"><span>为什么需要 TIME_WAIT 状态？</span></a></h3><ul><li><p>防止历史连接中的数据，被后面相同四元组的连接错误的接收：</p><p>2MSL<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p></li><li><p>保证「被动关闭连接」的一方，能被正确的关闭：</p><p><strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p></li></ul><p><strong>序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据</strong>。</p><p>2MSL<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p><h3 id="time-wait-过多有什么危害" tabindex="-1"><a class="header-anchor" href="#time-wait-过多有什么危害"><span>TIME_WAIT 过多有什么危害？</span></a></h3><p><strong>如果客户端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接了</p><p><strong>如果服务端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等</p><h3 id="如何优化-time-wait" tabindex="-1"><a class="header-anchor" href="#如何优化-time-wait"><span>如何优化 TIME_WAIT？</span></a></h3><p><strong>如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT</strong></p><h3 id="服务器出现大量-time-wait-状态的原因有哪些" tabindex="-1"><a class="header-anchor" href="#服务器出现大量-time-wait-状态的原因有哪些"><span>服务器出现大量 TIME_WAIT 状态的原因有哪些？</span></a></h3><p>服务器主动断开了很多TCP连接</p><p><strong>什么场景下服务端会主动断开连接呢？</strong></p><ul><li><p>第一个场景：HTTP 没有使用长连接</p><p>使用的是短链接，过程就是 建立 TCP -&gt; 请求资源 -&gt; 响应资源 -&gt; 释放连接</p><p><strong>根据大多数 Web 服务的实现，不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接</strong></p><blockquote><p>客户端禁用了 HTTP Keep-Alive，服务端开启 HTTP Keep-Alive，谁是主动关闭方？</p><p>HTTP Keep-Alive的设计初衷就是为用户的后续请求重用连接，当用户端禁用时，服务端在响应完就关闭连接，灰常合理</p></blockquote><blockquote><p>客户端开启了 HTTP Keep-Alive，服务端关闭 HTTP Keep-Alive，谁是主动关闭方？</p><p>这时服务端在发完 HTTP 响应后，服务端也会主动关闭连接</p></blockquote></li><li><p>第二个场景：HTTP 长连接超时</p><p><strong>如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间一到，nginx 就会触发回调函数来关闭该连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接</strong>。</p></li><li><p>第三个场景：HTTP 长连接的请求数量达到上限</p><p>Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。</p></li></ul><h3 id="服务器出现大量-close-wait-状态的原因有哪些" tabindex="-1"><a class="header-anchor" href="#服务器出现大量-close-wait-状态的原因有哪些"><span>服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</span></a></h3><p><strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p><p>一个普通的 TCP 服务端的流程：</p><ol><li>创建服务端 socket，bind 绑定端口、listen 监听端口</li><li>将服务端 socket 注册到 epoll</li><li>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket</li><li>将已连接的 socket 注册到 epoll</li><li>epoll_wait 等待事件发生</li><li>对方连接关闭时，我方调用 close</li></ol><p><strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close</strong>。</p>',24),a={},o=(0,i(6786).A)(a,[["render",function(e,t){return(0,p.uX)(),(0,p.CE)("div",null,[(0,p.Q3)(" more "),l])}]]),n=JSON.parse('{"path":"/demo/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/CLOSE_WAIT%E5%92%8CTIME_WAIT.html","title":"CLOSE_WAIT和TIME_WAIT","lang":"zh-CN","frontmatter":{"title":"CLOSE_WAIT和TIME_WAIT","date":"2023-12-01T00:00:00.000Z","tags":["计算机基础","计算机网络"],"categories":["计算机网络"],"head":[["meta",{"property":"og:url","content":"https://flipped1001.cn/demo/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/CLOSE_WAIT%E5%92%8CTIME_WAIT.html"}],["meta",{"property":"og:site_name","content":"Flipped"}],["meta",{"property":"og:title","content":"CLOSE_WAIT和TIME_WAIT"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-16T10:13:48.000Z"}],["meta",{"property":"article:author","content":"Flipped"}],["meta",{"property":"article:tag","content":"计算机基础"}],["meta",{"property":"article:tag","content":"计算机网络"}],["meta",{"property":"article:published_time","content":"2023-12-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-16T10:13:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"CLOSE_WAIT和TIME_WAIT\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-12-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-16T10:13:48.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Flipped\\"}]}"]]},"headers":[{"level":3,"title":"为什么 TIME_WAIT 等待的时间是 2MSL？","slug":"为什么-time-wait-等待的时间是-2msl","link":"#为什么-time-wait-等待的时间是-2msl","children":[]},{"level":3,"title":"为什么需要 TIME_WAIT 状态？","slug":"为什么需要-time-wait-状态","link":"#为什么需要-time-wait-状态","children":[]},{"level":3,"title":"TIME_WAIT 过多有什么危害？","slug":"time-wait-过多有什么危害","link":"#time-wait-过多有什么危害","children":[]},{"level":3,"title":"如何优化 TIME_WAIT？","slug":"如何优化-time-wait","link":"#如何优化-time-wait","children":[]},{"level":3,"title":"服务器出现大量 TIME_WAIT 状态的原因有哪些？","slug":"服务器出现大量-time-wait-状态的原因有哪些","link":"#服务器出现大量-time-wait-状态的原因有哪些","children":[]},{"level":3,"title":"服务器出现大量 CLOSE_WAIT 状态的原因有哪些？","slug":"服务器出现大量-close-wait-状态的原因有哪些","link":"#服务器出现大量-close-wait-状态的原因有哪些","children":[]}],"git":{"createdTime":1721124828000,"updatedTime":1721124828000,"contributors":[{"name":"flipped1001","email":"3154147351@qq.com","commits":1}]},"readingTime":{"minutes":4.13,"words":1238},"filePathRelative":"demo/计算机网络/TCP/CLOSE_WAIT和TIME_WAIT.md","localizedDate":"2023年12月1日","excerpt":""}')}}]);