"use strict";(self.webpackChunkvuepress_theme_hope_template=self.webpackChunkvuepress_theme_hope_template||[]).push([[7521],{2789:(e,t)=>{t.A=(e,t)=>{const a=e.__vccOpts||e;for(const[e,p]of t)a[e]=p;return a}},7728:(e,t,a)=>{a.r(t),a.d(t,{comp:()=>i,data:()=>r});var p=a(7829);const n=a.p+"assets/img/2024-05-16-20-37-31.57522fd7.png",l=(0,p.Fv)('<h2 id="tcp断开连接" tabindex="-1"><a class="header-anchor" href="#tcp断开连接"><span>TCP断开连接</span></a></h2><h3 id="tcp的四次挥手" tabindex="-1"><a class="header-anchor" href="#tcp的四次挥手"><span>TCP的四次挥手：</span></a></h3><p>第一次挥手，客户端主动想要断开连接，向服务器发送一个FIN报文，之后客户端进入FIN_WAIT_1状态</p><p>第二次挥手，服务端收到该报文，向客户端发送一个ACK报文，服务端进入CLOSE_WAIT状态，客户端接收之后进入FIN_WAIT_2状态</p><p>第三次挥手，服务端可能还有数据需要处理和发送，等服务端不再发送数据时，发送FIN报文，之后服务端进入LAST_ACK状态</p><p>第四次挥手，客户端向服务端发送ACK报文，服务端接收到报文之后进入CLOSE状态，而客户端则会TIME_WAIT(2MSL)之后进入CLOSE状态</p><p><strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p><h3 id="第一次挥手丢失" tabindex="-1"><a class="header-anchor" href="#第一次挥手丢失"><span>第一次挥手丢失：</span></a></h3><p>客户端向服务端发送FIN报文，之后进入FIN_WAIT_1状态</p><p>第一次挥手丢失，客户端会触发超时重传，当重传次数超出上限，客户端就会直接进入CLOSE状态</p><h3 id="第二次挥手丢失" tabindex="-1"><a class="header-anchor" href="#第二次挥手丢失"><span>第二次挥手丢失：</span></a></h3><p>服务端向客户端发送ACK报文，之后进入CLOSE_WAIT状态</p><p>当第二次挥手丢失之后，由于ACK报文不会重传，于是会触发第一次挥手的重传机制，当重传次数超出上限，客户端就会直接进入CLOSE状态</p><blockquote><p>客户端接收到第二次挥手的时候，进入FIN_WAIT_2状态</p><p>如果关闭方使用的是Close函数（无法再接收和发送数据），所以FIN_WAIT_2状态不能持续太久，一般在60s内不能接收到FIN报文，就会直接进入CLOSE状态</p><p>如果关闭方使用的是shutdown函数（无法在发送数据，但是可以接受数据），如果一直没有接收到FIN报文就会一直死等</p></blockquote><h3 id="第三次挥手丢失" tabindex="-1"><a class="header-anchor" href="#第三次挥手丢失"><span>第三次挥手丢失：</span></a></h3><p>由于服务端超时间没有收到ACK报文，就会触发超时重传，达到最大次数之后服务端就直接进入CLOSE状态</p><p>而客户端使用CKLOSE函数超过60s没有接收FIN报文，也会进入CLOSE状态</p><h3 id="第四次挥手丢失" tabindex="-1"><a class="header-anchor" href="#第四次挥手丢失"><span>第四次挥手丢失</span></a></h3><p>客户端的ACK报文丢失，服务端长时间没有收到ACK就会触发第三次挥手的重传机制</p><ul><li>客户端在发送ACK之后进入TIME_WAIT状态，开启2MSL计时器，如果中途再次接收到FIN报文，就会重置计时器，当等待时间超过2MSL，客户端就直接进入CLOSE状态</li><li>服务端超过最大重传次数之后，直接进入CLOSE状态</li></ul><h2 id="tcp四次挥手可以变成三次吗" tabindex="-1"><a class="header-anchor" href="#tcp四次挥手可以变成三次吗"><span>TCP四次挥手可以变成三次吗？</span></a></h2><blockquote><p>FIN 报文一定得调用关闭连接的函数，才会发送吗？</p></blockquote><p>不一定。</p><p>如果进程退出了，不管是不是正常退出，还是异常退出（如进程崩溃），内核都会发送 FIN 报文，与对方完成四次挥手</p><h4 id="粗暴关闭vs优雅关闭" tabindex="-1"><a class="header-anchor" href="#粗暴关闭vs优雅关闭"><span>粗暴关闭VS优雅关闭：</span></a></h4><p>粗暴关闭（close）：</p><ul><li>close 函数，同时 socket 关闭发送方向和读取方向，也就是 socket 不再有发送和接收数据的能力。如果有多进程/多线程共享同一个 socket，如果有一个进程调用了 close 关闭只是让 socket 引用计数 -1，并不会导致 socket 不可用，同时也不会发出 FIN 报文，其他进程还是可以正常读写该 socket，直到引用计数变为 0，才会发出 FIN 报文。</li></ul><p>如果客户端是用 close 函数来关闭连接，那么在 TCP 四次挥手过程中，如果收到了服务端发送的数据，由于客户端已经不再具有发送和接收数据的能力，所以客户端的内核会回 RST 报文给服务端，然后内核会释放连接，这时就不会经历完成的 TCP 四次挥手，所以我们常说，调用 close 是粗暴的关闭。</p><p>优雅关闭（shutdown）：</p><ul><li>shutdown 函数，可以指定 socket 只关闭发送方向而不关闭读取方向，也就是 socket 不再有发送数据的能力，但是还是具有接收数据的能力。如果有多进程/多线程共享同一个 socket，shutdown 则不管引用计数，直接使得该 socket 不可用，然后发出 FIN 报文，如果有别的进程企图使用该 socket，将会受到影响。</li></ul><h4 id="什么情况下会出现三次挥手" tabindex="-1"><a class="header-anchor" href="#什么情况下会出现三次挥手"><span>什么情况下会出现三次挥手？</span></a></h4><p>当被动关闭方在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p><blockquote><p>什么是 TCP 延迟确认机制？</p></blockquote><p>当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。 为了解决 ACK 传输效率低问题，所以就衍生出了 <strong>TCP 延迟确认</strong>。 TCP 延迟确认的策略：</p><ul><li>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</li><li>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</li><li>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</li></ul><h2 id="四次挥手中收到乱序的fin包怎么办" tabindex="-1"><a class="header-anchor" href="#四次挥手中收到乱序的fin包怎么办"><span>四次挥手中收到乱序的FIN包怎么办</span></a></h2><p>如果FIN报文比数据包提前到达客户端，此时FIN是一个乱序的报文，客户端不会从FIN_WAIT_2状态变成TIME_WAIT状态</p><p>而是把它放到乱序队列，等收到数据包之后才会从这个队列中找是否有可用的数据包，如果能找到这个数据包序列号保持顺序的报文，然后就会查看这个报文，如果有FIN字段就会进入TIME_WAIT状态</p><h2 id="在time-wait状态的tcp接收到syn报文会怎么样" tabindex="-1"><a class="header-anchor" href="#在time-wait状态的tcp接收到syn报文会怎么样"><span>在TIME_WAIT状态的TCP接收到SYN报文会怎么样？</span></a></h2><h4 id="syn合法" tabindex="-1"><a class="header-anchor" href="#syn合法"><span>SYN合法：</span></a></h4><p>针对开启了TCP时间戳的TCP：</p><ul><li>客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>大</strong>，<strong>并且</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>大</strong>。</li></ul><p>此时如果收到相同四元组的SYN包就会跳过2MSL,直接跳到SYN_RECV状态继续建立连接</p><h4 id="syn非法" tabindex="-1"><a class="header-anchor" href="#syn非法"><span>SYN非法：</span></a></h4><ul><li><strong>非法 SYN</strong>：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>小</strong>，<strong>或者</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>小</strong>。</li></ul><p>收到非法的SYN包回发送一个第四次挥手的ACK，然后客户端发现不是自己的，就会回复RST</p><h4 id="在-time-wait-状态-收到-rst-会断开连接吗" tabindex="-1"><a class="header-anchor" href="#在-time-wait-状态-收到-rst-会断开连接吗"><span>在 TIME_WAIT 状态，收到 RST 会断开连接吗？</span></a></h4><p>看这个内核参数net.ipv4.tcp_rfc1337为1就丢掉</p><h3 id="如果已经建立了链接-客户端突然挂怎么办" tabindex="-1"><a class="header-anchor" href="#如果已经建立了链接-客户端突然挂怎么办"><span>如果已经建立了链接，客户端突然挂怎么办</span></a></h3><p>TCP的保活机制：</p><p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡</p><h3 id="如果已经建立了链接-服务端突然挂怎么办" tabindex="-1"><a class="header-anchor" href="#如果已经建立了链接-服务端突然挂怎么办"><span>如果已经建立了链接，服务端突然挂怎么办</span></a></h3><p><strong>kill 掉进程后，服务端会（内核）发送 FIN 报文，与客户端进行四次挥手</strong>。</p><h2 id="tcp连接-一端断电和进程崩溃有什么区别" tabindex="-1"><a class="header-anchor" href="#tcp连接-一端断电和进程崩溃有什么区别"><span>TCP连接，一端断电和进程崩溃有什么区别？</span></a></h2><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>主机崩溃：</p><blockquote><p>在没有开启 TCP keepalive，且双方一直没有数据交互的情况下，如果客户端的「主机崩溃」了，会发生什么。</p></blockquote><p>客户端主机崩溃了，服务端是<strong>无法感知到的</strong>，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，<strong>服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态</strong>，直到服务端重启进程。</p><blockquote><p>那题目中的「进程崩溃」的情况呢？</p></blockquote><p>即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。</p><h4 id="客户端主机宕机又重启" tabindex="-1"><a class="header-anchor" href="#客户端主机宕机又重启"><span>客户端主机宕机又重启？</span></a></h4><p>无论重启之后主机上是否还有这个进程的目标端口号，都会返回一个RST报文</p>',62),s={},i=(0,a(2789).A)(s,[["render",function(e,t){return(0,p.uX)(),(0,p.CE)("div",null,[(0,p.Q3)(" more "),l])}]]),r=JSON.parse('{"path":"/demo/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%96%AD%E5%BC%80.html","title":"TCP连接的断开","lang":"zh-CN","frontmatter":{"title":"TCP连接的断开","date":"2023-11-25T00:00:00.000Z","tags":["计算机基础","计算机网络","TCP"],"categories":["计算机网络"],"head":[["meta",{"property":"og:url","content":"https://flipped1001.cn/demo/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%96%AD%E5%BC%80.html"}],["meta",{"property":"og:site_name","content":"Flipped"}],["meta",{"property":"og:title","content":"TCP连接的断开"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-16T10:13:48.000Z"}],["meta",{"property":"article:author","content":"Flipped"}],["meta",{"property":"article:tag","content":"计算机基础"}],["meta",{"property":"article:tag","content":"计算机网络"}],["meta",{"property":"article:tag","content":"TCP"}],["meta",{"property":"article:published_time","content":"2023-11-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-16T10:13:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"TCP连接的断开\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-11-25T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-16T10:13:48.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Flipped\\"}]}"]]},"headers":[{"level":2,"title":"TCP断开连接","slug":"tcp断开连接","link":"#tcp断开连接","children":[{"level":3,"title":"TCP的四次挥手：","slug":"tcp的四次挥手","link":"#tcp的四次挥手","children":[]},{"level":3,"title":"第一次挥手丢失：","slug":"第一次挥手丢失","link":"#第一次挥手丢失","children":[]},{"level":3,"title":"第二次挥手丢失：","slug":"第二次挥手丢失","link":"#第二次挥手丢失","children":[]},{"level":3,"title":"第三次挥手丢失：","slug":"第三次挥手丢失","link":"#第三次挥手丢失","children":[]},{"level":3,"title":"第四次挥手丢失","slug":"第四次挥手丢失","link":"#第四次挥手丢失","children":[]}]},{"level":2,"title":"TCP四次挥手可以变成三次吗？","slug":"tcp四次挥手可以变成三次吗","link":"#tcp四次挥手可以变成三次吗","children":[]},{"level":2,"title":"四次挥手中收到乱序的FIN包怎么办","slug":"四次挥手中收到乱序的fin包怎么办","link":"#四次挥手中收到乱序的fin包怎么办","children":[]},{"level":2,"title":"在TIME_WAIT状态的TCP接收到SYN报文会怎么样？","slug":"在time-wait状态的tcp接收到syn报文会怎么样","link":"#在time-wait状态的tcp接收到syn报文会怎么样","children":[{"level":3,"title":"如果已经建立了链接，客户端突然挂怎么办","slug":"如果已经建立了链接-客户端突然挂怎么办","link":"#如果已经建立了链接-客户端突然挂怎么办","children":[]},{"level":3,"title":"如果已经建立了链接，服务端突然挂怎么办","slug":"如果已经建立了链接-服务端突然挂怎么办","link":"#如果已经建立了链接-服务端突然挂怎么办","children":[]}]},{"level":2,"title":"TCP连接，一端断电和进程崩溃有什么区别？","slug":"tcp连接-一端断电和进程崩溃有什么区别","link":"#tcp连接-一端断电和进程崩溃有什么区别","children":[]}],"git":{"createdTime":1721124828000,"updatedTime":1721124828000,"contributors":[{"name":"flipped1001","email":"3154147351@qq.com","commits":1}]},"readingTime":{"minutes":7.27,"words":2181},"filePathRelative":"demo/计算机网络/TCP/TCP连接的断开.md","localizedDate":"2023年11月25日","excerpt":""}')}}]);