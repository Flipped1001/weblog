"use strict";(self.webpackChunkvuepress_theme_hope_template=self.webpackChunkvuepress_theme_hope_template||[]).push([[7807],{6786:(t,e)=>{e.A=(t,e)=>{const l=t.__vccOpts||t;for(const[t,n]of e)l[t]=n;return l}},1981:(t,e,l)=>{l.r(e),l.d(e,{comp:()=>c,data:()=>g});var n=l(2758);const p=l.p+"assets/img/2024-05-16-20-23-20.95e98f5b.png",i=l.p+"assets/img/2024-05-16-20-26-31.0ea147ed.png",o=l.p+"assets/img/2024-05-16-20-38-32.bc0a9196.png",s=l.p+"assets/img/2024-05-16-20-38-41.e76859ab.png",r=(0,n.Fv)('<h1 id="tcp篇" tabindex="-1"><a class="header-anchor" href="#tcp篇"><span>TCP篇</span></a></h1><h2 id="tcp基本认识" tabindex="-1"><a class="header-anchor" href="#tcp基本认识"><span>TCP基本认识</span></a></h2><h3 id="tcp的头格式" tabindex="-1"><a class="header-anchor" href="#tcp的头格式"><span>TCP的头格式：</span></a></h3><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，每发送一次数据，就累加一次。用来解决网络包乱序问题。</p><p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端接收到确认答应之后，可以认定之前的数据全部被接收。用来解决丢包问题</p><ul><li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li><li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li><li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li><li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li></ul><h3 id="tcp工作在那一层" tabindex="-1"><a class="header-anchor" href="#tcp工作在那一层"><span>TCP工作在那一层：</span></a></h3><p>TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p><h3 id="什么是tcp协议" tabindex="-1"><a class="header-anchor" href="#什么是tcp协议"><span>什么是TCP协议：</span></a></h3><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p><ul><li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li><li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li><li><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li></ul><h3 id="什么是tcp连接" tabindex="-1"><a class="header-anchor" href="#什么是tcp连接"><span>什么是TCP连接:</span></a></h3><p>连接：<strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。</strong></p><p>建立一个TCP连接需要：</p><ul><li><strong>Socket</strong>：由 IP 地址和端口号组成</li><li><strong>序列号</strong>：用来解决乱序问题等</li><li><strong>窗口大小</strong>：用来做流量控制</li></ul><h3 id="如何确定一个tcp连接" tabindex="-1"><a class="header-anchor" href="#如何确定一个tcp连接"><span>如何确定一个TCP连接：</span></a></h3><p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p><ul><li>源地址</li><li>源端口</li><li>目的地址</li><li>目的端口</li></ul><p>源地址和目的地址在IP头部，源端口和目的端口在TCP头部</p><blockquote><p><strong>有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？</strong></p></blockquote><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>对 IPv4，客户端的 IP 数最多为 <code>2</code> 的 <code>32</code> 次方，客户端的端口数最多为 <code>2</code> 的 <code>16</code> 次方，也就是服务端单机最大 TCP 连接数，约为 <code>2</code> 的 <code>48</code> 次方。</p><ul><li><p>文件描述符限制</p><p>每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 Too many open files。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：</p><ul><li><strong>系统级</strong>：当前系统可打开的最大数量</li><li><strong>用户级</strong>：指定用户可打开的最大数量</li><li><strong>进程级</strong>：单个进程可打开的最大数量</li></ul></li><li><p><strong>内存限制</strong>，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM</p></li></ul><h2 id="如何理解tcp是基于字节流的协议" tabindex="-1"><a class="header-anchor" href="#如何理解tcp是基于字节流的协议"><span>如何理解TCP是基于字节流的协议？</span></a></h2><blockquote><h4 id="先来说说为什么-udp-是面向报文的协议" tabindex="-1"><a class="header-anchor" href="#先来说说为什么-udp-是面向报文的协议"><span>先来说说为什么 UDP 是面向报文的协议？</span></a></h4><p>使用UDP传输协议的时候，操作系统不会对消息进行拆分。<strong>每个 UDP 报文就是一个用户消息的边界</strong></p><p>操作系统在收到 UDP 报文后，会将其插入到队列里，<strong>队列里的每一个元素就是一个 UDP 报文</strong></p></blockquote><blockquote><h4 id="再来说说为什么-tcp-是面向字节流的协议" tabindex="-1"><a class="header-anchor" href="#再来说说为什么-tcp-是面向字节流的协议"><span>再来说说为什么 TCP 是面向字节流的协议？</span></a></h4><p><strong>消息可能会被操作系统分组成多个的 TCP 报文</strong>，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。</p></blockquote><p>如何解决粘包：</p><ul><li>固定长度的消息；</li><li>特殊字符作为边界；</li><li>自定义消息结构</li></ul><h2 id="tcp半连接队列和全连接队列" tabindex="-1"><a class="header-anchor" href="#tcp半连接队列和全连接队列"><span>TCP半连接队列和全连接队列</span></a></h2><p><strong>如果持续不断地有连接因为 TCP 全连接队列溢出被丢弃，就应该调大 backlog 以及 somaxconn 参数</strong></p><p><strong>开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接</strong></p><p>SYN攻击：</p><ul><li>增大半连接队列；</li><li>开启 tcp_syncookies 功能</li><li>减少 SYN+ACK 重传次数</li></ul><p><strong>发送缓冲区不能超过「带宽时延积」</strong></p><ul><li>如果发送缓冲区「超过」带宽时延积，超出的部分就没办法有效的网络传输，同时导致网络过载，容易丢包；</li><li>如果发送缓冲区「小于」带宽时延积，就不能很好的发挥出网络的传输效率</li></ul><h2 id="syn报文在什么情况下会被丢弃" tabindex="-1"><a class="header-anchor" href="#syn报文在什么情况下会被丢弃"><span>SYN报文在什么情况下会被丢弃？</span></a></h2><ul><li><p>net.ipv4.tcp_tw_recycle，如果开启该选项的话，允许处于 TIME_WAIT 状态的连接被快速回收；</p><p>要使得这个选项生效，有一个前提条件，就是要打开 TCP 时间戳，即 net.ipv4.tcp_timestamps=1（默认即为 1)）。 当同时开启了recycle 和 timestamps 选项，会开启**「 per-host 的 PAWS 机制」**</p></li></ul><p><strong>tcp_tw_recycle在NAT网络下使用是不安全的</strong></p><p>PAWS 就是为了避免TCP中序列号出现回绕，在开启 tcp_timestamps 选项情况下，一台机器发的所有 TCP 包都会带上发送时的时间戳，PAWS 要求连接双方维护最近一次收到的数据包的时间戳（Recent TSval），每收到一个新数据包都会读取数据包中的时间戳值跟 Recent TSval 值做比较，<strong>如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包</strong>。</p><p><strong>per-host 是对「对端 IP 做 PAWS 检查」</strong>，而非对「IP + 端口」四元组做 PAWS 检查，在NAT网络下使用不安全</p><ul><li>半连接队列满了</li><li>全连接队列满了</li></ul><h2 id="拔掉网线之后-tcp连接会消失吗" tabindex="-1"><a class="header-anchor" href="#拔掉网线之后-tcp连接会消失吗"><span>拔掉网线之后，TCP连接会消失吗？</span></a></h2><p>TCP连接存在于内核中，不会因为把掉网线造成TCP断开</p><h2 id="为什么-tcp-tw-reuse-默认是关闭的" tabindex="-1"><a class="header-anchor" href="#为什么-tcp-tw-reuse-默认是关闭的"><span><strong>为什么 tcp_tw_reuse 默认是关闭的？</strong></span></a></h2><p><strong>RST 报文的时间戳即使过期了，只要 RST 报文的序列号在对方的接收窗口内，也是能被接受的</strong>。</p><ul><li>历史 RST 报文可能会终止后面相同四元组的连接，因为 PAWS 检查到即使 RST 是过期的，也不会丢弃。</li><li>如果第四次挥手的 ACK 报文丢失了，有可能被动关闭连接的一方不能被正常的关闭;</li></ul><h2 id="用了tcp传输数据就一定不会丢包吗" tabindex="-1"><a class="header-anchor" href="#用了tcp传输数据就一定不会丢包吗"><span>用了TCP传输数据就一定不会丢包吗？</span></a></h2><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>TCP丢包：</p><ul><li>三次握手时（连接建立失败）</li><li>流量控制丢包（当发送数据过快，流控队列长度<code>txqueuelen</code>又不够大时，就容易出现<strong>丢包</strong>现象。）</li><li>网卡丢包（<strong>网线质量差，接触不良</strong>）RingBuffer过小导致丢包（网卡性能不足）</li><li>接收缓冲区丢包，当缓冲区满了，就会将在收到的信息丢掉</li></ul><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>使用TCP出现丢包：</p><p><strong>聊天软件还需要将数据从TCP的接收缓冲区里读出来，如果在读出来这一刻，手机由于内存不足或其他各种原因，导致软件崩溃闪退了。</strong></p><p>这类丢包问题怎么解决：</p><p>服务器<strong>可能</strong>记录了我们最近发过什么数据，假设<strong>每条消息都有个id</strong>，服务器和聊天软件每次都拿<strong>最新消息的id</strong>进行对比</p><p>对于<strong>发送方</strong>，只要定时跟服务端的内容对账一下，就知道哪条消息没发送成功，直接重发就好了。</p><p>如果<strong>接收方</strong>的聊天软件崩溃了，重启后跟服务器稍微通信一下就知道少了哪条数据，同步上来就是了，所以也不存在上面提到的丢包情况。</p><p><strong>TCP只保证传输层的消息可靠性，并不保证应用层的消息可靠性。如果我们还想保证应用层的消息可靠性，就需要应用层自己去实现逻辑做保证。</strong></p><blockquote><p>主要有三个原因。</p><ul><li>第一，如果是两端通信，你聊天软件里有<code>1000个</code>好友，你就得建立<code>1000个</code>连接。但如果引入服务端，你只需要跟服务器建立<code>1个</code>连接就够了，<strong>聊天软件消耗的资源越少，手机就越省电</strong>。</li><li>第二，就是<strong>安全问题</strong>，如果还是两端通信，随便一个人找你对账一下，你就把聊天记录给同步过去了，这并不合适吧。如果对方别有用心，信息就泄露了。引入第三方服务端就可以很方便的做各种<strong>鉴权</strong>校验。</li><li>第三，是<strong>软件版本问题</strong>。软件装到用户手机之后，软件更不更新就是由用户说了算了。如果还是两端通信，且两端的<strong>软件版本跨度太大</strong>，很容易产生各种兼容性问题，但引入第三端服务器，就可以强制部分过低版本升级，否则不能使用软件。但对于大部分兼容性问题，给服务端加兼容逻辑就好了，不需要强制用户更新软件。</li></ul></blockquote>',60),a={},c=(0,l(6786).A)(a,[["render",function(t,e){return(0,n.uX)(),(0,n.CE)("div",null,[(0,n.Q3)(" more "),r])}]]),g=JSON.parse('{"path":"/demo/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/TCP%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86.html","title":"TCP的基本认识","lang":"zh-CN","frontmatter":{"title":"TCP的基本认识","date":"2023-11-24T00:00:00.000Z","tags":["计算机基础","计算机网络"],"categories":["计算机网络"],"head":[["meta",{"property":"og:url","content":"https://flipped1001.cn/demo/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/TCP%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86.html"}],["meta",{"property":"og:site_name","content":"Flipped"}],["meta",{"property":"og:title","content":"TCP的基本认识"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-16T10:13:48.000Z"}],["meta",{"property":"article:author","content":"Flipped"}],["meta",{"property":"article:tag","content":"计算机基础"}],["meta",{"property":"article:tag","content":"计算机网络"}],["meta",{"property":"article:published_time","content":"2023-11-24T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-16T10:13:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"TCP的基本认识\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-11-24T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-16T10:13:48.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Flipped\\"}]}"]]},"headers":[{"level":2,"title":"TCP基本认识","slug":"tcp基本认识","link":"#tcp基本认识","children":[{"level":3,"title":"TCP的头格式：","slug":"tcp的头格式","link":"#tcp的头格式","children":[]},{"level":3,"title":"TCP工作在那一层：","slug":"tcp工作在那一层","link":"#tcp工作在那一层","children":[]},{"level":3,"title":"什么是TCP协议：","slug":"什么是tcp协议","link":"#什么是tcp协议","children":[]},{"level":3,"title":"什么是TCP连接:","slug":"什么是tcp连接","link":"#什么是tcp连接","children":[]},{"level":3,"title":"如何确定一个TCP连接：","slug":"如何确定一个tcp连接","link":"#如何确定一个tcp连接","children":[]}]},{"level":2,"title":"如何理解TCP是基于字节流的协议？","slug":"如何理解tcp是基于字节流的协议","link":"#如何理解tcp是基于字节流的协议","children":[]},{"level":2,"title":"TCP半连接队列和全连接队列","slug":"tcp半连接队列和全连接队列","link":"#tcp半连接队列和全连接队列","children":[]},{"level":2,"title":"SYN报文在什么情况下会被丢弃？","slug":"syn报文在什么情况下会被丢弃","link":"#syn报文在什么情况下会被丢弃","children":[]},{"level":2,"title":"拔掉网线之后，TCP连接会消失吗？","slug":"拔掉网线之后-tcp连接会消失吗","link":"#拔掉网线之后-tcp连接会消失吗","children":[]},{"level":2,"title":"为什么 tcp_tw_reuse 默认是关闭的？","slug":"为什么-tcp-tw-reuse-默认是关闭的","link":"#为什么-tcp-tw-reuse-默认是关闭的","children":[]},{"level":2,"title":"用了TCP传输数据就一定不会丢包吗？","slug":"用了tcp传输数据就一定不会丢包吗","link":"#用了tcp传输数据就一定不会丢包吗","children":[]}],"git":{"createdTime":1721124828000,"updatedTime":1721124828000,"contributors":[{"name":"flipped1001","email":"3154147351@qq.com","commits":1}]},"readingTime":{"minutes":8.41,"words":2522},"filePathRelative":"demo/计算机网络/TCP/TCP的基本认识.md","localizedDate":"2023年11月24日","excerpt":""}')}}]);