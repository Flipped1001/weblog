"use strict";(self.webpackChunkvuepress_theme_hope_template=self.webpackChunkvuepress_theme_hope_template||[]).push([[4143],{6786:(e,t)=>{t.A=(e,t)=>{const p=e.__vccOpts||e;for(const[e,l]of t)p[e]=l;return p}},9268:(e,t,p)=>{p.r(t),p.d(t,{comp:()=>s,data:()=>r});var l=p(2758);const n=p.p+"assets/img/2024-05-16-20-31-23.17e04784.png",a=(0,l.Fv)('<h2 id="tcp连接的建立" tabindex="-1"><a class="header-anchor" href="#tcp连接的建立"><span>TCP连接的建立：</span></a></h2><p>TCP的三次握手：</p><p>一开始双方处于close状态，服务器会主动监听某个端口处于LISTEN，</p><p>第一次握手：客户端向服务端发送一个带有初始化序列号（ISN）的，SYN=1的SNTCP报文，之后客户端处于SYN_SENT状态</p><p>第二次握手：服务端收到客户端发来的报文，然会向服务端发送一个带有自己初始化的随机序列号，确认应答号是客户端的ISN+1， 并且SYN和ACK都等于1的TCP报文，然后服务端处于SYN_RCYD（半连接状态）</p><p>第三次握手：客户端向服务端发送一个，确认应答号为服务端ISN加1的，ACK为1，TCP报文发送给服务端，之后客户端处于ESTABLISHED（连接状态），可以携带数据</p><p>第三次握手是可以携带数据的，前两次不可以携带数据</p><h3 id="为什么是三次握手" tabindex="-1"><a class="header-anchor" href="#为什么是三次握手"><span>为什么是三次握手：</span></a></h3><p>1.<strong>TCP 使用三次握手建立连接的最主要原因是防止「历史连接」初始化了连接</strong></p><p><strong>在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费</strong>。</p><p><strong>要解决这种现象，最好就是在服务端发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手</strong>。</p><p>2.<em>同步双方初始序列号</em></p><p>序列号的作用：</p><ul><li><p>接收方可以去除重复的数据；</p></li><li><p>接收方可以根据数据包的序列号按序接收；</p></li><li><p>可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）</p><p><strong>一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></p></li></ul><p>两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收</p><h3 id="为什么每次建立tcp链接的时候-初始化序列号的都要求不一样" tabindex="-1"><a class="header-anchor" href="#为什么每次建立tcp链接的时候-初始化序列号的都要求不一样"><span>为什么每次建立TCP链接的时候，初始化序列号的都要求不一样？</span></a></h3><ul><li>首要目的是，防止历史报文被下一个相同四元组接收</li><li>为了安全性，防止黑客伪造的相同序列号TCP报文被对方接收</li></ul><h3 id="初始序列号isn是如何随机产生的" tabindex="-1"><a class="header-anchor" href="#初始序列号isn是如何随机产生的"><span>初始序列号ISN是如何随机产生的？</span></a></h3><p>ISN = M + F(localhost, localport, remotehost, remoteport)</p><p>M:计时器，每4微秒加一 F：是一个Hash，跟据源IP，目的IP，源端口，目标端口。随即生成一个随机数</p><h3 id="既然ip层会分片-为什么tcp层还需要mss" tabindex="-1"><a class="header-anchor" href="#既然ip层会分片-为什么tcp层还需要mss"><span>既然IP层会分片，为什么TCP层还需要MSS？</span></a></h3><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如果直接交给IP层，让他进行分片，如果其中一个IP包丢失，由于IP层<strong>没有超时重传</strong>，直接导致发送方迟迟接收不到ACK，导致整个IP报文被重传</p><p>所以，为了达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值</strong>，当将分片交给TCP层后就不需要IP层进行分片了，如果一个TCP分片丢失，只用重发丢失片</p><p>IP层分片：为了适应不同链路的MUT不同</p><h3 id="第一次握手丢失" tabindex="-1"><a class="header-anchor" href="#第一次握手丢失"><span>第一次握手丢失</span></a></h3><p>会触发超时重传，并且重传的SYN报文序列号是一样的</p><p>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后，<strong>每次超时的时间是上一次的 2 倍</strong>。</p><p>一般有一个最大重传次数 tcp_syn_retries，如果超过会在等一段时间（上一次超时的二倍），之后还没有，就断开连接</p><h3 id="第二次握手丢失" tabindex="-1"><a class="header-anchor" href="#第二次握手丢失"><span>第二次握手丢失</span></a></h3><p>客户端和服务端都会触发超时重传机制</p><p>由于客户端在第一次握手之后迟迟没有接受ACK，会认为第一次握手报文丢失就会重新传SYN报文 然后，服务端的话由于长时间没有收到第三次握手，会认为第二次握手丢失就会重传SYN_ACK报文（也有一个最大重传次数 tcp_syn_retries）</p><h3 id="第三次握手丢失" tabindex="-1"><a class="header-anchor" href="#第三次握手丢失"><span>第三次握手丢失</span></a></h3><p>服务端会触发超时重传</p><p>由于服务端长时间没有收到ACK报文，就会重传SYN_ACK报文</p><p><strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p><h2 id="为什么每次建立tcp连接-初始化序列号都要不一样" tabindex="-1"><a class="header-anchor" href="#为什么每次建立tcp连接-初始化序列号都要不一样"><span>为什么每次建立TCP连接，初始化序列号都要不一样？</span></a></h2><ul><li>尽最大可能避免历史报文被新的TCP连接接收到</li></ul><p>随机数是会基于时钟计时器递增的，基本不可能会随机成一样的初始化序列号。</p><p>​ 序列号（SEQ）：用于对TCP连接上发送的每一个数据包进行编号0，序列号在整个TCP连接的生命周期中都是递增的，并且它们用于确定数据包的顺序以及检测数据包的丢失或乱序到达，<strong>序列号是一个 32 位的无符号数，因此在到达 4G 之后再循环回到 0</strong>。</p><p>​ 初始化序列号（ISN）：用于每次建立TCP的链接，目的是确保每个TCP连接都具有唯一的起始序列号，以防止对连接的重放攻击和其他形式的网络攻击。<strong>初始化序列号可被视为一个 32 位的计数器，该计数器的数值每 4 微秒加 1，循环一次需要 4.55 小时</strong>。</p><p><strong>序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据</strong>。</p><blockquote><p>TCP时间戳：<strong>一个是便于精确计算 RTT ，另一个是能防止序列号回绕（PAWS）</strong>。</p><p>防回绕序列号算法要求连接双方维护最近一次收到的数据包的时间戳（Recent TSval），每收到一个新数据包都会读取数据包中的时间戳值跟 Recent TSval 值做比较，<strong>如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包</strong>。</p></blockquote><p>引入时间戳之后可以完全避免历史报文接收问题</p><h2 id="tcp-序列号和确认号是如何变化的" tabindex="-1"><a class="header-anchor" href="#tcp-序列号和确认号是如何变化的"><span>TCP 序列号和确认号是如何变化的？</span></a></h2><h2 id="万能公式" tabindex="-1"><a class="header-anchor" href="#万能公式"><span>万能公式</span></a></h2><p><strong>发送的 TCP 报文：</strong></p><ul><li><p><strong>公式一：序列号 = 上一次发送的序列号 + len（数据长度）。特殊情况，如果上一次发送的报文是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。</strong></p></li><li><p><strong>公式二：确认号 = 上一次收到的报文中的序列号 + len（数据长度）。特殊情况，如果收到的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。</strong></p></li><li></li><li><p><strong>序列号</strong>：在建立连接时由内核生成的随机数作为其初始值，通过 SYN 报文传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p></li><li><p><strong>确认号</strong>：指下一次「期望」收到的数据的序列号，发送端收到接收方发来的 ACK 确认报文以后，就可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p></li><li><p>**控制位：**用来标识 TCP 报文是什么类型的报文，比如是 SYN 报文、数据报文、ACK 报文，FIN 报文等</p></li></ul><h2 id="已建立的tcp连接-收到syn会发生什么" tabindex="-1"><a class="header-anchor" href="#已建立的tcp连接-收到syn会发生什么"><span>已建立的TCP连接，收到SYN会发生什么？</span></a></h2><ol><li><p>客户端的SYN报文中的源端口号和历史连接的不同</p><p>服务端会认为这是一个新的连接请求，就会建立一个新的链接</p></li><li><p>客户端的SYN中的端口号和历史连接的不同</p><p><strong>处于连接中的TCP连接，如果收到了SYN报文，服务端会返回一个带有正确的确认号和正确的序列号这个 ACK 被称之为 Challenge ACK。</strong></p><p><strong>接着，客户端收到这个 Challenge ACK，发现确认号（ack num）并不是自己期望收到的，于是就会回 RST 报文，服务端收到后，就会释放掉该连接</strong></p></li></ol><h3 id="killcx-的工具" tabindex="-1"><a class="header-anchor" href="#killcx-的工具"><span>killcx 的工具</span></a></h3><p><strong>我们可以伪造一个四元组相同的 SYN 报文，来拿到“合法”的序列号！</strong></p><p>正如我们最开始学到的，如果处于 Established 状态的服务端，收到四元组相同的 SYN 报文后，<strong>会回复一个 Challenge ACK，这个 ACK 报文里的「确认号」，正好是服务端下一次想要接收的序列号，说白了，就是可以通过这一步拿到服务端下一次预期接收的序列号。</strong></p><p><strong>然后用这个确认号作为 RST 报文的序列号，发送给服务端，此时服务端会认为这个 RST 报文里的序列号是合法的，于是就会释放连接！</strong></p><h3 id="tcpkill-的工具" tabindex="-1"><a class="header-anchor" href="#tcpkill-的工具"><span>tcpkill 的工具</span></a></h3><ul><li><p>tcpkill 工具是在双方进行 TCP 通信时，拿到对方下一次期望收到的序列号，然后将序列号填充到伪造的 RST 报文，并将其发送给对方，达到关闭 TCP 连接的效果。</p><p>无法关闭非活跃的TCP连接</p><h2 id="tcp-的-keepalive-和-http-的-keep-alive-是一个东西吗" tabindex="-1"><a class="header-anchor" href="#tcp-的-keepalive-和-http-的-keep-alive-是一个东西吗"><span><strong>TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？</strong></span></a></h2></li><li><p>HTTP 的 Keep-Alive，是由<strong>应用层（用户态）</strong> 实现的，称为 HTTP 长连接</p><p>只要一端没有明确的提出断开连接，就会让这个TCP保持连接状态；但是有一个，HTTP连接超时时间的限制</p></li><li><p>TCP 的 Keepalive，是由 <strong>TCP 层（内核态）</strong> 实现的，称为 TCP 保活机制</p></li></ul>',56),i={},s=(0,p(6786).A)(i,[["render",function(e,t){return(0,l.uX)(),(0,l.CE)("div",null,[(0,l.Q3)(" more "),a])}]]),r=JSON.parse('{"path":"/demo/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B.html","title":"TCP连接的建立","lang":"zh-CN","frontmatter":{"title":"TCP连接的建立","date":"2023-11-24T00:00:00.000Z","tags":["计算机基础","计算机网络","TCP"],"categories":["计算机网络"],"head":[["meta",{"property":"og:url","content":"https://flipped1001.cn/demo/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B.html"}],["meta",{"property":"og:site_name","content":"Flipped"}],["meta",{"property":"og:title","content":"TCP连接的建立"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-09T13:05:22.000Z"}],["meta",{"property":"article:author","content":"Flipped"}],["meta",{"property":"article:tag","content":"计算机基础"}],["meta",{"property":"article:tag","content":"计算机网络"}],["meta",{"property":"article:tag","content":"TCP"}],["meta",{"property":"article:published_time","content":"2023-11-24T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-09T13:05:22.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"TCP连接的建立\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-11-24T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-09T13:05:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Flipped\\"}]}"]]},"headers":[{"level":2,"title":"TCP连接的建立：","slug":"tcp连接的建立","link":"#tcp连接的建立","children":[{"level":3,"title":"为什么是三次握手：","slug":"为什么是三次握手","link":"#为什么是三次握手","children":[]},{"level":3,"title":"为什么每次建立TCP链接的时候，初始化序列号的都要求不一样？","slug":"为什么每次建立tcp链接的时候-初始化序列号的都要求不一样","link":"#为什么每次建立tcp链接的时候-初始化序列号的都要求不一样","children":[]},{"level":3,"title":"初始序列号ISN是如何随机产生的？","slug":"初始序列号isn是如何随机产生的","link":"#初始序列号isn是如何随机产生的","children":[]},{"level":3,"title":"既然IP层会分片，为什么TCP层还需要MSS？","slug":"既然ip层会分片-为什么tcp层还需要mss","link":"#既然ip层会分片-为什么tcp层还需要mss","children":[]},{"level":3,"title":"第一次握手丢失","slug":"第一次握手丢失","link":"#第一次握手丢失","children":[]},{"level":3,"title":"第二次握手丢失","slug":"第二次握手丢失","link":"#第二次握手丢失","children":[]},{"level":3,"title":"第三次握手丢失","slug":"第三次握手丢失","link":"#第三次握手丢失","children":[]}]},{"level":2,"title":"为什么每次建立TCP连接，初始化序列号都要不一样？","slug":"为什么每次建立tcp连接-初始化序列号都要不一样","link":"#为什么每次建立tcp连接-初始化序列号都要不一样","children":[]},{"level":2,"title":"TCP 序列号和确认号是如何变化的？","slug":"tcp-序列号和确认号是如何变化的","link":"#tcp-序列号和确认号是如何变化的","children":[]},{"level":2,"title":"万能公式","slug":"万能公式","link":"#万能公式","children":[]},{"level":2,"title":"已建立的TCP连接，收到SYN会发生什么？","slug":"已建立的tcp连接-收到syn会发生什么","link":"#已建立的tcp连接-收到syn会发生什么","children":[{"level":3,"title":"killcx 的工具","slug":"killcx-的工具","link":"#killcx-的工具","children":[]},{"level":3,"title":"tcpkill 的工具","slug":"tcpkill-的工具","link":"#tcpkill-的工具","children":[]}]}],"git":{"createdTime":1721124828000,"updatedTime":1723208722000,"contributors":[{"name":"flipped1001","email":"3154147351@qq.com","commits":2}]},"readingTime":{"minutes":8.35,"words":2506},"filePathRelative":"demo/计算机网络/TCP/TCP连接的建立.md","localizedDate":"2023年11月24日","excerpt":""}')}}]);