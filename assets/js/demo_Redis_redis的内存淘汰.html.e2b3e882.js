"use strict";(self.webpackChunkvuepress_theme_hope_template=self.webpackChunkvuepress_theme_hope_template||[]).push([[5070],{6786:(e,t)=>{t.A=(e,t)=>{const i=e.__vccOpts||e;for(const[e,l]of t)i[e]=l;return i}},140:(e,t,i)=>{i.r(t),i.d(t,{comp:()=>a,data:()=>n});var l=i(2758);const s=i.p+"assets/img/2024-08-10-15-21-27.6d7aee82.png",r=[(0,l.Fv)('<h2 id="当redis内存满了" tabindex="-1"><a class="header-anchor" href="#当redis内存满了"><span>当Redis内存满了</span></a></h2><p>在 Redis 的运行内存达到了某个<strong>阀值</strong>，就会触发<strong>内存淘汰机制</strong>，这个阀值就是我们设置的最大运行内存此值在 Redis 的配置文件中可以找到，配置项为 maxmemory。</p><p>这个时候就需要进行内存淘汰了，在redis中大体有两种策略：</p><h2 id="不进行数据淘汰的策略" tabindex="-1"><a class="header-anchor" href="#不进行数据淘汰的策略"><span>不进行数据淘汰的策略</span></a></h2><p><code>noeviction</code>(Redis3.0之后，默认的内存淘汰策略)：它表示当运行内存超过最大设置内存时，不淘汰任何数据，而是不再提供服务，直接返回错误。</p><h2 id="进行数据淘汰的策略" tabindex="-1"><a class="header-anchor" href="#进行数据淘汰的策略"><span>进行数据淘汰的策略</span></a></h2><p>这个策略又可以分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。</p><h3 id="_1-在设置了过期时间的数据中进行淘汰" tabindex="-1"><a class="header-anchor" href="#_1-在设置了过期时间的数据中进行淘汰"><span>1. 在设置了过期时间的数据中进行淘汰</span></a></h3><ul><li>volatile-random：随机淘汰设置了过期时间的任意键值</li><li>volatile-ttl：优先淘汰更早过期的键值。</li><li>volatile-lru (Redis3.0 之前，默认的内存淘汰策略)：淘汰所有设置了过期时间的键值中，最久未使用的键值</li><li>volatile-lfu (Redis 4.0 后新增的内存淘汰策略)：淘汰所有设置了过期时间的键值中，最少使用的键值</li></ul><h3 id="_2-在所有数据范围内进行淘汰" tabindex="-1"><a class="header-anchor" href="#_2-在所有数据范围内进行淘汰"><span>2. 在所有数据范围内进行淘汰</span></a></h3><ul><li>allkeys-random：随机淘汰任意键值</li><li>allkeys-Iru：淘汰整个键值中最久未使用的键值</li><li>allkeys-lfu (Redis 4.0 后新增的内存淘汰策略)：淘汰整个键值中最少使用的键值</li></ul><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="lru算法和lfu算法" tabindex="-1"><a class="header-anchor" href="#lru算法和lfu算法"><span>LRU算法和LFU算法</span></a></h3><h5 id="lru算法" tabindex="-1"><a class="header-anchor" href="#lru算法"><span>LRU算法：</span></a></h5><blockquote><p><strong>LRU算法是什么？</strong></p></blockquote><p>LRU 全称是<code>Least Recently Used</code>翻译为最近最少使用，会选择淘汰最近最少使用的数据。</p><p>传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素</p><p>传统的 LRU 算法存在两个问题</p><ul><li>需要用链表管理所有的缓存数据，这会带来额外的空间开销</li><li>当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能</li></ul><blockquote><p><strong>Redis是如何实现LRU算法的？</strong></p></blockquote><p>Redis 实现的是一种<strong>近似 LRU 算法</strong>，目的是为了更好的节约内存。</p><p>它的实现方式是在 Redis 的对象结构体中添加一个<strong>额外的字段</strong>，用于记录此数据的<strong>最后一次访问时间</strong>。 当 Redis 进行内存淘汰时，会使用<strong>随机采样</strong>的方式来淘汰数据它是随机取 5 个值（此值可配置），然后淘汰最久没有使用的那个</p><p><strong>优点</strong></p><ul><li>不用为所有的数据维护一个大链表，节省了空间占用</li><li>不用在每次数据访问时都移动链表项，提升了缓存的性能</li></ul><p><strong>缺点</strong></p><p>无法解决缓存污染问题，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染。因此，在 Redis 4.0 之后引入了 LFU 算法来解决这人问题。</p><h5 id="lfu算法" tabindex="-1"><a class="header-anchor" href="#lfu算法"><span>LFU算法</span></a></h5><blockquote><p>什么是LFU算法？</p></blockquote><p>LFU 全称是<code>Least Frequently Used</code>翻译为<strong>最近最不常用</strong>的，LFU 算法是根据数据访问次数来淘汰数据的它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p><p>所以，LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。</p><blockquote><p>Redis是如何实现LFU算法的？</p></blockquote><ol><li>在 LRU 算法中，Redis 对象头的 24 bits 的lru 字段是用来记录 key 的访问时间戳，因此在LRU 模式下，Redis可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key。</li><li>在LFU 算法中，Redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存诸ldt(<code>Last DecrementTime</code>)，用来记录 key 的访问时间戳；低 8bit 存储 logc(Logistic Counter)「访问频次」，用来记录 key 的访问频次。</li></ol>',32)],o={},a=(0,i(6786).A)(o,[["render",function(e,t){return(0,l.uX)(),(0,l.CE)("div",null,r)}]]),n=JSON.parse('{"path":"/demo/Redis/redis%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0.html","title":"redis的内存淘汰","lang":"zh-CN","frontmatter":{"title":"redis的内存淘汰","date":"2022-04-25T00:00:00.000Z","tags":["redis"],"categories":["redis","内存淘汰"],"description":"当Redis内存满了 在 Redis 的运行内存达到了某个阀值，就会触发内存淘汰机制，这个阀值就是我们设置的最大运行内存此值在 Redis 的配置文件中可以找到，配置项为 maxmemory。 这个时候就需要进行内存淘汰了，在redis中大体有两种策略： 不进行数据淘汰的策略 noeviction(Redis3.0之后，默认的内存淘汰策略)：它表示当运...","head":[["meta",{"property":"og:url","content":"https://flipped1001.cn/demo/Redis/redis%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0.html"}],["meta",{"property":"og:site_name","content":"Flipped"}],["meta",{"property":"og:title","content":"redis的内存淘汰"}],["meta",{"property":"og:description","content":"当Redis内存满了 在 Redis 的运行内存达到了某个阀值，就会触发内存淘汰机制，这个阀值就是我们设置的最大运行内存此值在 Redis 的配置文件中可以找到，配置项为 maxmemory。 这个时候就需要进行内存淘汰了，在redis中大体有两种策略： 不进行数据淘汰的策略 noeviction(Redis3.0之后，默认的内存淘汰策略)：它表示当运..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-10T10:25:42.000Z"}],["meta",{"property":"article:author","content":"Flipped"}],["meta",{"property":"article:tag","content":"redis"}],["meta",{"property":"article:published_time","content":"2022-04-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-10T10:25:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"redis的内存淘汰\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-04-25T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-10T10:25:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Flipped\\",\\"url\\":\\"www.flipped1001.cn\\"}]}"]]},"headers":[{"level":2,"title":"当Redis内存满了","slug":"当redis内存满了","link":"#当redis内存满了","children":[]},{"level":2,"title":"不进行数据淘汰的策略","slug":"不进行数据淘汰的策略","link":"#不进行数据淘汰的策略","children":[]},{"level":2,"title":"进行数据淘汰的策略","slug":"进行数据淘汰的策略","link":"#进行数据淘汰的策略","children":[{"level":3,"title":"1. 在设置了过期时间的数据中进行淘汰","slug":"_1-在设置了过期时间的数据中进行淘汰","link":"#_1-在设置了过期时间的数据中进行淘汰","children":[]},{"level":3,"title":"2. 在所有数据范围内进行淘汰","slug":"_2-在所有数据范围内进行淘汰","link":"#_2-在所有数据范围内进行淘汰","children":[]},{"level":3,"title":"LRU算法和LFU算法","slug":"lru算法和lfu算法","link":"#lru算法和lfu算法","children":[]}]}],"git":{"createdTime":1723285542000,"updatedTime":1723285542000,"contributors":[{"name":"flipped1001","email":"3154147351@qq.com","commits":1}]},"readingTime":{"minutes":3.91,"words":1174},"filePathRelative":"demo/Redis/redis的内存淘汰.md","localizedDate":"2022年4月25日","excerpt":"<h2>当Redis内存满了</h2>\\n<p>在 Redis 的运行内存达到了某个<strong>阀值</strong>，就会触发<strong>内存淘汰机制</strong>，这个阀值就是我们设置的最大运行内存此值在 Redis 的配置文件中可以找到，配置项为 maxmemory。</p>\\n<p>这个时候就需要进行内存淘汰了，在redis中大体有两种策略：</p>\\n<h2>不进行数据淘汰的策略</h2>\\n<p><code>noeviction</code>(Redis3.0之后，默认的内存淘汰策略)：它表示当运行内存超过最大设置内存时，不淘汰任何数据，而是不再提供服务，直接返回错误。</p>","autoDesc":true}')}}]);