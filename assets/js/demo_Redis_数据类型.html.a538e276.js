"use strict";(self.webpackChunkvuepress_theme_hope_template=self.webpackChunkvuepress_theme_hope_template||[]).push([[8270],{6786:(s,i)=>{i.A=(s,i)=>{const n=s.__vccOpts||s;for(const[s,a]of i)n[s]=a;return n}},7581:(s,i,n)=>{n.r(i),n.d(i,{comp:()=>d,data:()=>k});var a=n(2758);const e=n.p+"assets/img/2024-08-10-15-08-58.814a2a6c.png",l=n.p+"assets/img/2024-08-10-15-08-46.5f2c9858.png",p=n.p+"assets/img/2024-08-10-15-09-46.1bcc028e.png",t=[(0,a.Fv)('<h1 id="redis常用的数据类型" tabindex="-1"><a class="header-anchor" href="#redis常用的数据类型"><span>Redis常用的数据类型</span></a></h1><h2 id="redis常用的数据类型-以及他的底层实现" tabindex="-1"><a class="header-anchor" href="#redis常用的数据类型-以及他的底层实现"><span><strong>redis常用的数据类型，以及他的底层实现</strong></span></a></h2><figure><img src="'+e+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_1-string" tabindex="-1"><a class="header-anchor" href="#_1-string"><span>1.string</span></a></h2><h3 id="底层原理" tabindex="-1"><a class="header-anchor" href="#底层原理"><span>底层原理</span></a></h3><p>String：Key-Value，底层是int和SDS（简单的动态字符串）</p><p>SDS相比于原生的C字符串L:</p><ul><li><p><strong>SDS不仅可以保存文本数据，还可以保存二进制数据</strong>。因为 SDS 使用 len 属性的值而不是空字符判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。</p></li><li><p><strong>SDS 获取字符串长度的时间复杂度是 0(1)</strong>。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 0(n);而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 0(1)。</p></li><li><p><strong>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</strong>。因为 SDS 在拼接字符串之前会检查SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</p><p>字符串对象的内部编码 (encoding) 有3 种: int、raw和 embstr.</p></li></ul><p><code>embstr</code>编码是专门用于保存短字符串的一种优化编码方式，<code>row</code>编码是用来存储长字符串的</p><p>可以看到<code>embstr</code>和<code>raw</code>编码都会使用<code>SDS</code>来保存值，但不同之处在于<code>embstr</code>会通过一次内存分配函数来分配一块连续的内存空间来保存<code>redisObject</code>和<code>SDS</code>，而<code>raw</code>编码会通过调用两次内存分配函数来分别分配两块空间来保存<code>redisObject</code>和<code>SDS</code>。</p><ul><li>embstr 编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次</li><li>释放embstr 编码的字符串对象同样只需要调用一次内存释放函数:</li><li>因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用 CPU 缓存提升性能。</li></ul><p>但是 embstr 也有缺点的:</p><p>如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，所以embsti编码的字符串对象实际上是只读的，redis没有为embstr编码的字符串对象编写任何相应的修改程序。当我们对embstr编码的字符串对象执行任何修改命令(例如append) 时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令</p><h3 id="常用命令" tabindex="-1"><a class="header-anchor" href="#常用命令"><span>常用命令</span></a></h3><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 设置 key</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">value 类型的值</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> SET name lin</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">OK</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 根据 key 获得对应的 value</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> GET name</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;lin&quot;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 判断某个 key 是否存在</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> EXISTS name</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(integer) </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 返回 key 所储存的字符串值的长度</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> STRLEN name</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(integer)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 删除某个 key 对应的值</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> DEL name</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(integer)</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 批量设置 key</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">value 类型的值</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> MSET key1 value1 key2 value2</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">OK</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 批量获取多个 key 对应的 value</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> MGET key1 key2</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;value1&quot;</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;value2&#39;</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"># 设置 key-value 类型的值</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&gt; SET number 0</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">OK</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"># 将 key 中储存的数字值增</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&gt; INCR number</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">(integer)1</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"># 将key中存储的数字值加 10</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&gt; INCRBY number 10</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">(integer) 11</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">#将 key 中储存的数字值减1</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&gt; DECR number</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">(integer) 10</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"># 将key中存储的数字值减 10</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&gt; DECRBY number 10</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">(integer)</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"># 设置 key 在 60 秒后过期 (该方法是针对已经存在的key设置过期时间)</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&gt; EXPIRE name 60</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">(integer)1</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"># 查看数据还有多久过期</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&gt; TTL name</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">(integer)51</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">#设置 key-value 类型的值，并设置该key的过期时间为 60 秒</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&gt; SET key value EX 60</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">OK</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&gt; SETEX key 60 value</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">OK</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">#不存在就插入 (not exists)</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&gt; SETNX key value</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">(integer)1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h3><p>缓存，常规计数场景像访问次数、转发等</p><blockquote><p>分布式锁：SET 命令有个 NX 参数可以实现 [key不存在才插入]，可以用它来实现分布式锁</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">SET lock_key unique_value NX PX </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">10000</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功</li><li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</li></ul><p>SetNX加锁，可以设置一个过期时间。如果想要解除锁，就要把lock_key删除掉，在此之前需要判断这个客户端是不是加锁的那个。这就是两步，所以就可以使用lua脚本，在Resids中执行lua脚本是可以以原子性进行。</p></blockquote><p>共享session信息</p><h2 id="_2-list" tabindex="-1"><a class="header-anchor" href="#_2-list"><span>2.List</span></a></h2><h3 id="底层原理-1" tabindex="-1"><a class="header-anchor" href="#底层原理-1"><span>底层原理</span></a></h3><p><strong>List 列表是简单的字符串列表</strong>，按照插入顺序排序，可以从头部或尾部向 List 列表添加元素，列表的最大长度为 2^32 - 1 ，也即每个列表支持超过 40 亿 个元素</p><p><strong>List 类型的底层数据结构是由双向链表或压缩列表实现的:</strong></p><ul><li><p>如果列表的元素个数小于 512 个(默认值，可由 list-max-ziplist-entries 配置)，列表每个元素的值都小于 64 字节(默认值，可由 list-max-ziplist-value 配置)，Redis 会使用压缩列表作为List 类型的底层数据结构;</p></li><li><p>如果列表的元素不满足上面的条件，Redis 会使用双向链表作为 List 类型的底层数据结构；</p><p>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表。</strong></p></li></ul><h3 id="常用命令-1" tabindex="-1"><a class="header-anchor" href="#常用命令-1"><span>常用命令</span></a></h3><div class="language-c# line-numbers-mode" data-highlighter="shiki" data-ext="c#" data-title="c#" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 将一个或多个值value插入到key列表的表头(最左边),最后的值在最前面</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">LPUSH</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> key</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> ...]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 将一个或多个值value插入到key列表的表尾(最右边)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">RPUSH</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> key</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> ...]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 移除并返回key列表的头元素</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">LPOP</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> key</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 移除并返回key列表的尾元素</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">RPOP</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> key</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 返回列表key中指定区间内的元素,区间以偏移量start和stop指定,从0开始</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">LRANGE</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> key</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> start</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> stop</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 从key列表表头弹出一个元素,没有就阻塞timeout秒,如果timeout=0则一直阻塞</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">BLPOP</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> key</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">key</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> ..</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.] </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">timeout</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 从key列表表尾弹出一个元素,没有就阻塞timeout秒,如果timeout=0则一直阻塞</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">BRPOP</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> key</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">key</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> ..</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.] </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">timeout</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用场景-1" tabindex="-1"><a class="header-anchor" href="#使用场景-1"><span>使用场景</span></a></h3><p>消息队列：<strong>消息保序、处理重复的消息和保证消息可靠性</strong></p><ul><li>List本身就是先进先出的顺序对数据进行存取LPUSH + RPOP（左进右出），<strong>阻塞读取：使用 BRPOP；</strong></li><li>要实现处理重复消息，每一个消息都一个全局ID。消费者要记录已经处理过的消息ID，后续在收到消息的时候，将ID与已经处理的进行比较。<strong>List本身不会生成，需要我们自己生成然后插入List</strong></li><li>将读取的List进行备份，防止在处理过程中造成数据丢失,<code>BRPOPLPUSH</code>在每次读取的时候将元素加到另一个List</li></ul><p>缺点：不支持消费组的形式，因为在一个消费者读取之后list就被弹出来</p><h2 id="_3-hash" tabindex="-1"><a class="header-anchor" href="#_3-hash"><span>3.Hash</span></a></h2><h3 id="底层原理-2" tabindex="-1"><a class="header-anchor" href="#底层原理-2"><span>底层原理</span></a></h3><p>Hash 是一个键值对（key - value）集合，其中 value 的形式如：<code>value=[{field1，value1}，...{fieldN，valueN}]</code>。Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的</p><ul><li>如果列表的元素个数小于 512 个(默认值，可由 list-max-ziplist-entries 配置)，列表每个元素的值都小于 64 字节(默认值，可由 list-max-ziplist-value 配置)，<strong>Redis 会使用压缩列表作为List 类型的底层数据结构</strong></li><li>如果不满足上面的情况，就会使用<strong>哈希表</strong>作为底层数据结构</li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong></p><h3 id="常用命令-2" tabindex="-1"><a class="header-anchor" href="#常用命令-2"><span>常用命令</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 存储一个哈希表key的键值</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">HSET key field value</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 获取哈希表key对应的field键值</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">HGET key field</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 在一个哈希表key中存储多个键值对</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">HMSET key field value [field value...]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 批量获取哈希表key中多个field键值</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">HMGET key field [field ...]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 删除哈希表key中的field键值</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">HDEL key field [field ...]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 返回哈希表key中field的数量</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">HLEN key</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 返回哈希表key中所有的键值</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">HGETALL key</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">#为哈希表key中field键的值加上增量n</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">HINCRBY key field n</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用场景-2" tabindex="-1"><a class="header-anchor" href="#使用场景-2"><span>使用场景</span></a></h3><p>缓存类型为（key，field，value），可以用来存储对象</p><p>一般对象用 String + Json 存储，对象中某些频繁变化的属性可以考虑抽出来用 Hash 类型存储。</p><p>购物车，key代表用户id，field代表商品id，value是数量</p><h2 id="_4-set" tabindex="-1"><a class="header-anchor" href="#_4-set"><span>4.Set</span></a></h2><h3 id="底层原理-3" tabindex="-1"><a class="header-anchor" href="#底层原理-3"><span>底层原理</span></a></h3><p>Set类型是一个无序并唯一的键值集合。</p><p>Set的底层是哈希表或整数集合：</p><ul><li>在数据都是整数且小于512个使用<strong>整数集合</strong></li><li>不满足上面就是用<strong>哈希表</strong></li></ul><h3 id="常用命令-3" tabindex="-1"><a class="header-anchor" href="#常用命令-3"><span>常用命令</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 往集合key中存入元素，元素存在则忽略，若key不存在则新建</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">SADD key member [member ...]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 从集合key中删除元素</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">SREM key member [member ...]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 获取集合key中所有元素</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">SMEMBERS key</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 获取集合key中的元素个数</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">SCARD key</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 判断member元素是否存在于集合key中</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">SISMEMBER key member</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">#从集合key中随机选出count个元素，元素不从key中删除</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">SRANDMEMBER key [count]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 从集合key中随机选出count个元素，元素从key中删除</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">spop key [count]</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 交集运算</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">SINTER key [key ...]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 将交集结果存入新集合destination中</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">SINTERSTORE destination key [key...]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 并集运算</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">SUNION key [key]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 将并集结果存入新集合destination中</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">SUNIONSTORE destination key [key ...]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">            </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 差集运算</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">SDIFF key [key ...]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 将差集结果存入新集合destination中</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">SDIFFSTORE destination key [key ...]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用场景-3" tabindex="-1"><a class="header-anchor" href="#使用场景-3"><span>使用场景</span></a></h3><p>Set的交、并、差集，计算复杂度较高，在数据量较大的时候，执行会导致redis阻塞（可以采用主从集群，在从库中计算返回数据给主库）。</p><ul><li>点赞，可以确保一个用户只能点一次</li><li>计算两个之间的交集，可以用开计算共同关注的好友、公众号等。</li><li>抽奖，可以确保一个用户在中奖之后就把它踢出</li></ul><h2 id="_5-zset" tabindex="-1"><a class="header-anchor" href="#_5-zset"><span>5.Zset</span></a></h2><h3 id="底层原理-4" tabindex="-1"><a class="header-anchor" href="#底层原理-4"><span>底层原理</span></a></h3><p>比<code>Set</code>多另一个排序分值<code>score</code>（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是排序值。</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Zset的底层实现是<strong>压缩列表</strong>或<strong>跳表</strong>：</p><ul><li><p>如果有序集合的元素个数小于 128个，并且每个元素的值小于 64 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</p></li><li><p>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构;</p><p>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 <strong>listpack</strong> 数据结构来实现了</p></li></ul><h3 id="常用命令-4" tabindex="-1"><a class="header-anchor" href="#常用命令-4"><span>常用命令</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 往有序集合key中加入带分值元素</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">ZADD key score member [[score member]...]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 往有序集合key中删除元素</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">ZREM key member [member ...]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 返回有序集合key中元素member的分值</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">ZSCORE key member</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 返回有序集合key中元素个数</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">ZCARD key</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 为有序集合key中元素member的分值加上increment</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">ZINCRBY key increment member</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 正序获取有序集合key从start下标到stop下标的元素</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">ZRANGE key start stop [WITHSCORES]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 倒序获取有序集合key从start下标到stop下标的元素</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">ZREVRANGE key start stop [WITHSCORES]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 返回有序集合中指定分数区间内的成员，分数由低到高排序</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 返回指定成员区间内的成员，按字典正序排列，分数必须相同。</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">ZRANGEBYLEX key min max [LIMIT offset count]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 返回指定成员区间内的成员，按字典倒序排列，分数必须相同</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">ZREVRANGEBYLEX key max min [LIMIT offset count]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 并集计算(相同元素分值相加)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">ZUNIONSTORE destkey numberkeys key [key...]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 交集计算(相同元素分值相加)，numberkeys代表有多少个集合，WEIGHTS 你可以为键指定权重最后分值会乘以你设置的权重</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">ZINTERSTORE destkey numberkeys key [key...]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用场景-4" tabindex="-1"><a class="header-anchor" href="#使用场景-4"><span>使用场景</span></a></h3><p>排行榜，对电话姓名进行排序</p><h2 id="_6-bitmap" tabindex="-1"><a class="header-anchor" href="#_6-bitmap"><span>6.BitMap</span></a></h2><h3 id="底层原理-5" tabindex="-1"><a class="header-anchor" href="#底层原理-5"><span>底层原理</span></a></h3><p>用一串连续的二进制数组（用bit来进行<code>0|1</code>的设置），使用String 类型作为底层数据结构实现的一种统计二值状态的数据类型</p><h3 id="常用命令-5" tabindex="-1"><a class="header-anchor" href="#常用命令-5"><span>常用命令</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 设置值，其中value只能是0 和 </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">SETBIT key offset value</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 获取值</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">GETBIT key offset</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 获取指定范围内值为 </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> 的个数</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># start 和 end 以字节为单位</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">BITCOUNT key start end</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># BitMap间的运算</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># operations 位移操作符，枚举值</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># AND 与运算 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&amp;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># OR 或运算</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># XOR 异或</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">^</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># NOT 取反</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># result 计算的结果，会存储在该key中</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># keyl ... keyn 参与运算的key，可以有多个，空格分割，not运算只能一个key</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">。返回值# 是保存到 destket</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">BITOp [operations] [result] [key1] [keyn...]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"># 返回指定key中第一次出现指定value(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)的位置</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">BITPOS [key] [valuel]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用场景-5" tabindex="-1"><a class="header-anchor" href="#使用场景-5"><span>使用场景</span></a></h3><p>签到统计，可以找到首次打卡时间</p><p>判断用户登录态，连续签到用户总数</p>',70)],h={},d=(0,n(6786).A)(h,[["render",function(s,i){return(0,a.uX)(),(0,a.CE)("div",null,t)}]]),k=JSON.parse('{"path":"/demo/Redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html","title":"redis常用的数据类型","lang":"zh-CN","frontmatter":{"title":"redis常用的数据类型","date":"2022-03-18T00:00:00.000Z","tags":["redis"],"categories":["redis","数据类型"],"description":"Redis常用的数据类型 redis常用的数据类型，以及他的底层实现 1.string 底层原理 String：Key-Value，底层是int和SDS（简单的动态字符串） SDS相比于原生的C字符串L: SDS不仅可以保存文本数据，还可以保存二进制数据。因为 SDS 使用 len 属性的值而不是空字符判断字符串是否结束，并且 SDS 的所有 API ...","head":[["meta",{"property":"og:url","content":"https://flipped1001.cn/demo/Redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html"}],["meta",{"property":"og:site_name","content":"Flipped"}],["meta",{"property":"og:title","content":"redis常用的数据类型"}],["meta",{"property":"og:description","content":"Redis常用的数据类型 redis常用的数据类型，以及他的底层实现 1.string 底层原理 String：Key-Value，底层是int和SDS（简单的动态字符串） SDS相比于原生的C字符串L: SDS不仅可以保存文本数据，还可以保存二进制数据。因为 SDS 使用 len 属性的值而不是空字符判断字符串是否结束，并且 SDS 的所有 API ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-10T10:25:42.000Z"}],["meta",{"property":"article:author","content":"Flipped"}],["meta",{"property":"article:tag","content":"redis"}],["meta",{"property":"article:published_time","content":"2022-03-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-10T10:25:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"redis常用的数据类型\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-03-18T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-10T10:25:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Flipped\\",\\"url\\":\\"www.flipped1001.cn\\"}]}"]]},"headers":[{"level":2,"title":"redis常用的数据类型，以及他的底层实现","slug":"redis常用的数据类型-以及他的底层实现","link":"#redis常用的数据类型-以及他的底层实现","children":[]},{"level":2,"title":"1.string","slug":"_1-string","link":"#_1-string","children":[{"level":3,"title":"底层原理","slug":"底层原理","link":"#底层原理","children":[]},{"level":3,"title":"常用命令","slug":"常用命令","link":"#常用命令","children":[]},{"level":3,"title":"使用场景","slug":"使用场景","link":"#使用场景","children":[]}]},{"level":2,"title":"2.List","slug":"_2-list","link":"#_2-list","children":[{"level":3,"title":"底层原理","slug":"底层原理-1","link":"#底层原理-1","children":[]},{"level":3,"title":"常用命令","slug":"常用命令-1","link":"#常用命令-1","children":[]},{"level":3,"title":"使用场景","slug":"使用场景-1","link":"#使用场景-1","children":[]}]},{"level":2,"title":"3.Hash","slug":"_3-hash","link":"#_3-hash","children":[{"level":3,"title":"底层原理","slug":"底层原理-2","link":"#底层原理-2","children":[]},{"level":3,"title":"常用命令","slug":"常用命令-2","link":"#常用命令-2","children":[]},{"level":3,"title":"使用场景","slug":"使用场景-2","link":"#使用场景-2","children":[]}]},{"level":2,"title":"4.Set","slug":"_4-set","link":"#_4-set","children":[{"level":3,"title":"底层原理","slug":"底层原理-3","link":"#底层原理-3","children":[]},{"level":3,"title":"常用命令","slug":"常用命令-3","link":"#常用命令-3","children":[]},{"level":3,"title":"使用场景","slug":"使用场景-3","link":"#使用场景-3","children":[]}]},{"level":2,"title":"5.Zset","slug":"_5-zset","link":"#_5-zset","children":[{"level":3,"title":"底层原理","slug":"底层原理-4","link":"#底层原理-4","children":[]},{"level":3,"title":"常用命令","slug":"常用命令-4","link":"#常用命令-4","children":[]},{"level":3,"title":"使用场景","slug":"使用场景-4","link":"#使用场景-4","children":[]}]},{"level":2,"title":"6.BitMap","slug":"_6-bitmap","link":"#_6-bitmap","children":[{"level":3,"title":"底层原理","slug":"底层原理-5","link":"#底层原理-5","children":[]},{"level":3,"title":"常用命令","slug":"常用命令-5","link":"#常用命令-5","children":[]},{"level":3,"title":"使用场景","slug":"使用场景-5","link":"#使用场景-5","children":[]}]}],"git":{"createdTime":1723285542000,"updatedTime":1723285542000,"contributors":[{"name":"flipped1001","email":"3154147351@qq.com","commits":1}]},"readingTime":{"minutes":11.24,"words":3373},"filePathRelative":"demo/Redis/数据类型.md","localizedDate":"2022年3月18日","excerpt":"\\n<h2><strong>redis常用的数据类型，以及他的底层实现</strong></h2>\\n<figure><figcaption></figcaption></figure>\\n<figure><figcaption></figcaption></figure>\\n<h2>1.string</h2>\\n<h3>底层原理</h3>\\n<p>String：Key-Value，底层是int和SDS（简单的动态字符串）</p>\\n<p>SDS相比于原生的C字符串L:</p>\\n<ul>\\n<li>\\n<p><strong>SDS不仅可以保存文本数据，还可以保存二进制数据</strong>。因为 SDS 使用 len 属性的值而不是空字符判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。</p>\\n</li>\\n<li>\\n<p><strong>SDS 获取字符串长度的时间复杂度是 0(1)</strong>。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 0(n);而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 0(1)。</p>\\n</li>\\n<li>\\n<p><strong>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</strong>。因为 SDS 在拼接字符串之前会检查SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</p>\\n<p>字符串对象的内部编码 (encoding) 有3 种: int、raw和 embstr.</p>\\n</li>\\n</ul>","autoDesc":true}')}}]);