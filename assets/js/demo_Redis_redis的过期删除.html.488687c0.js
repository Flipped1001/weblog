"use strict";(self.webpackChunkvuepress_theme_hope_template=self.webpackChunkvuepress_theme_hope_template||[]).push([[4157],{6786:(e,t)=>{t.A=(e,t)=>{const i=e.__vccOpts||e;for(const[e,s]of t)i[e]=s;return i}},9927:(e,t,i)=>{i.r(t),i.d(t,{comp:()=>o,data:()=>l});var s=i(2758);const n=i.p+"assets/img/2024-08-10-15-20-15.5445d558.png",r=[(0,s.Fv)('<p>当我们对Key设置过期时间，Redis就将这个Key和我们设置的过期时间保存到<strong>过期字典</strong></p><p>当我们查询一个Key的时候，就会先去查看字典中是否有：</p><ul><li>如果不在，就正常获取</li><li>如果在，去找到这个key对应的过期时间和系统时间进行比较，没有过期就查询，过期删除</li></ul><p><strong>Redis采用「惰性删除+定期删除」的策略</strong></p><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="惰性删除" tabindex="-1"><a class="header-anchor" href="#惰性删除"><span>惰性删除</span></a></h2><p>不主动删除过期键，每次访问的时候，会去查询Key是否过期，如果过期删除</p><p><strong>优点</strong> 因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，情性删除策略对 CPU 友好</p><p><strong>缺点</strong> 如果一个 key 已经过期，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好</p><h2 id="定期删除" tabindex="-1"><a class="header-anchor" href="#定期删除"><span>定期删除</span></a></h2><p>每隔一段时间[随机]从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</p><p>Redis 的定期删除的流程:</p><ol><li><p>从过期字典中随机抽取 20 个 key;</p></li><li><p>检查这 20 个 key 是否过期，并删除已过期的 key;</p></li><li><p>如果本轮检查的已过期 key 的数量，超过 5个(20/4)，也就是[已过期 key 的数量] 占比随机抽取 key 的数量] 大于 25%，则继续重复步 1; 如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。</p></li></ol><p>Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms。</p><p><strong>优点</strong> 通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。</p><p><strong>缺点</strong> 难以确定删除操作执行的时长和频率。如果执行的太频繁，就会对 CPU 不友好，如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。</p><h2 id="定时删除" tabindex="-1"><a class="header-anchor" href="#定时删除"><span>定时删除</span></a></h2><p>定时删除策略的做法是，在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作。</p><p><strong>优点</strong> 可以保证过期 key 会被尽快删除，也就是内存可以被尽快地释放。因此，定时删除对内存是最友好的</p><p><strong>缺点</strong> 在过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间，在内存不紧张 CPU 时间紧张的情况下，将 CPU 时间用于删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。所以，定时删除策略对 CPU 不友好。</p><h3 id="redis持久化时对过期键的处理" tabindex="-1"><a class="header-anchor" href="#redis持久化时对过期键的处理"><span><strong>Redis持久化时对过期键的处理</strong></span></a></h3><p>RDB文件有两个阶段，文件生成和文件加载阶段</p><ol><li>RDB 文件生成阶段：从内存状态持久化成 RDB (文件)的时候，会对 key 进行过期检查，过期的键[不会] 被保存到新的 RDB 文件中，因此 Redis 中的过期键不会对生成新 RDB 文件产生任何影响。</li><li>RDB 加载阶段：RDB 加载阶段时，要看服务器是<strong>主服务器还是从服务器</strong>，分别对应以下两种情况: <ul><li>如果 Redis 是**[主服务器]<strong>运行模式的话，在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键</strong>[不会] 被载入到数据库**中。所以过期键不会对载入 RDB 文件的主服务器造成影响</li><li>如果 Redis 是**[从服务器]<strong>运行模式的话，在载入 RDB 文件时，不论键是否过期都会</strong>被载入到数据库**中。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。所以一般来说，过期键对载入 RDB 文件的从服务器也不会造成影响。</li></ul></li></ol><p>AOF 文件分为两个阶段，AOF 文件写入阶段和 AOF 重写阶段。</p><ol><li>AOF 文件写入阶段：当 Redis 以 AOF 模式持久化时，如果数据库某个过期键还没被除，那么 AOF 文件会<strong>保留此过期键</strong>，当此过期键被删除后，Redis 会 AOF 文件追加一条 <strong>DEL 命令</strong>来显式地除该键值</li><li>AOF 重写阶段：执行 AOF 重写时，会对 Redis 中的键值对进行检查，已过期的键<strong>不会被保存</strong>到重写后的 AOF 文件中，因此不会对 AOF 重写造成任何影响。</li></ol><h3 id="在主从模式下对过期键的处理" tabindex="-1"><a class="header-anchor" href="#在主从模式下对过期键的处理"><span><strong>在主从模式下对过期键的处理</strong></span></a></h3><p>当 Redis 运行在主从模式下时，从库<strong>不会进行过期扫描</strong>，从库对过期的处理是<strong>被动</strong>的。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。</p><p>从库的过期键处理依靠主服务器控制，主库在 key 到期时，会在 AOF 文里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指今来删除过期的 key。</p>',28)],p={},o=(0,i(6786).A)(p,[["render",function(e,t){return(0,s.uX)(),(0,s.CE)("div",null,r)}]]),l=JSON.parse('{"path":"/demo/Redis/redis%E7%9A%84%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4.html","title":"Redis过期删除","lang":"zh-CN","frontmatter":{"title":"Redis过期删除","date":"2022-03-30T00:00:00.000Z","tags":["redis"],"categories":["redis","过期删除"],"description":"当我们对Key设置过期时间，Redis就将这个Key和我们设置的过期时间保存到过期字典 当我们查询一个Key的时候，就会先去查看字典中是否有： 如果不在，就正常获取 如果在，去找到这个key对应的过期时间和系统时间进行比较，没有过期就查询，过期删除 Redis采用「惰性删除+定期删除」的策略 惰性删除 不主动删除过期键，每次访问的时候，会去查询Key是...","head":[["meta",{"property":"og:url","content":"https://flipped1001.cn/demo/Redis/redis%E7%9A%84%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4.html"}],["meta",{"property":"og:site_name","content":"Flipped"}],["meta",{"property":"og:title","content":"Redis过期删除"}],["meta",{"property":"og:description","content":"当我们对Key设置过期时间，Redis就将这个Key和我们设置的过期时间保存到过期字典 当我们查询一个Key的时候，就会先去查看字典中是否有： 如果不在，就正常获取 如果在，去找到这个key对应的过期时间和系统时间进行比较，没有过期就查询，过期删除 Redis采用「惰性删除+定期删除」的策略 惰性删除 不主动删除过期键，每次访问的时候，会去查询Key是..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-10T10:25:42.000Z"}],["meta",{"property":"article:author","content":"Flipped"}],["meta",{"property":"article:tag","content":"redis"}],["meta",{"property":"article:published_time","content":"2022-03-30T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-10T10:25:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis过期删除\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-03-30T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-10T10:25:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Flipped\\"}]}"]]},"headers":[{"level":2,"title":"惰性删除","slug":"惰性删除","link":"#惰性删除","children":[]},{"level":2,"title":"定期删除","slug":"定期删除","link":"#定期删除","children":[]},{"level":2,"title":"定时删除","slug":"定时删除","link":"#定时删除","children":[{"level":3,"title":"Redis持久化时对过期键的处理","slug":"redis持久化时对过期键的处理","link":"#redis持久化时对过期键的处理","children":[]},{"level":3,"title":"在主从模式下对过期键的处理","slug":"在主从模式下对过期键的处理","link":"#在主从模式下对过期键的处理","children":[]}]}],"git":{"createdTime":1723285542000,"updatedTime":1723285542000,"contributors":[{"name":"flipped1001","email":"3154147351@qq.com","commits":1}]},"readingTime":{"minutes":4.76,"words":1427},"filePathRelative":"demo/Redis/redis的过期删除.md","localizedDate":"2022年3月30日","excerpt":"<p>当我们对Key设置过期时间，Redis就将这个Key和我们设置的过期时间保存到<strong>过期字典</strong></p>\\n<p>当我们查询一个Key的时候，就会先去查看字典中是否有：</p>\\n<ul>\\n<li>如果不在，就正常获取</li>\\n<li>如果在，去找到这个key对应的过期时间和系统时间进行比较，没有过期就查询，过期删除</li>\\n</ul>\\n<p><strong>Redis采用「惰性删除+定期删除」的策略</strong></p>\\n<figure><figcaption></figcaption></figure>\\n<h2>惰性删除</h2>\\n<p>不主动删除过期键，每次访问的时候，会去查询Key是否过期，如果过期删除</p>","autoDesc":true}')}}]);