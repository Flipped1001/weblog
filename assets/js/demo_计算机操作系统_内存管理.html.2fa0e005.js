"use strict";(self.webpackChunkvuepress_theme_hope_template=self.webpackChunkvuepress_theme_hope_template||[]).push([[4374],{2789:(i,e)=>{e.A=(i,e)=>{const a=i.__vccOpts||i;for(const[i,t]of e)a[i]=t;return a}},7479:(i,e,a)=>{a.r(e),a.d(e,{comp:()=>E,data:()=>_});var t=a(7829);const n=a.p+"assets/img/2024-05-30-16-04-38.4beab040.png",r=a.p+"assets/img/2024-05-30-16-05-41.f6b87cb9.png",s=a.p+"assets/img/2024-05-30-16-06-30.0d15c3e7.png",l=a.p+"assets/img/2024-05-30-16-07-04.396f58a8.png",p=a.p+"assets/img/2024-05-30-16-08-52.3e20ab41.png",g=a.p+"assets/img/2024-05-30-16-10-11.6ab82cbb.png",o=a.p+"assets/img/2024-05-30-16-11-05.e6ed06ed.png",c=a.p+"assets/img/2024-05-30-16-11-30.97396840.png",d=a.p+"assets/img/2024-05-30-16-12-02.96a4d0e8.png",h=a.p+"assets/img/2024-05-30-16-12-18.da402509.png",f=a.p+"assets/img/2024-05-30-16-12-36.7d35b110.png",u=a.p+"assets/img/2024-05-30-16-12-57.71c08739.png",m=a.p+"assets/img/2024-05-30-16-13-18.bdec3649.png",b=a.p+"assets/img/2024-05-30-16-13-34.f54f0f71.png",x=a.p+"assets/img/2024-05-30-16-13-47.1ce2d2e0.png",B=(0,t.Fv)('<h1 id="内存管理" tabindex="-1"><a class="header-anchor" href="#内存管理"><span>内存管理</span></a></h1><h2 id="_1-虚拟内存" tabindex="-1"><a class="header-anchor" href="#_1-虚拟内存"><span>1. 虚拟内存</span></a></h2><h3 id="问题背景" tabindex="-1"><a class="header-anchor" href="#问题背景"><span>问题背景</span></a></h3><p>单片机没有操作系统，每次都是直接操作内存的物理地址。这种情况下，无法同时运行两个程序。操作系统通过为每个进程分配<strong>虚拟内存地址</strong>来解决这个问题。</p><p><strong>操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来</strong></p><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h3><ul><li><strong>虚拟内存地址</strong>（Virtual Memory Address）：程序使用的内存地址。</li><li><strong>物理内存地址</strong>（Physical Memory Address）：实际存在于硬件中的内存地址。</li></ul><p>操作系统通过<strong>内存分段</strong>和<strong>内存分页</strong>来控制虚拟内存和物理内存地址的映射。</p><h3 id="_1-1-内存分段" tabindex="-1"><a class="header-anchor" href="#_1-1-内存分段"><span>1.1 内存分段</span></a></h3><p>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。<strong>不同的段是有不同的属性的，所以就用分段（<em>Segmentation</em>）的形式把这些段分离出来。</strong></p><p>虚拟地址由两部分组成：<strong>段选择因子</strong>和<strong>段内偏移量</strong>。</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong>段选择子</strong>保存在段寄存器里，包含<strong>段号</strong>，用于段表的索引。段表包含段的基地址、段的界限和特权等级等。</li><li><strong>段内偏移量</strong>在0和段界限之间。如果段内偏移量合法，段基地址加上段内偏移量得到物理内存地址。</li></ul><p>每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址，如下图：</p><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>例如，访问段3中偏移量500的虚拟地址，计算物理地址为段3基地址7000 + 偏移量500 = 7500。</p><h4 id="内存碎片" tabindex="-1"><a class="header-anchor" href="#内存碎片"><span>内存碎片</span></a></h4><p>什么是内存碎片：</p><blockquote><p>我们来看看这样一个例子。假设有 1G 的物理内存，用户执行了多个程序，其中：</p><ul><li>游戏占用了 512MB 内存</li><li>浏览器占用了 128MB 内存</li><li>音乐占用了 256 MB 内存。</li></ul><p>这个时候，如果我们关闭了浏览器，则空闲内存还有 1024 - 512 - 256 = 256MB。</p><p>如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></blockquote><ul><li><strong>内部内存碎片</strong>：分段管理能根据需求分配内存，不会出现。</li><li><strong>外部内存碎片</strong>：由于段长度不固定，多个段未必能恰好使用所有内存空间，导致不连续的小物理内存，无法装载新程序。</li></ul><p><strong>解决方法：内存交换</strong></p><p>通过把内存写到硬盘上，然后重新加载到紧跟已占用内存后面，空缺出连续的空间。例如在Linux系统中，Swap空间用于内存与硬盘的交换。</p><h4 id="内存交换效率低" tabindex="-1"><a class="header-anchor" href="#内存交换效率低"><span>内存交换效率低</span></a></h4><p>分段方式容易产生外部内存碎片，导致重新Swap内存区域，性能下降。硬盘访问速度比内存慢很多，每次内存交换都需把大段连续内存数据写到硬盘。</p><p>为解决分段的外部内存碎片和低效问题，出现了内存分页。</p><h3 id="_1-2-内存分页" tabindex="-1"><a class="header-anchor" href="#_1-2-内存分页"><span>1.2 内存分页</span></a></h3><p>分页把整个虚拟和物理内存空间切成固定大小的段，称为<strong>页</strong>（Page），在Linux下每页大小为4KB。</p><p>虚拟地址与物理地址之间通过<strong>页表</strong>来映射，页表是存储在内存里的，<strong>内存管理单元</strong> （<em>MMU</em>）就做将虚拟内存地址转换成物理地址的工作。</p><p>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个<strong>缺页异常</strong>，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p><p>虚拟地址分为<strong>页号</strong>和<strong>页内偏移</strong>。页号作为页表的索引，页表包含物理页所在物理内存的基地址。基地址与页内偏移组合形成物理内存地址。</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>总结：内存地址转换的三个步骤：</p><ol><li>虚拟内存地址切分成页号和偏移量。</li><li>根据页号，从页表查询对应的物理页号。</li><li>物理页号加上偏移量，得到物理内存地址。</li></ol><p>分页解决了内存碎片问题，但由于最小分配单位是一页，页内会出现内存浪费，即<strong>内部内存碎片</strong>。</p><p>如果内存空间不足，操作系统会释放其他进程中最近未使用的内存页面（Swap Out），并在需要时再加载进来（Swap In）。每次交换只需少数页，效率较高。</p><p>分页使得程序不需一次性加载到物理内存，按需加载页到物理内存。</p><h4 id="简单分页-有缺陷" tabindex="-1"><a class="header-anchor" href="#简单分页-有缺陷"><span>简单分页（有缺陷）</span></a></h4><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>简单分页的缺陷：有空间上的缺陷。</p><p>在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 <code>4MB</code> 的内存来存储页表。</p><p>但是每个进程都是有自己的虚拟地址空间的，<code>100</code> 个进程的话，就需要 <code>400MB</code> 的内存来存储页表位的环境了。</p><h4 id="多级页表" tabindex="-1"><a class="header-anchor" href="#多级页表"><span>多级页表</span></a></h4><p>单级页表在32位和4KB页大小环境下，一个进程的页表需装下约100万个「页表项」，每项占用4字节，页表需4MB空间。多个进程需大量内存存储页表。</p><p><strong>解决方法：二级分页</strong></p><p>把单级页表再分页，形成二级分页。一级页表分为1024个页表（每个包含1024个「页表项」），如图：</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>一级页表覆盖整个4GB虚拟地址空间，但只在需要时创建二级页表。假设20%一级页表项被用到，占用内存仅为4KB（一级页表）+ 20% * 4MB（二级页表）= 0.804MB。</p><p>多级页表推广到64位系统，形成四级目录：</p><ul><li>全局页目录项 PGD（Page Global Directory）</li><li>上层页目录项 PUD（Page Upper Directory）</li><li>中间页目录项 PMD（Page Middle Directory）</li><li>页表项 PTE（Page Table Entry）</li></ul><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="tlb" tabindex="-1"><a class="header-anchor" href="#tlb"><span>TLB</span></a></h4><p>多级页表增加地址转换工序，降低速度。程序有局部性，一段时间内执行局限于某部分。为加快速度，CPU加入了<strong>转址旁路缓存</strong>（Translation Lookaside Buffer, TLB），存放最常访问的页表项。</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>TLB在CPU内，访问快，命中率高。CPU在寻址时先查TLB，未找到再查常规页表。</p><h3 id="_1-3-段页式内存管理" tabindex="-1"><a class="header-anchor" href="#_1-3-段页式内存管理"><span>1.3 段页式内存管理</span></a></h3><p>结合内存分段和分页，形成<strong>段页式内存管理</strong>。</p><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>先将程序划分为多个逻辑段。</li><li>再把每个段划分为多个页。</li></ul><p>地址结构由<strong>段号、段内页号和页内位移</strong>组成。段表每个段有一个页表，页表中地址为物理页号，物理页号加页内位移得到物理地址。</p><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>段页式地址变换需三次内存访问：</p><ol><li>访问段表，得到页表起始地址。</li><li>访问页表，得到物理页号。</li><li>物理页号加页内位移，得到物理地址。</li></ol><p>段页式地址变换通过软硬件结合，提高内存利用率。</p><h3 id="linux内存布局" tabindex="-1"><a class="header-anchor" href="#linux内存布局"><span>Linux内存布局</span></a></h3><p>早期Intel 80386处理器设计页式内存管理时，没有绕开段式内存管理。页式内存管理在段式内存管理基础上再加一层地址映射。段式内存管理先将逻辑地址映射成线性地址，再由页式内存管理将线性地址映射成物理地址。</p><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong>逻辑地址</strong>：程序使用的地址，未映射。</li><li><strong>线性地址</strong>：通过段式内存管理映射的地址，也叫虚拟地址。</li></ul><p><strong>Linux主要采用页式内存管理，同时涉及段机制</strong>。每个段从0地址开始整个4GB虚拟空间，所有段起始地址相同，相当于屏蔽了逻辑地址概念，段用于访问控制和内存保护。</p><p>Linux虚拟地址空间分为<strong>内核空间</strong>和<strong>用户空间</strong>，不同位数系统地址空间范围不同。</p><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="内核空间与用户空间的区别" tabindex="-1"><a class="header-anchor" href="#内核空间与用户空间的区别"><span>内核空间与用户空间的区别</span></a></h4><ul><li>用户态进程只能访问用户空间内存。</li><li>进入内核态后，才可访问内核空间内存。</li></ul><p>每个进程有独立虚拟内存，但每个虚拟内存中的内核地址关联相同物理内存。进程切换到内核态后，可方便访问内核空间内存。</p><figure><img src="'+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>32位系统用户空间内存布局：</p><figure><img src="'+x+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong>代码段</strong>：二进制可执行代码。</li><li><strong>数据段</strong>：已初始化静态常量和全局变量。</li><li><strong>BSS段</strong>：未初始化静态变量和全局变量。</li><li><strong>堆段</strong>：动态分配内存，从低地址向上增长。</li><li><strong>文件映射段</strong>：动态库、共享内存等，从低地址向上增长。</li><li><strong>栈段</strong>：局部变量和函数调用上下文，从高地址向下增长，固定大小（一般为8MB）。</li></ul><p>代码段下有一段<strong>保留区</strong>，防止程序bug导致非法内存访问。</p><p>堆和文件映射段内存可动态分配，如使用C标准库的<code>malloc()</code>或<code>mmap()</code>。</p><h3 id="虚拟内存的作用" tabindex="-1"><a class="header-anchor" href="#虚拟内存的作用"><span>虚拟内存的作用</span></a></h3><h4 id="虚拟内存的功能" tabindex="-1"><a class="header-anchor" href="#虚拟内存的功能"><span>虚拟内存的功能</span></a></h4><ul><li><strong>程序大小大于物理内存</strong>：程序不需一次性装入物理内存，动态分配内存页，按需加载页到物理内存。</li><li><strong>内存保护</strong>：虚拟内存控制每个进程能访问的内存范围，防止非法内存访问。</li><li><strong>内存共享</strong>：多个进程共享相同虚拟内存页面，节省内存。</li></ul><h4 id="虚拟内存管理器" tabindex="-1"><a class="header-anchor" href="#虚拟内存管理器"><span>虚拟内存管理器</span></a></h4><p>虚拟内存的功能由<strong>虚拟内存管理器</strong>（Virtual Memory Manager, VMM）实现，功能包括内存分配、内存回收、地址映射等。</p><p><strong>总结</strong></p><p>虚拟内存是计算机系统重要技术，通过分段和分页机制，提高内存利用率，保证程序安全性，提升系统性能。理解虚拟内存有助于优化程序性能和系统资源管理。</p>',87),y={},E=(0,a(2789).A)(y,[["render",function(i,e){return(0,t.uX)(),(0,t.CE)("div",null,[(0,t.Q3)(" more "),B])}]]),_=JSON.parse('{"path":"/demo/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html","title":"内存管理","lang":"zh-CN","frontmatter":{"title":"内存管理","date":"2023-05-25T00:00:00.000Z","tags":["计算机基础","操作系统"],"categories":["操作系统"],"head":[["meta",{"property":"og:url","content":"https://flipped1001.cn/demo/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"Flipped"}],["meta",{"property":"og:title","content":"内存管理"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-16T10:13:48.000Z"}],["meta",{"property":"article:author","content":"Flipped"}],["meta",{"property":"article:tag","content":"计算机基础"}],["meta",{"property":"article:tag","content":"操作系统"}],["meta",{"property":"article:published_time","content":"2023-05-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-16T10:13:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"内存管理\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-05-25T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-16T10:13:48.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Flipped\\"}]}"]]},"headers":[{"level":2,"title":"1. 虚拟内存","slug":"_1-虚拟内存","link":"#_1-虚拟内存","children":[{"level":3,"title":"问题背景","slug":"问题背景","link":"#问题背景","children":[]},{"level":3,"title":"基本概念","slug":"基本概念","link":"#基本概念","children":[]},{"level":3,"title":"1.1 内存分段","slug":"_1-1-内存分段","link":"#_1-1-内存分段","children":[]},{"level":3,"title":"1.2 内存分页","slug":"_1-2-内存分页","link":"#_1-2-内存分页","children":[]},{"level":3,"title":"1.3 段页式内存管理","slug":"_1-3-段页式内存管理","link":"#_1-3-段页式内存管理","children":[]},{"level":3,"title":"Linux内存布局","slug":"linux内存布局","link":"#linux内存布局","children":[]},{"level":3,"title":"虚拟内存的作用","slug":"虚拟内存的作用","link":"#虚拟内存的作用","children":[]}]}],"git":{"createdTime":1721124828000,"updatedTime":1721124828000,"contributors":[{"name":"flipped1001","email":"3154147351@qq.com","commits":1}]},"readingTime":{"minutes":8.84,"words":2653},"filePathRelative":"demo/计算机操作系统/内存管理.md","localizedDate":"2023年5月25日","excerpt":""}')}}]);