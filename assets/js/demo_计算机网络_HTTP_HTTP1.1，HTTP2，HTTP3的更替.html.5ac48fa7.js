"use strict";(self.webpackChunkvuepress_theme_hope_template=self.webpackChunkvuepress_theme_hope_template||[]).push([[4611],{6786:(e,t)=>{t.A=(e,t)=>{const a=e.__vccOpts||e;for(const[e,p]of t)a[e]=p;return a}},4831:(e,t,a)=>{a.r(t),a.d(t,{comp:()=>h,data:()=>T});var p=a(2758);const n=a.p+"assets/img/2024-05-16-21-51-37.4a4feaab.png",r=a.p+"assets/img/2024-05-16-21-51-44.85d9d3df.png",i=a.p+"assets/img/2024-05-16-21-51-58.58a8f9a6.png",s=(0,p.Fv)('<h1 id="http-1-1该如何优化" tabindex="-1"><a class="header-anchor" href="#http-1-1该如何优化"><span>HTTP/1.1该如何优化</span></a></h1><h2 id="_1-如何避免发送http请求" tabindex="-1"><a class="header-anchor" href="#_1-如何避免发送http请求"><span>1.如何避免发送HTTP请求</span></a></h2><p>通过缓存技术，把URL作为key,响应作为Value，两者间映射</p><p>设置缓存时间过期之后重新请求，带上Etag头，如果一样说明资源未改变，可以使用客户端的缓存**<code>304 Not Modified</code>**</p><h2 id="_2-如何减少http请求次数" tabindex="-1"><a class="header-anchor" href="#_2-如何减少http请求次数"><span>2.如何减少HTTP请求次数</span></a></h2><p>1.减少重定向次数</p><p>将重定向的工作交给代理服务器，可以鉴赏HTTP请求次数</p><p>2.合并请求</p><p><strong>合并请求的方式就是合并资源，以一个大资源的请求替换多个小资源的请求</strong>。但是如果有一个小资源改变就需要重新下载全部</p><p>3.延迟发送请求</p><p>按需获取，当用户有需要操作时再获取资源</p><h2 id="_3-如何减少http响应的数据大小" tabindex="-1"><a class="header-anchor" href="#_3-如何减少http响应的数据大小"><span>3.如何减少HTTP响应的数据大小？</span></a></h2><p>无损压缩：解压之后和原来数据一模一样</p><p>有损压缩：和原来数据和接近</p><h1 id="http2" tabindex="-1"><a class="header-anchor" href="#http2"><span>HTTP2</span></a></h1><h2 id="_1-http的性能问题" tabindex="-1"><a class="header-anchor" href="#_1-http的性能问题"><span>1.HTTP的性能问题</span></a></h2><ul><li><p><em>消息的大小变大了</em>，<em>页面资源变多了</em> <em>内容形式变多样了</em> <em>实时性要求变高了</em></p><p>造成HTTP1.1的出现高延迟</p><p><strong>延迟高的问题来源</strong>：</p></li><li><p><em>延迟难以下降</em>，虽然现在网络的「带宽」相比以前变多了，但是延迟降到一定幅度后，就很难再下降了，说白了就是到达了延迟的下限；</p></li><li><p><em>并发连接有限</em>，谷歌浏览器最大并发连接数是 6 个，而且每一个连接都要经过 TCP 和 TLS 握手耗时，以及 TCP 慢启动过程给流量带来的影响；</p></li><li><p><em>队头阻塞问题</em>，同一连接只能在完成一个 HTTP 事务（请求和响应）后，才能处理下一个事务；</p></li><li><p><em>HTTP 头部巨大且重复</em>，由于 HTTP 协议是无状态的，每一个请求都得携带 HTTP 头部，特别是对于有携带 Cookie 的头部，而 Cookie 的大小通常很大；</p></li><li><p><em>不支持服务器推送消息</em>，因此当客户端需要获取通知时，只能通过定时器不断地拉取消息，这无疑浪费大量了带宽和服务器资源。</p></li></ul><h2 id="_2-兼容http1-1" tabindex="-1"><a class="header-anchor" href="#_2-兼容http1-1"><span>2.兼容HTTP1.1</span></a></h2><p><strong>HTTP2可以兼容HTTP1.1</strong> 1.HTTP2没有在URL中引入新的协议名，仍然使用「http://」表示明文协议，用「https://」表示加密协议。 2.只在应用层做了改变，基本改变了HTTP报文的传输格式</p><h2 id="_3-头部压缩" tabindex="-1"><a class="header-anchor" href="#_3-头部压缩"><span>3.头部压缩</span></a></h2><p>HTTP1.1的头部存在问题，太大了<strong>需要压缩</strong>,请求中大量字段重复需要<strong>避免重复性</strong>，字段需要改成<strong>二进制编码</strong></p><p>使用<strong>HPACK</strong> 算法：</p><ul><li><p>静态字典；</p></li><li><p>动态字典；</p></li><li><p>Huffman 编码（压缩算法）；</p><h3 id="静态表编码" tabindex="-1"><a class="header-anchor" href="#静态表编码"><span>静态表编码</span></a></h3></li></ul><p>HTTP/2 为高频出现在头部的字符串和字段建立了一张<strong>静态表</strong> 根据 RFC7541 规范，如果头部字段属于静态表范围，并且 Value 是变化，那么它的 HTTP/2 头部前 2 位固定为 <em>01</em></p><p>Huffman 编码的原理是将高频出现的信息用「较短」的编码表示，从而缩减字符串长度。</p><h3 id="动态编码表" tabindex="-1"><a class="header-anchor" href="#动态编码表"><span>动态编码表</span></a></h3><p>不在静态编码表的范围内时，要自行构建<strong>动态表</strong> 使得动态表生效有一个前提：<strong>必须同一个连接上，重复传输完全相同的 HTTP 头部</strong> 字典累计越来越大，会有一个限制</p><p><strong>动态表是具有时序性的，如果首次出现的请求发生了丢包，后续的收到请求，对方就无法解码出 HPACK 头部，因为对方还没建立好动态表，因此后续的请求解码会阻塞到首次请求中丢失的数据包重传过来</strong>。</p><h2 id="_4-二进制帧" tabindex="-1"><a class="header-anchor" href="#_4-二进制帧"><span>4.二进制帧</span></a></h2><p>HTTP2把报文从文本改成了二进制格式，HTTP/2 把响应报文划分成了两类<strong>帧（Frame）</strong></p><ul><li>HEADERS（首部）和 DATA（消息负载） 是帧的类型</li></ul><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>前三个字节为<strong>帧长度</strong>，帧长度后面的一个字节为<strong>帧类型</strong></p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>帧类型后面的一个字节是<strong>标志位</strong>，可以保存 8 个标志位，用于携带简单的控制信息 帧头的最后 4 个字节是<strong>流标识符</strong>（Stream ID），它的作用是用来标识该 Frame 属于哪个 Stream</p><h2 id="_5-并发传输" tabindex="-1"><a class="header-anchor" href="#_5-并发传输"><span>5.并发传输</span></a></h2><p>多个 Stream 跑在一条 TCP 连接，同一个 HTTP 请求与响应是跑在同一个 Stream 中，HTTP 消息可以由多个 Frame 构成， 一个 Frame 可以由多个 TCP 报文构成。</p><p><strong>不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ）</strong>，因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息，而<strong>同一 Stream 内部的帧必须是严格有序的</strong>。</p><p><strong>当 HTTP/2 实现 100 个并发 Stream 时，只需要建立一次 TCP 连接，而 HTTP/1.1 需要建立 100 个 TCP 连接，每个 TCP 连接都要经过 TCP 握手、慢启动以及 TLS 握手过程，这些都是很耗时的。</strong></p><h2 id="_6-服务器主动推送资源" tabindex="-1"><a class="header-anchor" href="#_6-服务器主动推送资源"><span>6.服务器主动推送资源</span></a></h2><p>比如，客户端通过 HTTP/1.1 请求从服务器那获取到了 HTML 文件，而 HTML 可能还需要依赖 CSS 来渲染页面，这时客户端还要再发起获取 CSS 文件的请求，需要两次消息往返 在 HTTP/2 中，客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数。</p><h1 id="http3" tabindex="-1"><a class="header-anchor" href="#http3"><span>HTTP3</span></a></h1><h2 id="_1-http2的问题" tabindex="-1"><a class="header-anchor" href="#_1-http2的问题"><span>1.HTTP2的问题</span></a></h2><p>HTTP2是基于TCP协议实现的</p><ul><li><p>队头阻塞；</p></li><li><p>TCP 与 TLS 的握手时延迟；</p></li><li><p>网络迁移需要重新连接；</p></li></ul><h4 id="_1-队头阻塞" tabindex="-1"><a class="header-anchor" href="#_1-队头阻塞"><span>1.队头阻塞：</span></a></h4><p>HTTP/2 多个请求是跑在一个 TCP 连接中的，那么当 TCP 丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。</p><h4 id="_2-tcp与tls的握手延迟" tabindex="-1"><a class="header-anchor" href="#_2-tcp与tls的握手延迟"><span>2.TCP与TLS的握手延迟</span></a></h4><p>TCP三次握手TLS四次握手</p><h4 id="_3-网络迁移需要重新连接" tabindex="-1"><a class="header-anchor" href="#_3-网络迁移需要重新连接"><span>3.网络迁移需要重新连接</span></a></h4><p>一个 TCP 连接是由四元组（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的，这意味着如果 IP 地址或者端口变动了，就会导致需要 TCP 与 TLS 重新握手，这不利于移动设备切换网络的场景，比如 4G 网络环境切换成 WiFi。</p><h2 id="_2-quic协议的特点" tabindex="-1"><a class="header-anchor" href="#_2-quic协议的特点"><span>2.QUIC协议的特点</span></a></h2><p>它具有类似 TCP 的<strong>连接管理</strong>、<strong>拥塞窗口</strong>、<strong>流量控制</strong>的网络特性</p><h4 id="_1-无队头阻塞" tabindex="-1"><a class="header-anchor" href="#_1-无队头阻塞"><span>1.无队头阻塞</span></a></h4><p>某个流中的一个数据包丢失了，即使该流的其他数据包到达了，数据也无法被 HTTP/3 读取，直到 QUIC 重传丢失的报文，数据才会交给 HTTP/3。 QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p><h4 id="_2-更快连接建立" tabindex="-1"><a class="header-anchor" href="#_2-更快连接建立"><span>2.更快连接建立</span></a></h4><p><strong>QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS 1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果</strong>。</p><h4 id="_3-连接迁移" tabindex="-1"><a class="header-anchor" href="#_3-连接迁移"><span>3.连接迁移</span></a></h4><p>通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己</p><h2 id="_3-http3协议" tabindex="-1"><a class="header-anchor" href="#_3-http3协议"><span>3.HTTP3协议</span></a></h2><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>HTTP3在头部压缩升级到了QPACK，静态表更大</p><p>QUIC 会有两个特殊的单向流，所谓的单向流只有一端可以发送消息，双向则指两端都可以发送消息，传输 HTTP 消息时用的是双向流，这两个单向流的用法：</p><ul><li>一个叫 QPACK Encoder Stream，用于将一个字典（Key-Value）传递给对方，比如面对不属于静态表的 HTTP 请求头部，客户端可以通过这个 Stream 发送字典；</li><li>一个叫 QPACK Decoder Stream，用于响应对方，告诉它刚发的字典已经更新到自己的本地动态表了，后续就可以使用这个字典来编码了。</li></ul><p>这两个特殊的单向流是用来<strong>同步双方的动态表</strong>，编码方收到解码方更新确认的通知后，才使用动态表编码 HTTP 头部</p>',65),l={},h=(0,a(6786).A)(l,[["render",function(e,t){return(0,p.uX)(),(0,p.CE)("div",null,[(0,p.Q3)(" more "),s])}]]),T=JSON.parse('{"path":"/demo/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/HTTP1.1%EF%BC%8CHTTP2%EF%BC%8CHTTP3%E7%9A%84%E6%9B%B4%E6%9B%BF.html","title":"HTTP的更迭","lang":"zh-CN","frontmatter":{"title":"HTTP的更迭","date":"2023-11-21T00:00:00.000Z","tags":["计算机基础","计算机网络","HTTP"],"categories":["计算机网络"],"head":[["meta",{"property":"og:url","content":"https://flipped1001.cn/demo/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/HTTP1.1%EF%BC%8CHTTP2%EF%BC%8CHTTP3%E7%9A%84%E6%9B%B4%E6%9B%BF.html"}],["meta",{"property":"og:site_name","content":"Flipped"}],["meta",{"property":"og:title","content":"HTTP的更迭"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-16T10:13:48.000Z"}],["meta",{"property":"article:author","content":"Flipped"}],["meta",{"property":"article:tag","content":"计算机基础"}],["meta",{"property":"article:tag","content":"计算机网络"}],["meta",{"property":"article:tag","content":"HTTP"}],["meta",{"property":"article:published_time","content":"2023-11-21T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-16T10:13:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"HTTP的更迭\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-11-21T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-16T10:13:48.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Flipped\\"}]}"]]},"headers":[{"level":2,"title":"1.如何避免发送HTTP请求","slug":"_1-如何避免发送http请求","link":"#_1-如何避免发送http请求","children":[]},{"level":2,"title":"2.如何减少HTTP请求次数","slug":"_2-如何减少http请求次数","link":"#_2-如何减少http请求次数","children":[]},{"level":2,"title":"3.如何减少HTTP响应的数据大小？","slug":"_3-如何减少http响应的数据大小","link":"#_3-如何减少http响应的数据大小","children":[]},{"level":2,"title":"1.HTTP的性能问题","slug":"_1-http的性能问题","link":"#_1-http的性能问题","children":[]},{"level":2,"title":"2.兼容HTTP1.1","slug":"_2-兼容http1-1","link":"#_2-兼容http1-1","children":[]},{"level":2,"title":"3.头部压缩","slug":"_3-头部压缩","link":"#_3-头部压缩","children":[{"level":3,"title":"动态编码表","slug":"动态编码表","link":"#动态编码表","children":[]}]},{"level":2,"title":"4.二进制帧","slug":"_4-二进制帧","link":"#_4-二进制帧","children":[]},{"level":2,"title":"5.并发传输","slug":"_5-并发传输","link":"#_5-并发传输","children":[]},{"level":2,"title":"6.服务器主动推送资源","slug":"_6-服务器主动推送资源","link":"#_6-服务器主动推送资源","children":[]},{"level":2,"title":"1.HTTP2的问题","slug":"_1-http2的问题","link":"#_1-http2的问题","children":[]},{"level":2,"title":"2.QUIC协议的特点","slug":"_2-quic协议的特点","link":"#_2-quic协议的特点","children":[]},{"level":2,"title":"3.HTTP3协议","slug":"_3-http3协议","link":"#_3-http3协议","children":[]}],"git":{"createdTime":1721124828000,"updatedTime":1721124828000,"contributors":[{"name":"flipped1001","email":"3154147351@qq.com","commits":1}]},"readingTime":{"minutes":7.05,"words":2116},"filePathRelative":"demo/计算机网络/HTTP/HTTP1.1，HTTP2，HTTP3的更替.md","localizedDate":"2023年11月21日","excerpt":""}')}}]);