const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":511,\"nextId\":511,\"documentIds\":{\"0\":\"1\",\"1\":\"2\",\"2\":\"2#📋-个人信息\",\"3\":\"2#📝-简介\",\"4\":\"2#🚀-技能\",\"5\":\"2#🖥️-编程语言\",\"6\":\"2#🌐-前端技术\",\"7\":\"2#🛠️-后端技术\",\"8\":\"2#🗄️-数据库\",\"9\":\"2#🔧-工具\",\"10\":\"2#📚-项目经验\",\"11\":\"2#📦-项目名称1\",\"12\":\"2#📝-项目名称2\",\"13\":\"2#🎓-教育背景\",\"14\":\"2#🎖️-证书\",\"15\":\"2#🎨-兴趣爱好\",\"16\":\"2#💬-个人格言\",\"17\":\"3\",\"18\":\"4\",\"19\":\"5\",\"20\":\"5#_1-limit-m-1\",\"21\":\"5#_2-limit-offset-count\",\"22\":\"6\",\"23\":\"6#union\",\"24\":\"6#union-all\",\"25\":\"7\",\"26\":\"8\",\"27\":\"9\",\"28\":\"10\",\"29\":\"11\",\"30\":\"12\",\"31\":\"13\",\"32\":\"13#cors-cross-origin-resource-sharing-跨域资源共享\",\"33\":\"13#cors的原理\",\"34\":\"13#实际请求-actual-request\",\"35\":\"13#为什么需要-cors\",\"36\":\"14\",\"37\":\"14#start-go\",\"38\":\"14#middleware-go\",\"39\":\"14#jwtbucket-go\",\"40\":\"14#auth-go\",\"41\":\"14#handler-go\",\"42\":\"15\",\"43\":\"15#_1-什么是oauth2-0\",\"44\":\"15#a-oauth-2-0-授权模式\",\"45\":\"15#_2-用户扫码是如何实现的\",\"46\":\"15#_3-如果要实现不同域名下的cookie正常使用-应该怎么处理\",\"47\":\"15#_4-假如1亿用户体量-如何设计一个登录验签服务\",\"48\":\"16\",\"49\":\"17\",\"50\":\"18\",\"51\":\"18#_1-tcp和udp的区别\",\"52\":\"18#_2-tcp是如何做链接管理的\",\"53\":\"18#_3-tcp是如何保证可靠的\",\"54\":\"18#_4-重传机制有哪些\",\"55\":\"18#_5-tcp是如何保证有序的\",\"56\":\"18#_6-粘包问题\",\"57\":\"18#_7-滑动窗口\",\"58\":\"18#_8-拥塞控制\",\"59\":\"18#_9-tcp的三次握手和四次挥手\",\"60\":\"18#三次握手\",\"61\":\"18#_1-第一次握手\",\"62\":\"18#_2-第二次握手\",\"63\":\"18#_3-第三次握手\",\"64\":\"18#四次挥手\",\"65\":\"18#_1-第一次挥手\",\"66\":\"18#_2-第二次挥手\",\"67\":\"18#_3-第三次挥手\",\"68\":\"18#_4-第四次挥手\",\"69\":\"18#_10-time-wait状态的意义\",\"70\":\"18#_11-为什么需要三次握手而不是四次-两次\",\"71\":\"18#什么是restful风格\",\"72\":\"19\",\"73\":\"19#dcl\",\"74\":\"20\",\"75\":\"20#ddl\",\"76\":\"21\",\"77\":\"21#dml\",\"78\":\"22\",\"79\":\"22#dql\",\"80\":\"22#聚合函数\",\"81\":\"23\",\"82\":\"23#explain-一个sql语句可以查询到什么\",\"83\":\"24\",\"84\":\"24#字符串函数\",\"85\":\"24#数值函数\",\"86\":\"24#日期函数\",\"87\":\"24#流程函数\",\"88\":\"25\",\"89\":\"25#约束\",\"90\":\"25#外键约束\",\"91\":\"26\",\"92\":\"26#全局锁\",\"93\":\"26#表级锁定\",\"94\":\"26#普通表锁\",\"95\":\"26#元数据锁-mdl\",\"96\":\"26#意向锁\",\"97\":\"26#auto-inc-锁\",\"98\":\"26#行级锁\",\"99\":\"26#record-lock\",\"100\":\"26#gap-lock\",\"101\":\"26#next-key-lock\",\"102\":\"26#插入意向锁\",\"103\":\"27\",\"104\":\"27#redis\",\"105\":\"27#redis和memcached的区别\",\"106\":\"28\",\"107\":\"28#当redis内存满了\",\"108\":\"28#不进行数据淘汰的策略\",\"109\":\"28#进行数据淘汰的策略\",\"110\":\"28#_1-在设置了过期时间的数据中进行淘汰\",\"111\":\"28#_2-在所有数据范围内进行淘汰\",\"112\":\"28#lru算法和lfu算法\",\"113\":\"28#lru算法\",\"114\":\"28#lfu算法\",\"115\":\"29\",\"116\":\"29#缓存雪崩\",\"117\":\"29#redis服务宕机造成缓存雪崩\",\"118\":\"29#缓存击穿\",\"119\":\"29#缓存穿透\",\"120\":\"30\",\"121\":\"30#数据一致性\",\"122\":\"30#双写策略\",\"123\":\"30#读时更新-写时删除\",\"124\":\"30#永不过期-由后端自主更新\",\"125\":\"30#单飞\",\"126\":\"31\",\"127\":\"31#使用redis实现延时队列\",\"128\":\"32\",\"129\":\"32#redis是否支持回滚操作\",\"130\":\"33\",\"131\":\"33#使用redis实现一个分布式锁\",\"132\":\"34\",\"133\":\"34#使用redis实现一个异步队列\",\"134\":\"34#redis-异步队列的实现\",\"135\":\"35\",\"136\":\"35#redis常用的数据类型-以及他的底层实现\",\"137\":\"35#_1-string\",\"138\":\"35#底层原理\",\"139\":\"35#常用命令\",\"140\":\"35#使用场景\",\"141\":\"35#_2-list\",\"142\":\"35#底层原理-1\",\"143\":\"35#常用命令-1\",\"144\":\"35#使用场景-1\",\"145\":\"35#_3-hash\",\"146\":\"35#底层原理-2\",\"147\":\"35#常用命令-2\",\"148\":\"35#使用场景-2\",\"149\":\"35#_4-set\",\"150\":\"35#底层原理-3\",\"151\":\"35#常用命令-3\",\"152\":\"35#使用场景-3\",\"153\":\"35#_5-zset\",\"154\":\"35#底层原理-4\",\"155\":\"35#常用命令-4\",\"156\":\"35#使用场景-4\",\"157\":\"35#_6-bitmap\",\"158\":\"35#底层原理-5\",\"159\":\"35#常用命令-5\",\"160\":\"35#使用场景-5\",\"161\":\"36\",\"162\":\"36#redis是单线程的吗\",\"163\":\"36#redis单线程还这么快\",\"164\":\"37\",\"165\":\"37#redis持久化\",\"166\":\"37#aof\",\"167\":\"37#aof的写回策略\",\"168\":\"37#aof重写机制\",\"169\":\"37#重写过程\",\"170\":\"37#rdb\",\"171\":\"37#混合持久化\",\"172\":\"38\",\"173\":\"38#主从复制\",\"174\":\"38#第一次同步\",\"175\":\"38#分摊压力\",\"176\":\"38#增量复制\",\"177\":\"38#在主从库中如何确定对方还活着\",\"178\":\"39\",\"179\":\"39#监控\",\"180\":\"39#由哪个哨兵进行故障转移\",\"181\":\"39#主从故障转移的过程\",\"182\":\"39#如何组成哨兵集群\",\"183\":\"40\",\"184\":\"40#切片集群模式\",\"185\":\"41\",\"186\":\"41#集群脑裂-数据丢失\",\"187\":\"41#现象\",\"188\":\"41#解决方法\",\"189\":\"42\",\"190\":\"42#惰性删除\",\"191\":\"42#定期删除\",\"192\":\"42#定时删除\",\"193\":\"42#redis持久化时对过期键的处理\",\"194\":\"42#在主从模式下对过期键的处理\",\"195\":\"43\",\"196\":\"43#cup-cache\",\"197\":\"43#如何写出让-cpu-跑得更快的代码\",\"198\":\"43#数据缓存\",\"199\":\"43#指令缓存\",\"200\":\"43#多核-cpu-的缓存命中率\",\"201\":\"44\",\"202\":\"44#cpu如何执行任务的\",\"203\":\"44#cache-伪共享是什么\",\"204\":\"44#避免伪共享的方法\",\"205\":\"44#cpu-是根据什么来选择当前要执行的线程。\",\"206\":\"44#调度类\",\"207\":\"44#完全公平调度\",\"208\":\"44#cpu-运行队列\",\"209\":\"44#调整优先级\",\"210\":\"45\",\"211\":\"45#cpu-cache-的数据写入\",\"212\":\"45#写直达\",\"213\":\"45#写回\",\"214\":\"45#缓存一致性问题\",\"215\":\"45#总线嗅探\",\"216\":\"45#mesi-协议\",\"217\":\"46\",\"218\":\"46#中断\",\"219\":\"46#软中断\",\"220\":\"47\",\"221\":\"47#_1-虚拟内存\",\"222\":\"47#问题背景\",\"223\":\"47#基本概念\",\"224\":\"47#_1-1-内存分段\",\"225\":\"47#内存碎片\",\"226\":\"47#内存交换效率低\",\"227\":\"47#_1-2-内存分页\",\"228\":\"47#简单分页-有缺陷\",\"229\":\"47#多级页表\",\"230\":\"47#tlb\",\"231\":\"47#_1-3-段页式内存管理\",\"232\":\"47#linux内存布局\",\"233\":\"47#内核空间与用户空间的区别\",\"234\":\"47#虚拟内存的作用\",\"235\":\"47#虚拟内存的功能\",\"236\":\"47#虚拟内存管理器\",\"237\":\"48\",\"238\":\"48#内存\",\"239\":\"48#中央处理器\",\"240\":\"48#总线\",\"241\":\"48#输入、输出设备\",\"242\":\"48#存储器的层次结构\",\"243\":\"49\",\"244\":\"49#线程的优势\",\"245\":\"49#理解线程\",\"246\":\"49#线程与进程的比较\",\"247\":\"49#线程的上下文切换\",\"248\":\"49#线程的实现方式\",\"249\":\"49#线程的优劣势\",\"250\":\"50\",\"251\":\"50#用补码的形式保存负数\",\"252\":\"50#十进制小数与二进制的转换\",\"253\":\"50#计算机是怎么存小数的\",\"254\":\"50#在计算机中-0-1-0-2-并不等于完整的-0-3。\",\"255\":\"51\",\"256\":\"51#进程的状态\",\"257\":\"51#进程的控制结构\",\"258\":\"51#进程的控制\",\"259\":\"51#进程的上下文切换\",\"260\":\"52\",\"261\":\"53\",\"262\":\"54\",\"263\":\"55\",\"264\":\"56\",\"265\":\"57\",\"266\":\"58\",\"267\":\"59\",\"268\":\"60\",\"269\":\"61\",\"270\":\"62\",\"271\":\"63\",\"272\":\"63#http基本概念\",\"273\":\"63#http是什么\",\"274\":\"63#http常见的状态码\",\"275\":\"63#http常见字段有哪些\",\"276\":\"63#get与post请求\",\"277\":\"63#get与post的区别\",\"278\":\"63#get和post的方法都是安全和幂等的吗\",\"279\":\"63#http缓存技术\",\"280\":\"63#强缓存\",\"281\":\"63#协商缓存\",\"282\":\"63#http特性\",\"283\":\"64\",\"284\":\"64#_1-如何避免发送http请求\",\"285\":\"64#_2-如何减少http请求次数\",\"286\":\"64#_3-如何减少http响应的数据大小\",\"287\":\"64#_1-http的性能问题\",\"288\":\"64#_2-兼容http1-1\",\"289\":\"64#_3-头部压缩\",\"290\":\"64#静态表编码\",\"291\":\"64#动态编码表\",\"292\":\"64#_4-二进制帧\",\"293\":\"64#_5-并发传输\",\"294\":\"64#_6-服务器主动推送资源\",\"295\":\"64#_1-http2的问题\",\"296\":\"64#_1-队头阻塞\",\"297\":\"64#_2-tcp与tls的握手延迟\",\"298\":\"64#_3-网络迁移需要重新连接\",\"299\":\"64#_2-quic协议的特点\",\"300\":\"64#_1-无队头阻塞\",\"301\":\"64#_2-更快连接建立\",\"302\":\"64#_3-连接迁移\",\"303\":\"64#_3-http3协议\",\"304\":\"65\",\"305\":\"65#_1-分析性能损耗\",\"306\":\"65#硬件优化\",\"307\":\"65#软件优化\",\"308\":\"65#证书优化\",\"309\":\"65#会话复用\",\"310\":\"65#https中tcp三次握手和tls握手能同时进行吗\",\"311\":\"66\",\"312\":\"66#http和https\",\"313\":\"66#_1-http和https的区别\",\"314\":\"66#_2-https解决了http的那些问题\",\"315\":\"66#如何解决的\",\"316\":\"66#_3-https是如何建立连接的-期间交互了什么\",\"317\":\"66#_4-https的应用数据时如保证完整性的\",\"318\":\"67\",\"319\":\"67#tcp-是有三个特点-面向连接、可靠、基于字节流。\",\"320\":\"67#_1-http和rpc的区别\",\"321\":\"67#_2-websocket是什么\",\"322\":\"68\",\"323\":\"68#apr\",\"324\":\"68#dhcp\",\"325\":\"68#nat\",\"326\":\"68#icmp\",\"327\":\"69\",\"328\":\"69#ping的工作原理\",\"329\":\"69#查询报文类型\",\"330\":\"69#traceroute\",\"331\":\"69#断网了还能ping通127-0-0-1吗\",\"332\":\"69#什么是127-0-0-1\",\"333\":\"69#tcp和ping数据的区别\",\"334\":\"69#为什么断网了还能ping通127-0-0-1\",\"335\":\"69#_127-0-0-1和localhost和0-0-00有什么区别\",\"336\":\"70\",\"337\":\"70#ip基本认识\",\"338\":\"70#ip的基础知识\",\"339\":\"70#ip的分类\",\"340\":\"70#什么是a-b-c类\",\"341\":\"70#什么是d类-e类\",\"342\":\"70#无分类地址cidr\",\"343\":\"70#公有-ip-地址与私有-ip-地址\",\"344\":\"70#ip-地址与路由控制\",\"345\":\"70#ip分片与重组\",\"346\":\"70#ipv6-基本认识\",\"347\":\"70#ipv6的首部改进\",\"348\":\"71\",\"349\":\"71#为什么-time-wait-等待的时间是-2msl\",\"350\":\"71#为什么需要-time-wait-状态\",\"351\":\"71#time-wait-过多有什么危害\",\"352\":\"71#如何优化-time-wait\",\"353\":\"71#服务器出现大量-time-wait-状态的原因有哪些\",\"354\":\"71#服务器出现大量-close-wait-状态的原因有哪些\",\"355\":\"72\",\"356\":\"72#什么是syn攻击-如何避免syn攻击\",\"357\":\"72#什么时syn超时-如何解决syn超时\",\"358\":\"73\",\"359\":\"73#udp和tcp的区别和应用场景\",\"360\":\"73#tcp和udp的区别\",\"361\":\"74\",\"362\":\"74#_1-针对tcp应该如何socket编程\",\"363\":\"74#_2-listen-时候参数-backlog-的意义\",\"364\":\"74#_3-accept-发生在三次握手的哪一步\",\"365\":\"74#_4-客户端调用-close-了-连接是断开的流程是什么\",\"366\":\"74#_5-服务端没有调用listen-客户端请求建立连接会发生什么\",\"367\":\"74#_6-没有listen可以建立tcp连接吗\",\"368\":\"74#_7-没有accpet-能建立tcp连接吗\",\"369\":\"74#_8-为什么半连接队列要设计成哈希表\",\"370\":\"74#_9-会有一个cookies队列吗\",\"371\":\"74#_10-cookies方案为什么不直接取代半连接队列\",\"372\":\"74#tcp和udp可以同时绑定相同的端口吗\",\"373\":\"74#_1-tcp和udp可以同时绑定相同的端口吗\",\"374\":\"74#_2-多个tcp可以同时绑定一个端口吗\",\"375\":\"74#_3-重启-tcp-服务进程时-为什么会有-address-in-use-的报错信息\",\"376\":\"74#_4-重启-tcp-服务进程时-如何避免-address-in-use-的报错信息\",\"377\":\"74#_5-客户端的端口可以重复使用吗\",\"378\":\"74#_6-多个客户端可以-bind-同一个端口吗\",\"379\":\"74#_7-客户端-tcp-连接-time-wait-状态过多-会导致端口资源耗尽而无法建立新的连接吗\",\"380\":\"75\",\"381\":\"75#如何优化tcp\",\"382\":\"75#tcp三次握手的性能提升\",\"383\":\"75#tcp四次挥手性能的提升\",\"384\":\"75#tcp传输数据的性能提升\",\"385\":\"76\",\"386\":\"76#tcp基本认识\",\"387\":\"76#tcp的头格式\",\"388\":\"76#tcp工作在那一层\",\"389\":\"76#什么是tcp协议\",\"390\":\"76#什么是tcp连接\",\"391\":\"76#如何确定一个tcp连接\",\"392\":\"76#如何理解tcp是基于字节流的协议\",\"393\":\"76#先来说说为什么-udp-是面向报文的协议\",\"394\":\"76#再来说说为什么-tcp-是面向字节流的协议\",\"395\":\"76#tcp半连接队列和全连接队列\",\"396\":\"76#syn报文在什么情况下会被丢弃\",\"397\":\"76#拔掉网线之后-tcp连接会消失吗\",\"398\":\"76#为什么-tcp-tw-reuse-默认是关闭的\",\"399\":\"76#用了tcp传输数据就一定不会丢包吗\",\"400\":\"77\",\"401\":\"77#拥塞控制\",\"402\":\"77#慢启动\",\"403\":\"77#拥塞避免\",\"404\":\"77#拥塞发生\",\"405\":\"77#快速恢复\",\"406\":\"78\",\"407\":\"78#滑动窗口\",\"408\":\"78#窗口大小由哪一方决定\",\"409\":\"78#发送方的滑动窗口\",\"410\":\"78#程序如何表示发送方的四个部分呢\",\"411\":\"78#接收方的滑动窗口\",\"412\":\"78#接收窗口和发送窗口的大小是相等的吗\",\"413\":\"78#流量控制\",\"414\":\"78#操作系统缓冲区和滑动窗口的关系\",\"415\":\"78#窗口关闭\",\"416\":\"78#糊涂窗口综合征\",\"417\":\"79\",\"418\":\"79#tcp的重传机制\",\"419\":\"79#_1-超时重传\",\"420\":\"79#_2-快速重传\",\"421\":\"79#_3-sack方法\",\"422\":\"79#_4-duplicate-sack\",\"423\":\"80\",\"424\":\"80#tcp连接的建立\",\"425\":\"80#为什么是三次握手\",\"426\":\"80#为什么每次建立tcp链接的时候-初始化序列号的都要求不一样\",\"427\":\"80#初始序列号isn是如何随机产生的\",\"428\":\"80#既然ip层会分片-为什么tcp层还需要mss\",\"429\":\"80#第一次握手丢失\",\"430\":\"80#第二次握手丢失\",\"431\":\"80#第三次握手丢失\",\"432\":\"80#为什么每次建立tcp连接-初始化序列号都要不一样\",\"433\":\"80#tcp-序列号和确认号是如何变化的\",\"434\":\"80#万能公式\",\"435\":\"80#已建立的tcp连接-收到syn会发生什么\",\"436\":\"80#killcx-的工具\",\"437\":\"80#tcpkill-的工具\",\"438\":\"80#tcp-的-keepalive-和-http-的-keep-alive-是一个东西吗\",\"439\":\"81\",\"440\":\"81#tcp断开连接\",\"441\":\"81#tcp的四次挥手\",\"442\":\"81#第一次挥手丢失\",\"443\":\"81#第二次挥手丢失\",\"444\":\"81#第三次挥手丢失\",\"445\":\"81#第四次挥手丢失\",\"446\":\"81#tcp四次挥手可以变成三次吗\",\"447\":\"81#粗暴关闭vs优雅关闭\",\"448\":\"81#什么情况下会出现三次挥手\",\"449\":\"81#四次挥手中收到乱序的fin包怎么办\",\"450\":\"81#在time-wait状态的tcp接收到syn报文会怎么样\",\"451\":\"81#syn合法\",\"452\":\"81#syn非法\",\"453\":\"81#在-time-wait-状态-收到-rst-会断开连接吗\",\"454\":\"81#如果已经建立了链接-客户端突然挂怎么办\",\"455\":\"81#如果已经建立了链接-服务端突然挂怎么办\",\"456\":\"81#tcp连接-一端断电和进程崩溃有什么区别\",\"457\":\"81#客户端主机宕机又重启\",\"458\":\"82\",\"459\":\"82#如何基于udp实现可靠传输\",\"460\":\"82#quic是如何实现可靠传输的\",\"461\":\"82#packet-header\",\"462\":\"82#quic-frame-header\",\"463\":\"82#quic-是如何解决-tcp-队头阻塞问题的\",\"464\":\"82#quic-是如何做流量控制的\",\"465\":\"82#quic-对拥塞控制改进\",\"466\":\"82#quic-更快的连接建立\",\"467\":\"82#quic-是如何迁移连接的\",\"468\":\"83\",\"469\":\"83#网络模型\",\"470\":\"83#osi网络模型\",\"471\":\"83#tcp-ip四层模型\",\"472\":\"83#tcp-ip协议栈的五层模型\",\"473\":\"84\",\"474\":\"84#应用层\",\"475\":\"84#用户态和内核态\",\"476\":\"84#传输层-作为传输媒介\",\"477\":\"84#网络层-有着实际的传输功能\",\"478\":\"84#ip协议的寻址作用\",\"479\":\"84#ip协议还可以路由\",\"480\":\"84#网络接口层\",\"481\":\"85\",\"482\":\"85#_1-浏览器第一步工作是解析ulr-然后生产http请求消息-然后会委托操作系统发送消息\",\"483\":\"85#_2-在发送之前-必须查询服务器域名对应的ip地址-在委托操作系统发送消息时必须提供通讯对象的ip地址\",\"484\":\"85#dns服务器-专门保存了-web-服务器域名与-ip-的对应关系\",\"485\":\"85#只指路不带路\",\"486\":\"85#_3-通过dns获取到ip后-把传输工作给操作系统中的协议栈\",\"487\":\"85#_4-http协议是基于tcp协议传输的\",\"488\":\"85#_1-第一次握手\",\"489\":\"85#_2-第二次握手\",\"490\":\"85#_3-第三次握手\",\"491\":\"85#完整的tcp报文\",\"492\":\"85#_4-ip\",\"493\":\"85#_5-mac\",\"494\":\"85#_5-网卡-真正的数据发送\",\"495\":\"85#_6-交换机\",\"496\":\"85#_7-路由器\",\"497\":\"85#_8-客户端-服务器\",\"498\":\"86\",\"499\":\"87\",\"500\":\"88\",\"501\":\"89\",\"502\":\"90\",\"503\":\"91\",\"504\":\"92\",\"505\":\"93\",\"506\":\"94\",\"507\":\"95\",\"508\":\"96\",\"509\":\"97\",\"510\":\"98\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[2],\"2\":[2],\"3\":[2],\"4\":[2],\"5\":[2],\"6\":[2],\"7\":[2],\"8\":[2],\"9\":[2],\"10\":[2],\"11\":[2],\"12\":[2],\"13\":[2],\"14\":[2],\"15\":[2],\"16\":[2],\"17\":[2,16],\"18\":[2,16],\"19\":[2,61],\"20\":[2,9],\"21\":[2,12],\"22\":[2],\"23\":[1,21],\"24\":[2,49],\"25\":[2,17],\"26\":[2,61],\"27\":[2,111],\"28\":[2,17],\"29\":[2,41],\"30\":[1],\"31\":[1],\"32\":[7],\"33\":[1],\"34\":[1],\"35\":[1],\"36\":[1,1],\"37\":[2,27],\"38\":[2,93],\"39\":[2,51],\"40\":[2,92],\"41\":[2,59],\"42\":[1],\"43\":[4],\"44\":[5],\"45\":[2],\"46\":[4],\"47\":[4],\"48\":[1],\"49\":[1],\"50\":[1,2],\"51\":[2,21],\"52\":[3,3],\"53\":[3,1],\"54\":[3,37],\"55\":[3,10],\"56\":[3,24],\"57\":[2,15],\"58\":[2,50],\"59\":[3],\"60\":[1],\"61\":[2,15],\"62\":[2,12],\"63\":[2,10],\"64\":[1],\"65\":[2,5],\"66\":[2,7],\"67\":[2,5],\"68\":[2,11],\"69\":[3,16],\"70\":[3],\"71\":[2,8],\"72\":[1],\"73\":[1,83],\"74\":[1],\"75\":[1],\"76\":[1],\"77\":[1,53],\"78\":[1],\"79\":[1,95],\"80\":[1,136],\"81\":[2],\"82\":[3],\"83\":[1],\"84\":[1,43],\"85\":[1,41],\"86\":[1,66],\"87\":[1,113],\"88\":[1],\"89\":[1,65],\"90\":[1,137],\"91\":[1],\"92\":[1,12],\"93\":[1],\"94\":[2,12],\"95\":[3,12],\"96\":[1,24],\"97\":[3,24],\"98\":[1,18],\"99\":[2,20],\"100\":[2,10],\"101\":[3,10],\"102\":[1,23],\"103\":[1],\"104\":[1,5],\"105\":[2,31],\"106\":[1],\"107\":[1,11],\"108\":[1,9],\"109\":[1,6],\"110\":[2,17],\"111\":[2,11],\"112\":[1],\"113\":[2,61],\"114\":[1,51],\"115\":[3],\"116\":[1,42],\"117\":[1,13],\"118\":[1,14],\"119\":[1,71],\"120\":[1],\"121\":[1],\"122\":[1,34],\"123\":[2,58],\"124\":[2,5],\"125\":[1,81],\"126\":[1],\"127\":[1,158],\"128\":[1],\"129\":[1,121],\"130\":[1],\"131\":[1,114],\"132\":[1],\"133\":[1,31],\"134\":[2,116],\"135\":[1],\"136\":[1],\"137\":[2],\"138\":[1,76],\"139\":[1,63],\"140\":[1,33],\"141\":[2],\"142\":[1,41],\"143\":[1,27],\"144\":[1,23],\"145\":[2],\"146\":[1,39],\"147\":[1,21],\"148\":[1,17],\"149\":[2],\"150\":[1,4],\"151\":[1,34],\"152\":[1,15],\"153\":[2],\"154\":[1,28],\"155\":[1,46],\"156\":[1,2],\"157\":[2],\"158\":[1,4],\"159\":[1,52],\"160\":[1,4],\"161\":[3],\"162\":[2,64],\"163\":[1,21],\"164\":[1],\"165\":[1,17],\"166\":[1,28],\"167\":[1,3],\"168\":[1,9],\"169\":[1,46],\"170\":[1,20],\"171\":[1,90],\"172\":[1],\"173\":[1,5],\"174\":[1,44],\"175\":[1,9],\"176\":[1,55],\"177\":[1,29],\"178\":[1,5],\"179\":[1,19],\"180\":[1,25],\"181\":[1,60],\"182\":[1,14],\"183\":[1],\"184\":[1,52],\"185\":[1],\"186\":[2],\"187\":[1,10],\"188\":[1,5],\"189\":[1,13],\"190\":[1,23],\"191\":[1,51],\"192\":[1,30],\"193\":[1,64],\"194\":[1,24],\"195\":[2],\"196\":[2],\"197\":[4],\"198\":[1],\"199\":[1],\"200\":[3],\"201\":[2],\"202\":[1],\"203\":[3],\"204\":[1],\"205\":[3],\"206\":[1],\"207\":[1],\"208\":[2],\"209\":[1],\"210\":[1],\"211\":[3],\"212\":[1],\"213\":[1],\"214\":[1],\"215\":[1],\"216\":[2],\"217\":[2],\"218\":[1],\"219\":[1],\"220\":[1],\"221\":[2],\"222\":[1],\"223\":[1],\"224\":[2],\"225\":[1],\"226\":[1],\"227\":[3],\"228\":[3],\"229\":[1],\"230\":[1],\"231\":[3],\"232\":[1],\"233\":[1],\"234\":[1],\"235\":[1],\"236\":[1],\"237\":[1],\"238\":[2],\"239\":[2],\"240\":[2],\"241\":[2],\"242\":[1],\"243\":[1],\"244\":[1],\"245\":[1],\"246\":[1],\"247\":[1],\"248\":[1],\"249\":[1],\"250\":[1],\"251\":[1],\"252\":[1],\"253\":[2],\"254\":[1],\"255\":[1],\"256\":[2],\"257\":[2],\"258\":[1],\"259\":[1],\"260\":[1,78],\"261\":[1,74],\"262\":[1,86],\"263\":[1,43],\"264\":[1,102],\"265\":[1,92],\"266\":[1,49],\"267\":[1,49],\"268\":[1,286],\"269\":[1,60],\"270\":[1,60],\"271\":[1],\"272\":[1],\"273\":[2],\"274\":[2],\"275\":[2],\"276\":[2],\"277\":[2],\"278\":[2],\"279\":[1],\"280\":[2],\"281\":[2],\"282\":[2],\"283\":[1],\"284\":[2],\"285\":[2],\"286\":[3],\"287\":[2],\"288\":[3],\"289\":[2],\"290\":[1],\"291\":[1],\"292\":[2],\"293\":[2],\"294\":[2],\"295\":[2],\"296\":[3],\"297\":[2],\"298\":[2],\"299\":[2],\"300\":[2],\"301\":[2],\"302\":[2],\"303\":[2],\"304\":[1],\"305\":[2],\"306\":[1],\"307\":[1],\"308\":[1],\"309\":[1],\"310\":[1],\"311\":[1],\"312\":[2],\"313\":[3],\"314\":[3],\"315\":[2],\"316\":[4],\"317\":[2],\"318\":[1],\"319\":[4],\"320\":[2],\"321\":[2],\"322\":[1],\"323\":[1],\"324\":[1],\"325\":[1],\"326\":[1],\"327\":[1],\"328\":[1],\"329\":[1],\"330\":[2],\"331\":[4],\"332\":[3],\"333\":[2],\"334\":[4],\"335\":[5],\"336\":[1],\"337\":[1],\"338\":[1],\"339\":[2],\"340\":[4],\"341\":[3],\"342\":[1],\"343\":[4],\"344\":[2],\"345\":[1],\"346\":[2],\"347\":[2],\"348\":[3],\"349\":[6],\"350\":[5],\"351\":[4],\"352\":[4],\"353\":[5],\"354\":[5],\"355\":[1],\"356\":[3],\"357\":[3],\"358\":[1],\"359\":[2],\"360\":[2],\"361\":[1],\"362\":[3],\"363\":[6],\"364\":[4],\"365\":[6],\"366\":[4],\"367\":[3],\"368\":[4],\"369\":[3],\"370\":[2],\"371\":[3],\"372\":[2],\"373\":[3],\"374\":[2],\"375\":[1],\"376\":[10],\"377\":[1],\"378\":[1],\"379\":[9],\"380\":[1],\"381\":[2],\"382\":[2],\"383\":[2],\"384\":[2],\"385\":[1],\"386\":[1],\"387\":[2],\"388\":[2],\"389\":[2],\"390\":[2],\"391\":[2],\"392\":[2],\"393\":[4],\"394\":[4],\"395\":[1],\"396\":[2],\"397\":[3],\"398\":[1],\"399\":[2],\"400\":[1],\"401\":[2],\"402\":[1],\"403\":[1],\"404\":[1],\"405\":[1],\"406\":[1],\"407\":[1],\"408\":[2],\"409\":[2],\"410\":[2],\"411\":[2],\"412\":[2],\"413\":[1],\"414\":[2],\"415\":[1],\"416\":[1],\"417\":[1],\"418\":[1],\"419\":[2],\"420\":[2],\"421\":[2],\"422\":[3],\"423\":[1],\"424\":[2],\"425\":[2],\"426\":[3],\"427\":[2],\"428\":[3],\"429\":[1],\"430\":[1],\"431\":[1],\"432\":[3],\"433\":[3],\"434\":[1],\"435\":[3],\"436\":[2],\"437\":[2],\"438\":[1],\"439\":[1],\"440\":[1],\"441\":[2],\"442\":[2],\"443\":[2],\"444\":[2],\"445\":[1],\"446\":[2],\"447\":[2],\"448\":[2],\"449\":[1],\"450\":[3],\"451\":[2],\"452\":[2],\"453\":[8],\"454\":[2],\"455\":[2],\"456\":[3],\"457\":[2],\"458\":[1],\"459\":[1],\"460\":[2],\"461\":[2],\"462\":[3],\"463\":[5],\"464\":[3],\"465\":[2],\"466\":[2],\"467\":[3],\"468\":[1],\"469\":[2],\"470\":[1],\"471\":[1],\"472\":[1],\"473\":[1],\"474\":[2],\"475\":[2],\"476\":[3],\"477\":[3],\"478\":[2],\"479\":[1],\"480\":[2],\"481\":[2],\"482\":[4],\"483\":[3],\"484\":[4],\"485\":[1],\"486\":[3],\"487\":[2],\"488\":[2],\"489\":[2],\"490\":[2],\"491\":[2],\"492\":[2],\"493\":[2],\"494\":[4],\"495\":[2],\"496\":[2],\"497\":[3],\"498\":[1,3],\"499\":[1],\"500\":[1],\"501\":[2],\"502\":[1],\"503\":[1],\"504\":[1],\"505\":[1],\"506\":[1],\"507\":[1],\"508\":[1],\"509\":[1],\"510\":[1]},\"averageFieldLength\":[1.8101761252446185,31.414807895846454],\"storedFields\":{\"0\":{\"h\":\"友情链接\"},\"1\":{\"h\":\"🌟 Flipped的个人介绍页 🌟\"},\"2\":{\"h\":\"📋 个人信息\"},\"3\":{\"h\":\"📝 简介\"},\"4\":{\"h\":\"🚀 技能\"},\"5\":{\"h\":\"🖥️ 编程语言\"},\"6\":{\"h\":\"🌐 前端技术\"},\"7\":{\"h\":\"🛠️ 后端技术\"},\"8\":{\"h\":\"🗄️ 数据库\"},\"9\":{\"h\":\"🔧 工具\"},\"10\":{\"h\":\"📚 项目经验\"},\"11\":{\"h\":\"📦 项目名称1\"},\"12\":{\"h\":\"📝 项目名称2\"},\"13\":{\"h\":\"🎓 教育背景\"},\"14\":{\"h\":\"🎖️ 证书\"},\"15\":{\"h\":\"🎨 兴趣爱好\"},\"16\":{\"h\":\"💬 个人格言\"},\"17\":{\"h\":\"1148.游戏玩法分析\",\"t\":[\"-- LeetCode -- 1148.文章浏览I select author_id as id from Views where viewer_id = author_id group by author_id order by id\"]},\"18\":{\"h\":\"1527.患有某种疾病的患者\",\"t\":[\"-- LeetCode -- 1527.患有某种疾病的患者 SELECT patient_id, patient_name, conditions FROM Patients WHERE conditions LIKE 'DIAB1%' OR conditions LIKE '% DIAB1%'; -- 用LIKE查找含有DIAB1为前缀的conditions\"]},\"19\":{\"h\":\"176`177.第N高的数据\",\"t\":[\"-- LeetCode -- 176.第二高的薪水 SELECT MAX(salary) AS SecondHighestSalary FROM Employee WHERE salary < ( SELECT MAX(salary) FROM Employee ) -- 子查询找到最大的 `salary`,外层查询找到出最大值的剩余数中的最大值 SELECT (SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 1) AS SecondHighestSalary -- 由于需要输出null，使用 LIMIT 1 OFFSET 1 时，如果表中的行数少于2行，即只有1行或者为空，那么查询将不会返回任何结果，包括 null，所以将查询设为一个子查询，这样外层查询在无数据查询的情况下会返回一个null SELECT IFNULL( (SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 1), NULL) AS SecondHighestSalary -- 使用IFNULL，将空值的情况返回一个NULL值 -- 177.第N高的薪水 CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT BEGIN DECLARE M INT; SET M=N-1; RETURN ( SELECT IFNULL( ( SELECT DISTINCT salary FROM Employee ORDER BY salary DESC LIMIT 1 OFFSET M ),null) AS getNthHighestSalary ); END -- 在 LIMIT 子句中使用 OFFSET 时，不能直接将参数N递给 OFFSET。参数必须是一个常量或一个变量，不能是函数参数。 -- DECLARE M INT 声明了一个变量 -- SET M = N-1 赋值\"]},\"20\":{\"h\":\"1.\",\"t\":[\"这种语法用于从查询结果的第 M 行开始，返回接下来的1行数据。\",\"这里的 M 是一个整数，表示从结果集的哪一条记录开始返回数据。\",\"这种语法通常用于分页或获取某一个特定位置的记录。\"]},\"21\":{\"h\":\"2.\",\"t\":[\"这种语法用于跳过查询结果的前 offset 条记录，然后返回接下来的 count 条记录。\",\"offset 是一个整数，表示要跳过的记录数。\",\"count 也是一个整数，表示在跳过 offset 条记录后，要返回的记录数。\"]},\"22\":{\"h\":\"1907.按分类统计薪水\"},\"23\":{\"h\":\"UNION\",\"t\":[\"UNION 用于合并两个或多个查询的结果，并且结果集中的每行都是唯一的。\",\"使用 UNION 时，它会进行额外的步骤来消除重复的行。\",\"示例：\",\"复制SELECT column_name(s) FROM table1 UNION SELECT column_name(s) FROM table2;\",\"这个示例将从 table1 和 table2 中选择列，并合并结果集，但不包括重复的行。\"]},\"24\":{\"h\":\"UNION ALL\",\"t\":[\"UNION ALL 也用于合并两个或多个查询的结果，但它不会去除重复的行。\",\"使用 UNION ALL 可以提高查询效率，因为它不需要执行额外的步骤来消除重复的行。\",\"示例：\",\"SELECT column_name(s) FROM table1 UNION ALL SELECT column_name(s) FROM table2;\",\"这个示例将从 table1 和 table2 中选择列，并合并结果集，包括重复的行。\",\"-- LeetCode -- 1907.按分类统计薪水 SELECT 'Low Salary' AS category, COUNT(CASE WHEN income < 20000 THEN 1 END) AS accounts_count FROM Accounts UNION ALL SELECT 'Average Salary' AS category, COUNT(CASE WHEN income BETWEEN 20000 AND 50000 THEN 1 END) AS accounts_count FROM Accounts UNION ALL SELECT 'High Salary' AS category, COUNT(CASE WHEN income > 50000 THEN 1 END) AS accounts_count FROM Accounts; -- 使用 UNION ALL 来合并三个查询的结果。UNION ALL 允许重复的行，确保每个类别都出现在结果集中。\"]},\"25\":{\"h\":\"2356.每位教师所教授的科目种类的数量\",\"t\":[\"-- LeetCode -- 2356.每位教师所教授的科目种类的数量 select teacher_id, count(distinct subject_id ) as cnt from Teacher group by teacher_id -- 用distinct去重\"]},\"26\":{\"h\":\"34.在排序数组中查找元素的第一个位置和最后一个位置\",\"t\":[\"// LeetCode // 34.在排序数组中查找元素的第一个位置和最后一个位置 // 使用二分查找可以提供O(log(n))的查询效率，具体要先查询第一次出现的位置，然后去查询第二次的位置 // 易于理解但是不够快 func searchRange(nums []int, target int) []int { left:=0 ringht:=len(nums)-1 res:=[]int{-1,-1} //获取第一个目标值的地址 for left<=right{ mid:=left+(right-left)/2 if nums[mid]>target{ right=mid-1 }else if nums[mid]<target{ left=mid+1 }else{ if mid==0 || nums[mid]!=target{ // 记录元素第一次出现的位置 res[0]=mid break }else{ // 继续去左边查询第一个元素 right=mid-1 } } } if res[0]==-1{ return res } left=right right=len(nums)-1 for left<=right{ mid:=left+(right-left)/2 if nums[mid]>target{ right=mid-1 }else if nums[mid]<target{ left=mid+1 }else{ if mid==len(nums)-1 || nums[mid+1]!=target{ res[1]=mid break }else{ left=mid+1 } } } return res } // 够快 func searchRange(nums []int, target int) []int { //返回第一个大于等于target的索引 frist:=getIndex(nums,target) if frist>=len(nums) || nums[frist]!=target{ return []int{-1,-1} } // 查询第一个大于等于target+1的索引 second:=getIndex(nums,target+1) return []int{frist,second-1} } func getIndex(nums []int, target int) int{ left:=0 right:=len(nums) for left<right{ mid:=left+(right-left)/2 if nums[mid]>=target{ right=mid }else if nums[mid]<target{ left=mid+1 } } return left }\"]},\"27\":{\"h\":\"551.游戏玩法分析\",\"t\":[\"-- LeetCode -- 551.游戏玩法分析 select player_id,min(event_date) as first_login from Activity group by player_id -- 简短，易懂 select distinct A.player_id, FIRST_VALUE(A.event_date)Over( PARTITION BY A.player_id ORDER BY A.event_date ) AS first_login from Activity as A -- PARTITION BY A.player_id：这表示窗口函数将按 player_id 进行分区。每个不同的 player_id 都会创建一个独立的分区。 -- ORDER BY A.event_date：这表示在每个分区内，数据将按 event_date 升序排序。FIRST_VALUE() 将返回每个分区内第一个（最早的）event_date。\",\"SUM(amount) OVER (ORDER BY visited_on ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS sum_past_6_days -- 计算当前行和前六行的数据的amount的总和 COUNT(*) OVER (ORDER BY visited_on ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS days_count -- 计数前六行和当前行的数据 ROW_NUMBER() OVER (ORDER BY visited_on) AS rn -- ROW_NUMBER()：为结果集中的每一行分配一个唯一的序号，通常基于ORDER BY子句定义的顺序。 RANK()：为结果集中的每一行分配一个排名，排名相同（即并列）的行会得到相同的排名，后续的排名会跳过。 DENSE_RANK()：与RANK()类似，但是排名不会跳过，即使存在并列排名。 NTILE(n)：将结果集分为n个大致相等的组，返回每行所属的组号。 LEAD(column)：返回当前行之后第n行的数据，如果没有后续行，则返回NULL。 LAG(column)：返回当前行之前第n行的数据，如果没有前面的行，则返回NULL。 FIRST_VALUE() 是一个窗口函数，它返回在每个分区内按指定顺序的第一个值。 FIRST_VALUE(A.event_date) OVER ( PARTITION BY A.player_id ORDER BY A.event_date ) -- PARTITION BY A.player_id：这表示窗口函数将按 player_id 进行分区。每个不同的 player_id 都会创建一个独立的分区。 -- ORDER BY A.event_date：这表示在每个分区内，数据将按 event_date 升序排序。FIRST_VALUE() 将返回每个分区内第一个（最早的）event_date。 LAST_VALUE()：返回窗口定义中指定的排序后最后一行的数据。 SUM()：计算窗口中的总和。 AVG()：计算窗口中的平均值。 MIN()：找到窗口中的最小值。 MAX()：找到窗口中的最大值。 STDDEV_POP()：计算窗口内值的总体标准差。 STDDEV_SAMP()：计算窗口内值的样本标准差。 VAR_POP()：计算窗口内值的总体方差。 VAR_SAMP()：计算窗口内值的样本方差。 PERCENT_RANK()：返回窗口中每行的百分比排名。 CUME_DIST()：返回当前行及其之前所有行的累积分布。 #todo 窗口函数通常搭配OVER()函数使用\"]},\"28\":{\"h\":\"586.订单最多的客户\",\"t\":[\"-- LeetCode -- 586.订单最多的客户 select customer_number from Orders Group by customer_number order by count(*) desc limit 1 -- 用limit限制返回一行数据\"]},\"29\":{\"h\":\"884.比较含退格的字符串\",\"t\":[\"// LeetCode // 884.比较含退格的字符串 func backspaceCompare(s string, t string) bool { return processString(s) == processString(t) } func processString(s string) string { var stack []rune for _, char := range s { if char == '#' { if len(stack) > 0 { stack = stack[:len(stack)-1] // 顶出栈顶元素 } } else { stack = append(stack, char) } } return string(stack) } func main() { fmt.Println(backspaceCompare(\\\"ab#c\\\", \\\"ad#c\\\")) // 输出: true } // 利用栈的思想，当#时就将前面的字符顶出栈，不然就加入栈，先进先出\"]},\"30\":{\"h\":\"LeetCode\"},\"31\":{\"h\":\"CORS策略\"},\"32\":{\"h\":\"CORS( Cross-Origin Resource Sharing )跨域资源共享：\"},\"33\":{\"h\":\"\"},\"34\":{\"h\":\"\"},\"35\":{\"h\":\"\"},\"36\":{\"h\":\"JWT\",\"t\":[\"用go语言实现JWT登录认证\"]},\"37\":{\"h\":\"Start.go\",\"t\":[\"func Start() { r := gin.Default() r.POST(\\\"/login\\\", LoginHandler) auth := r.Group(\\\"/auth\\\") auth.Use(AuthMiddleware()) auth.Use(RateLimiterMiddleware()) auth.Use(JWTAuthMiddleware()) { auth.GET(\\\"/protected\\\", ProtectedHandler) } err := r.Run(\\\":8080\\\") if err != nil { panic(\\\"启动失败\\\") return } }\"]},\"38\":{\"h\":\"middleware.go\",\"t\":[\" var tokenBucket = NewTokenBucket(10, 1*time.Second) // 10 tokens, refill every second func RateLimiterMiddleware() gin.HandlerFunc { return func(c *gin.Context) { if !tokenBucket.Take() { c.JSON(http.StatusTooManyRequests, gin.H{\\\"error\\\": \\\"rate limit exceeded\\\"}) c.Abort() return } c.Next() } } func JWTAuthMiddleware() gin.HandlerFunc { return func(c *gin.Context) { authHeader := c.GetHeader(\\\"Authorization\\\") if authHeader == \\\"\\\" { c.JSON(http.StatusUnauthorized, gin.H{\\\"error\\\": \\\"Authorization header is missing\\\"}) // 停止当前中间件链的执行，并阻止后续的中间件和处理函数的执行 c.Abort() return } // 去掉Bearer前缀，获取完整的token字符串 tokenString := strings.TrimPrefix(authHeader, \\\"Bearer \\\") token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) { return secretKey, nil }) // 判断err以及令牌是否有效 if err != nil || !token.Valid { c.JSON(http.StatusUnauthorized, gin.H{\\\"error\\\": \\\"Invalid token\\\"}) c.Abort() return } //检查令牌是否在 Redis 中存在 _, err = rdb.Get(context.Background(), tokenString).Result() if errors.Is(err, redis.Nil) { c.JSON(http.StatusUnauthorized, gin.H{\\\"error\\\": \\\"invalid token\\\"}) c.Abort() return } else if err != nil { c.JSON(http.StatusInternalServerError, gin.H{\\\"error\\\": \\\"server error\\\"}) c.Abort() return } if claims, ok := token.Claims.(*Claims); ok { c.Set(\\\"username\\\", claims.Username) } else { c.JSON(http.StatusUnauthorized, gin.H{\\\"error\\\": \\\"Invalid token claims\\\"}) c.Abort() return } c.Next() } } func AuthMiddleware() gin.HandlerFunc { return func(c *gin.Context) { token, err := c.Cookie(\\\"token\\\") if err != nil { c.JSON(http.StatusUnauthorized, gin.H{\\\"error\\\": \\\"no token provided\\\"}) c.Abort() return } fmt.Println(token) //将令牌添加到请求头中 c.Request.Header.Set(\\\"Authorization\\\", \\\"Bearer \\\"+token) c.Next() } }\"]},\"39\":{\"h\":\"jwtBucket.go\",\"t\":[\"type TokenBucket struct { capacity int // 令牌桶的容量，即桶中可以持有的最大令牌数 tokens int // 桶中当前的令牌数 fillInterval time.Duration // 令牌填充的间隔时间 mu sync.Mutex // 互斥锁,防止并发访问时的数据竞争 lastFill time.Time // 上次填充令牌的时间 } func NewTokenBucket(capacity int, fillInterval time.Duration) *TokenBucket { return &TokenBucket{ capacity: capacity, tokens: capacity, fillInterval: fillInterval, lastFill: time.Now(), } } func (tb *TokenBucket) Take() bool { tb.mu.Lock() defer func() { tb.mu.Unlock() }() now := time.Now() // 当前时间和上一次填充的时间差 elapsed := now.Sub(tb.lastFill) if elapsed >= tb.fillInterval { // 计算可以填充的令牌数 fillTokens := int(elapsed / tb.fillInterval) // 更新桶中令牌数 tb.tokens += fillTokens // 如果桶中令牌数大于容量，则将令牌数设置为容量 if tb.tokens > tb.capacity { tb.tokens = tb.capacity } // 更新上次填充的时间 tb.lastFill = now } // 检查是否还有令牌可以取 if tb.tokens > 0 { tb.tokens-- return true } return false }\"]},\"40\":{\"h\":\"auth.go\",\"t\":[\"var secretKey = []byte(\\\"mySecretKey\\\") type LoginRequest struct { Username string `json:\\\"username\\\"` Password string `json:\\\"password\\\"` } type Claims struct { Username string `json:\\\"username\\\"` jwt.RegisteredClaims } func generateToken(username string) (string, error) { claims := &Claims{ Username: username, RegisteredClaims: jwt.RegisteredClaims{ Issuer: \\\"Flipped1001\\\", // 发行者 Subject: \\\"test\\\", // 主题\\\" ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Hour * 24)), // 设置过期时间 NotBefore: jwt.NewNumericDate(time.Now()), // 设置token生效开始时间 IssuedAt: jwt.NewNumericDate(time.Now()), // 设置发行时间 }, } token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims) tokenString,err := token.SignedString(secretKey) // 把密钥写进去 if err != nil { return \\\"\\\", err } // 把密钥写进去 // 存储令牌到 Redis err = rdb.Set(context.Background(), tokenString, username, 3600*time.Second).Err() if err != nil { return \\\"\\\", err } return tokenString, nil } func LoginHandler(c *gin.Context) { var req LoginRequest // ShouldBindJSON直接将json数据解析到req if err := c.ShouldBindJSON(&req); err != nil { c.JSON(400, gin.H{\\\"error\\\": \\\"Invalid request\\\"}) return } // 模拟用户认证 if req.Username == \\\"Flipped\\\" && req.Password == \\\"021001\\\" { token, err := generateToken(req.Username) if err != nil { c.JSON(500, gin.H{\\\"error\\\": \\\"Failed to generate token\\\"}) return } c.SetCookie(\\\"token\\\", token, 3600, \\\"/\\\", \\\"localhost\\\", false, true) c.JSON(http.StatusOK, gin.H{\\\"message\\\": \\\"login successful\\\"}) return } else { c.JSON(401, gin.H{\\\"error\\\": \\\"Unauthorized\\\"}) } }\"]},\"41\":{\"h\":\"handler.go\",\"t\":[\"func ProtectedHandler(c *gin.Context) { username, _ := c.Get(\\\"username\\\") c.JSON(200, gin.H{\\\"message\\\": \\\"Hello \\\" + username.(string)}) }\",\"Rdb.go\",\"var ( rdb *redis.Client ) func init() { rdb = redis.NewClient(&redis.Options{ Addr: \\\"localhost:6379\\\", }) }\",\"removeJWT.go\",\"func RevokeToken(c *gin.Context) { tokenString, err := c.Cookie(\\\"token\\\") if err != nil { c.JSON(http.StatusUnauthorized, gin.H{\\\"error\\\": \\\"no token provided\\\"}) return } // 从 Redis 中删除令牌 err = rdb.Del(context.Background(), tokenString).Err() if err != nil { c.JSON(http.StatusInternalServerError, gin.H{\\\"error\\\": \\\"server error\\\"}) return } // 删除 cookie c.SetCookie(\\\"token\\\", \\\"\\\", -1, \\\"/\\\", \\\"localhost\\\", false, true) c.JSON(http.StatusOK, gin.H{\\\"message\\\": \\\"token revoked\\\"}) }\"]},\"42\":{\"h\":\"用户登录\"},\"43\":{\"h\":\"1.什么是OAUTH2.0?\"},\"44\":{\"h\":\"a. OAuth 2.0 授权模式\"},\"45\":{\"h\":\"2.用户扫码是如何实现的\"},\"46\":{\"h\":\"3. 如果要实现不同域名下的cookie正常使用，应该怎么处理？\"},\"47\":{\"h\":\"4.假如1亿用户体量，如何设计一个登录验签服务？\"},\"48\":{\"h\":\"学习笔记\"},\"49\":{\"h\":\"tool\"},\"50\":{\"h\":\"学习疑问\",\"t\":[\"计网部分：\"]},\"51\":{\"h\":\"1.TCP和UDP的区别\",\"t\":[\"TCP和UDP是传输层常见的两种传输协议，提供一种可靠的数据传输和通信方式；\",\"其中，TCP的特点是：面向连接，可靠的，基于字节流的\",\"提供一种可靠的数据传输，所以一般适用于上传下载，网页请求，邮件发送等场景\",\"UDP的特点是：无连接，不可靠的，面向报文的 提供一种快速，但相对不可靠的数据传输，所以常用在对数据实时性要求较高，对数据完整性和正确性不那么高的场景，比如音视频通话，一些实时游戏\"]},\"52\":{\"h\":\"2.TCP是如何做链接管理的？\",\"t\":[\"TCP在连接时使用三次握手，在断开时使用四次握手；确保连接的稳定和可靠\"]},\"53\":{\"h\":\"3.TCP是如何保证可靠的？\",\"t\":[\"通过确认应答机制以及重传机制来保证数据传输的可靠\"]},\"54\":{\"h\":\"4.重传机制有哪些？\",\"t\":[\"1.超时重传：已建立连接或者正在建立连接的两方，其中一方在发出数据包之后超一定时间，不返回ACK包，那么这一方就会认定出现丢包现象，重传这个数据包\",\"2.快速重传：已建立连接或者正在建立连接的两方，其中一方在发出数据包之后，重复三次收到相同的ACK包，那么这一方就会认为数据包丢失，重传数据包； 快速重传解决了超时重传重传周期太长的问题，但是超时重传和快速重传都具有一个问题：在一端 发送一堆数据包之后，其中某一个/几个数据包丢失时，无法精准定位是哪一个/几个，所以会选择将这个数据包之后的所有数据包全部重传一遍，容易造成资源的浪费，和网络的负担\",\"3.SACK：在TCP头部加一个SACK字段在每次接收完数据之后，将接收到数据的信息放到ACK包的这个字段，告知对方接收了哪些数据；这样如果出现数据丢失，发送方根据这一字段就可以精准定位这个丢失包，并且重发这个包\",\"4.Duplicate SACK：又称D_SACK，用于通知发送方哪些数据被重复接收了；让发送方知道时丢包还是网络延迟\"]},\"55\":{\"h\":\"5.TCP是如何保证有序的？\",\"t\":[\"在发送方，当传输层使用TCP协议时，数据包在经过传输层时可能会被拆分成多个小数据包，这个时候在TCP报文段中，每段数据都会被标记上一个序列号，表示数据在数据流中的位置\",\"在发送方接受到这些数据包的时候，会将它放到缓冲区，并根据序列号进行排序和重新组装，以确保数据的有序性\"]},\"56\":{\"h\":\"6.粘包问题？\",\"t\":[\"TCP时一个面向字节流的协议，所谓字节流就是一串没有边界的二进制数据\",\"在当使用TCP协议时，在传输层，一个完整的数据包可能会被拆分成多个小的数据包，也可能多个小的数据包会被合并成一个大数据包发送，就会出现连包和拆包的问题，导致接收方无法正确解析数据边界，造成数据处理错误\",\"解决方法：\",\"1.固定数据长度：在发送数据的同时，将每个包的长度固定\",\"2.使用特殊符号标识边界：例如在每一个完整的数据之后加一个特殊字符\",\"3.自定义消息结构：我们可以自定义一个消息结构，由头部和消息体组成，在头部保存当前整个消息的长度\",\"4.通过自定义协议\"]},\"57\":{\"h\":\"7.滑动窗口\",\"t\":[\"在TCP建立连接的时候，双方协商缓冲区大小，通过Window字段告知对方本端的缓冲区大小， 并在TCP连接建立之后开辟出一片缓冲区\",\"在连接建立之后，发送端就可以跟据接收端和本端窗口大小，向对方发送相应的字节数；接收放在接收完数据之后将其放到缓冲区，等待上层应用读取，当数据被读取，相应的缓冲区就会被释放；并跟据本端剩余缓冲区大小通告对方当前能接受数据的缓冲区大小\",\"发送方根据接收方的窗口变化，相应改变本端的窗口大小；然后发送方就可以根据接收端和本端窗口大小继续发送数据\"]},\"58\":{\"h\":\"8.拥塞控制\",\"t\":[\"1.慢启动：在TCP连接建立完成之后，它发送数据的能力会呈指数形式增长，每收到1次ACK，拥塞窗口加1\",\"2.拥塞避免：当拥塞窗口超过慢启动门限，就会进入拥塞避免算法，此时他发送数据的能力呈线性增长，每当收到一个 ACK 时，cwnd 增加 1/cwnd。\",\"3.拥塞发生：\",\"发生超时重传的拥塞发生算法：慢启动门限变成拥塞窗口/2，直接将拥塞窗口降为1\",\"发生快速重传的拥塞发生算法：将拥塞窗口减半，慢启动门限等于当前拥塞窗口，进入快恢复算法\",\"4.快速恢复：\",\"拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；\",\"重传丢失的数据包；\",\"如果再收到重复的 ACK，那么 cwnd 增加 1；\",\"如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；\"]},\"59\":{\"h\":\"9.TCP的三次握手和四次挥手？\"},\"60\":{\"h\":\"三次握手\"},\"61\":{\"h\":\"1.第一次握手\",\"t\":[\"首先双方都处于closed状态，客户端会发送一个带有SYN（同步序列编号）标志的TCP报文到服务器，表示客户端请求连接；并且在其中客户端还会选择一个ISN（初始序列号）放入SYN报文段中\",\"第一次握手之后：客户端处于SYN_SENT状态（同步已发送），服务器处于LISTEN（监听状态）\"]},\"62\":{\"h\":\"2.第二次握手\",\"t\":[\"服务器同意建立连接，会回复一个带有SYN和ACK（确认号）标识的TCP报文；服务器也会选择一个初始序列号用于标识服务器到客户端的数据流\",\"第二次握手之后：客户端处于SYN_SENT状态，服务器处于SYN-RCVD（半连接状态）\"]},\"63\":{\"h\":\"3.第三次握手\",\"t\":[\"客户端在接收服务器的带有SYN和ACK（确认号）标识的TCP报文之后，会向服务器发送一个带有ACK标志的确认报文段;并且这个报文字段包含客户端收到的服务端的ISN，以及ACK（表示客户端希望下一次接受的序列号）\",\"第三次握手之后：客户端和服务器都进入ESTABLISHED\",\"三次握手的目的是确认双方都有发送和接受的能力\"]},\"64\":{\"h\":\"四次挥手\"},\"65\":{\"h\":\"1.第一次挥手\",\"t\":[\"客户端主动想要断开连接，向服务器发送一个FIN报文，之后客户端进入FIN_WAIT_1状态\"]},\"66\":{\"h\":\"2.第二次挥手\",\"t\":[\"服务端收到该报文，向客户端发送一个ACK报文，服务端进入CLOSE_WAIT状态，客户端接收之后进入FIN_WAIT_2状态\"]},\"67\":{\"h\":\"3.第三次挥手\",\"t\":[\"服务端可能还有数据需要处理和发送，等服务端不再发送数据时，发送FIN报文，之后服务端进入LAST_ACK状态\"]},\"68\":{\"h\":\"4.第四次挥手\",\"t\":[\"客户端向服务端发送ACK报文，服务端接收到报文之后进入CLOSE状态，而客户端则会TIME_WAIT(2MSL)之后进入CLOSE状态\",\"主动关闭连接的，才有 TIME_WAIT 状态。\"]},\"69\":{\"h\":\"10.time_wait状态的意义\",\"t\":[\"TIME_WAIT状态标识一个连接已经完成了关闭过程，并且在等最后的确认报文\",\"有两点作用：\",\"第一点：\",\"防止历史连接中的数据，被后面相同四元组的连接错误的接收；\",\"第二点：\",\"保证「被动关闭连接」的一方，能被正确的关闭；\",\"如果没有time_wait状态或者time_wait时间太短，可能导致数据错乱或者连接错误\"]},\"70\":{\"h\":\"11.为什么需要三次握手而不是四次，两次\"},\"71\":{\"h\":\"什么是restful风格？\",\"t\":[\"RESTful 是一种针对网络应用程序设计的架构风格，它基于 HTTP 协议，强调了资源的标识、状态和操作的统一性。\"]},\"72\":{\"h\":\"SQL的DCL\"},\"73\":{\"h\":\"DCL\",\"t\":[\"DCL数据控制语言，用来创建数据库用户,控制数据库的访问权限\",\"1. 查询用户 USE mysql; SELECT * FROM `user`; 2. 创建用户 CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 3. 修改用户密码 ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码'; 4. 删除用户 DROP USER '用户名'@'主机名'; #创建用户只能在当前主机上访问，密码123456 CREATE USER 'main'@'localhost' IDENTIFIED BY '123456'; #创建用户能在任意主机上访问，密码123456 CREATE USER 'main'@'%' IDENTIFIED BY '123456'; #修改用户密码 ALTER USER 'mian'@'%' IDENTIFIED WITH mysql_native_password BY '1234'; #删除用户 DROP USER 'mian'@'localhost';\",\"注意:\",\"主机名可以使用%通配。\",\"这类SQL开发人员操作的比较少,主要是DBA(Database Administrator 数据库管理员)使用。\",\"权限\",\"说明\",\"ALL, ALL PRIVILEGES\",\"所有权限\",\"SELECT\",\"查询数据\",\"INSERT\",\"插入数据\",\"UPDATE\",\"修改数据\",\"DELETE\",\"删除数据\",\"ALTER\",\"修改表\",\"DROP\",\"删除数据库/表/视图\",\"CREATE\",\"创建数据库/表\",\"1. 查询权限 SHOW GRANTS FOR '用户名’@'主机名’; 2. 授予权限 GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名'; 3. 撤销权限 REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';\",\"注意:\",\"多个权限之间,使用逗号分隔\",\"授权时,数据库名和表名可以使用*进行通配,代表所有。\"]},\"74\":{\"h\":\"SQL的DDL\"},\"75\":{\"h\":\"DDL\"},\"76\":{\"h\":\"SQL的DML\"},\"77\":{\"h\":\"DML\",\"t\":[\"DML数据库操作语言，用来对数据库表中的数据进行增删改查\",\"#给指定字段添加数据 INSERT INTO 表名(字段名1，字段名2,...)VALUE(值1，值2) #例子 INSERT INTO `flipped-user1`(`NAME`，`AGE`)VALUE('ALice',30) #给全部的字段添加数据 INSERT INTO 表名 VALUES(值1，值2,..) #例子 INSERT INTO `flipped-user1`VALUES(NULL,'Alice',30); #批量添加数据 INSERT INTO 表名(字段名1,字段名2, .. )VALUES(值1,值2,.),(值1,值2, .. ),(值1,值2, ... ); INSERT INTO 表名VALUES(值1,值2,.),(值1,值2, .. ),(值1,值2, ... ); #例子 INSERT INTO `flipped-user1` (`NAME`, `AGE`) VALUES ('Alice', 2), ('Bob', 3), ('Charlie', 4); #修改数据 UPDATE 表名 SET 字段名1=值1,字段名2=值2,...[WHERE 条件]; #例子 UPDATE `flipped-user1`SET name = '倪浩' WHERE name='flipped'; #删除数据（NULL 是一个特殊的值，不能使用普通的等号（=）进行比较，应该使用 IS NULL 进行比较） DELETE FROM 表名 [WHERE 条件] DELETE FROM `flipped-user1` WHERE `name` IS NULL;\"]},\"78\":{\"h\":\"SQL的DQL\"},\"79\":{\"h\":\"DQL\",\"t\":[\"DQL数据查询语言，用来查询数据库中表的记录\",\"FROM: 确定要查询的表。 JOIN: 如果有多表查询，处理表连接。 WHERE: 过滤符合条件的记录。 GROUP BY: 将记录进行分组。 HAVING: 过滤分组后的记录。 SELECT: 选择要返回的列。 DISTINCT: 去除重复的记录。 ORDER BY: 对记录进行排序。 LIMIT/OFFSET: 返回限定的记录数。 #基本查询 1.查询多个字段 SELECT 字段1，字段2，字段3....FROM 表名; SELECT * FROM 表名; 2.设置别名 SELECT 字段1[AS 别名1],字段2[AS 别名2]...FROM 表名; #例子 SELECT `workadress` AS '工作地点' FROM `emp`; 也可以省去AS SELECT `workadress` '工作地点' FROM `emp`; 3.去除重复记录 SELECT DISTINCT 字段列表 FROM 表名; #例子 SELECT DISTINCT `workadress` '工作地点' FROM `emp`; #条件查询 SELECT 字段列表 FROM 表名 WHERE 条件列表; #例子 SELECT * FROM `emp` WHERE `idcard` IS NOT NULL; SELECT * FROM `emp` WHERE `age` > 15 AND `age` < 20; SELECT * FROM `emp` WHERE `age` BETWEEN 15 AND 20; SELECT * FROM `emp` WHERE `age`= 18 OR `age`= 20 OR `age`= 40; SELECT * FROM `emp` WHERE `age` IN(18,20,40); 查询两个字的姓名 SELECT * FROM `emp` WHERE `name` LIKE '__';\",\"比较运算符\",\"功能\",\">\",\"大于\",\">=\",\"大于等于\",\"<\",\"小于\",\"<=\",\"小于等于\",\"=\",\"等于\",\"<> 或 !=\",\"不等\",\"BETWEEN ... AND ...\",\"在某个范围之内(含最小、最大值)\",\"IN( ... )\",\"在in之后的列表中的值,多选一\",\"LIKE 占位符\",\"模糊匹配(_匹配单个字符,%匹配任意个字符)\",\"IS NULL\",\"是NULL\",\"逻辑运算符\",\"功能\",\"AND 或 &&\",\"并且(多个条件同时成立)\",\"OR 或Ⅱ\",\"或者(多个条件任意一个成立)\",\"NOT 或!\",\"非,不是\"]},\"80\":{\"h\":\"聚合函数\",\"t\":[\"函数\",\"功能\",\"count\",\"统计数量\",\"max\",\"最大值\",\"min\",\"最小值\",\"avg\",\"平均值\",\"sum\",\"求和\",\"SELECT 聚合函数(字段列表) FROM 表名; #统计数量 SELECT COUNT(*) FROM `emp`; SELECT COUNT(`id`) FROM `emp`; #统计平均数 SELECT AVG(`age`) FROM `emp`; #统计最大值 SELECT MAX(`age`) FROM `emp`; #最小值 SELECT MIN(`age`) FROM `emp`; SELECT SUM(`age`) FROM `emp` WHERE `workadress` = `西安`;\",\"SELECT 字段列表 FROM 表名[WHERE 条件]GROUP BY 分组字段[HAVING 分组后的过滤条件]; #根据性别分组，并计算总和 SELECT `gender` ,COUNT(*) FROM `emp` GROUP BY `gender`; #根据性别分组，并计算年龄平均值 SELECT `gender`, AVG(`age`) FROM `emp` GROUP BY `gender`; #查询年龄小于45，根据工作地址分组，并获取人数大于三的工作地址 SELECT `workadress`, COUNT(*) FROM `emp`WHERE `age` < 45 GROUP BY `workadress` HAVING COUNT(*) > 3;\",\"1.where与having区别\",\"执行时机不同: where是分组之前进行过滤,不满足where条件,不参与分组;而having是分组之后对结果进行过滤。\",\"判断条件不同:where不能对聚合函数进行判断,而having可以。\",\"注意· 执行顺序:where>聚合函数>having。· 分组之后,查询的字段一般为聚合函数和分组字段,查询其他字段无任何意义。\",\"SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1，字段2 排序方式2; #根据年龄进行升序排序 SELECT * FROM `emp` ORDER BY `age` ASC; #根据年龄进行升序排序，如果年龄相同，再按照入职时间进行降序排序 SELECT * FROM `emp` ORDER BY `age` ASC, `entrydate` DESC;\",\"排序方式\",\"ASC: 升序(默认值)\",\"DESC: 降序\",\"注意:如果是多字段排序,当第一个字段值相同时,才会根据第二个字段进行排序。\",\"SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数; #查询第一页数据，每页展示十条数据 SELECT * FROM `emp` LIMIT 0,10; #查询第二页数据，每页展示十条数据 SELECT * FROM `emp` LIMIT 10,10;\",\"注意\",\"*起始索引从0开始,起始索引=(查询页码-1)每页显示记录数。\",\"分页查询是数据库的方言,不同的数据库有不同的实现,MySQL中是LIMIT。\",\"如果查询的是第一页数据,起始索引可以省略,直接简写为limit 10。\",\"1. 查询年龄为20,21,22,23岁的员工信息。 2. 查询性别为男,并且年龄在20-40岁(含)以内的姓名为三个字的员工。 3. 统计员工表中,年龄小于60岁的,男性员工和女性员工的人数。 4. 查询所有年龄小于等于35岁员工的姓名和年龄,并对查询结果按年龄升序排序,如果年龄相同按入职时间降序排序。 5. 查询性别为男,且年龄在20-40岁(含)以内的前5个员工信息,对查询的结果按年龄升序排序,年龄相同按入职时间升序排序。 SELECT * FROM `emp` WHERE `age` IN (20,21,22,23); SELECT * FROM `emp` WHERE `age`>=20 AND `age`<=40 AND `name` LIKE '___'; SELECT `gender`, COUNT(*) FROM `emp` WHERE `age` < 60 GROUP BY `gender`; SELECT `name`,`age` FROM `emp` WHERE `age`<=35 ORDER BY `age` , `entrydate` DESC; SELECT * FROM `emp` WHERE `gender` = '男' AND `age`>=20 AND `age`<=40 ORDER BY `entydate` ASC LIMIT 5 ;\"]},\"81\":{\"h\":\"EXPLAIN 一个SQL语句\"},\"82\":{\"h\":\"EXPLAIN 一个SQL语句可以查询到什么？\"},\"83\":{\"h\":\"SQL中的函数\"},\"84\":{\"h\":\"字符串函数\",\"t\":[\"函数\",\"功能\",\"CONCAT(S1,S2,….Sn)\",\"字符串拼接,将S1,S2,…Sn拼接成一个字符串\",\"LOWER(str)\",\"将字符串str全部转为小写\",\"UPPER(str)\",\"将字符串str全部转为大写\",\"LPAD(str,n,pad)\",\"左填充,用字符串pad对str的左边进行填充,达到n个字符串长度\",\"RPAD(str,n,pad)\",\"右填充,用字符串pad对str的右边进行填充,达到n个字符串长度\",\"TRIM(str)\",\"去掉字符串头部和尾部的空格\",\"SUBSTRING(str,start,len)\",\"返回从字符串str从start位置起的len个长度的字符串\",\"#由于业务需求变更,企业员工的工号,统一为5位数,目前不足5位数的全部在前面补0。比如:1号员工的工号应该为00001。 UPDATE `emp` SET `workon` = LPAD(`workon`,5,'0');\"]},\"85\":{\"h\":\"数值函数\",\"t\":[\"函数\",\"功能\",\"CEIL(x)\",\"向上取整\",\"FLOOR(×)\",\"向下取整\",\"MOD(x,y)\",\"返回x/y的模\",\"RAND()\",\"返回0~1内的随机数\",\"ROUND(x,y)\",\"求参数x的四舍五入的值,保留y位小数\",\"-- ceil select ceil(1.1); #结果2 -- floor select floor(1.9); #结果1 -- mod select mod(3,4); #结果3 取余 -- rand select rand(); #0-1内的随机数 -- round select round(2.34,2); #通过数据库的函数,生成一个六位数的随机验证码。 select lpad(round(rand() * 1000000,0),6,'0');\"]},\"86\":{\"h\":\"日期函数\",\"t\":[\"函数\",\"功能\",\"CURDATE()\",\"返回当前日期\",\"CURTIME()\",\"返回当前时间\",\"NOW()\",\"返回当前日期和时间\",\"YEAR(date)\",\"获取指定date的年份\",\"MONTH(date)\",\"获取指定date的月份\",\"DAY(date)\",\"获取指定date的日期\",\"DATE_ADD(date, INTERVAL expr type)\",\"返回一个日期/时间值加上一个时间间隔expr后的时间值\",\"DATEDIFF(date1,date2)\",\"返回起始时间date1和 结束时间date2之间的天数\",\"DATE_SUB(date, INTERVAL value unit)\",\"从指定的日期或时间值中减去指定的时间间隔。\",\"select curdate();#获取当前日期 select curtime();#获取当前时间 select now();#获取当前日期和时间 select YEAR(now());#获取当前年份 select MONTH(now());#获取当前月份 select DAY(now());#获取当前的日期（某一日） select date_add(now(),INTERVAL 60 DAY);#间隔60天 select DATE_SUB(date, INTERVAL value unit) #从指定的日期或时间值中减去指定的时间间隔。 select datediff('2018-09-01','2024-12-18')#求取两个时间之间的天数（第一个减第二个时间） #查询所有员工入职天数，并根据入职天数倒序排序 select `name`,datediff(curdate(),`entrydate`) as 'entrydates' from `emp` order by 'entrydates' de;\"]},\"87\":{\"h\":\"流程函数\",\"t\":[\"函数\",\"功能\",\"IF(value , t, f)\",\"如果value为true，则返回t，否则返回f\",\"IFNULL(value1, value2)\",\"如果value1不为空，返回value1，否则返回value2\",\"CASE WHEN [val1] THEN [res1] ... ELSE[default] END\",\"如果val1为true，返回res1，... 否则返回default默认值\",\"CASE[expr] WHEN [val1] THEN [res1] ...ELSE[default] END\",\"如果expr的值等于val1，返回res1，...否则返回default默认值\",\"select if(true,\\\"ok\\\",\\\"error\\\"); select ifnull(\\\"ok\\\",\\\"default\\\") -- 需求: 查询emp 表的员工姓名和工作地址(北京/上海 ---> 一线城市 ， 其他 ---> 二线城市) select `name`, (case `address` when '北京' then '一线城市' when '上海' then '一线城市' else '二线城市' end) as '工作地址' from emp; -- 案例: 统计班级各个学员的成绩，展示的规则如下: -- >= 85，展示优秀 -- >= 60，展示及格 -- 否则，展示不及格 create table score( id int comment 'ID', name varchar(20) comment '姓名', math int comment '数学', english int comment '英语', chinese int comment '语文' )comment '学员成绩表'; insert into score (id, name, math, english, chinese) values (1, 'Tom', 67, 88, 95), (2, 'Rose', 23, 66, 90), (3, 'Jack', 56, 98, 76); SELECT id, `name`, (case WHEN `math` >=85 THEN '优秀' WHEN `math` >=60 THEN '及格' ELSE '不及格' END)AS '数学', `english`, `chinese` FROM `score`;\"]},\"88\":{\"h\":\"SQL的约束\"},\"89\":{\"h\":\"约束\",\"t\":[\"概念:约束是作用于表中字段上的规则，用于限制存储在表中的数据。 目的:保证数据库中数据的正确、有效性和完整性\",\"分类\",\"描述\",\"关键字\",\"非空约束\",\"限制该字段数据不能为NULL\",\"NOT NULL\",\"唯一约束\",\"保证该字段的所有数据都是唯一，不重复的\",\"UNIOUE\",\"主键约束\",\"主键是一行数据的唯一标识，要求非空且唯一\",\"PRIMARY KEY\",\"默认约束\",\"保存数据时，如果未指定该字段的值，则采用默认值\",\"DEFAULT\",\"检查约束(8.0.16版本之后)\",\"保证字段值满足某一个条件\",\"CHECK\",\"外键约束\",\"用来让两张表的数据之间建立连接，保证数据的一致性和完整性\",\"FOREIGN KEY\",\"CREATE TABLE user ( id INT PRIMARY KEY AUTO_INCREMENT COMMENT '主键', name VARCHAR(10) NOT NULL UNIQUE COMMENT '姓名', age INT CHECK (age > 0 AND age <= 120) COMMENT '年龄', status CHAR(1) DEFAULT '1' COMMENT '状态', gender CHAR(1) COMMENT '性别' ) COMMENT '用户表';\"]},\"90\":{\"h\":\"外键约束\",\"t\":[\"概念：外键用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性\",\"-- 创建表 dept CREATE TABLE dept ( id INT AUTO_INCREMENT PRIMARY KEY COMMENT 'ID', name VARCHAR(50) NOT NULL COMMENT '部门名称' ) COMMENT '部门表'; -- 插入数据 INSERT INTO dept (id, name) VALUES (1, '研发部'), (2, '市场部'), (3, '财务部'), (4, '销售部'), (5, '总经办'); -- 创建表 emp CREATE TABLE emp ( id INT AUTO_INCREMENT PRIMARY KEY COMMENT 'ID', name VARCHAR(50) NOT NULL COMMENT '姓名', age INT COMMENT '年龄', job VARCHAR(20) COMMENT '职位', salary INT COMMENT '薪资', entrydate DATE COMMENT '入职时间', managerid INT COMMENT '直属领导ID', dept_id INT COMMENT '部门ID' ) COMMENT '员工表'; -- 插入数据 INSERT INTO emp (name, age, job, salary, entrydate, managerid, dept_id) VALUES ('金庸', 66, '总裁', 20000, '2000-01-01', NULL, 5), ('张无忌', 20, '项目经理', 12500, '2005-12-05', 1, 1), ('杨道', 33, '开发', 8400, '2000-11-03', 2, 1), ('韦一笑', 48, '开发', 11000, '2002-08-05', 2, 1), ('常遇春', 43, '开发', 10580, '2004-09-07', 3, 1), ('小昭', 19, '程序员鼓励师', 6600, '2004-10-12', 2, 1); -- 添加外键 ALTER TABLE emp ADD CONSTRAINT fk_emp_dept_id FOREIGN KEY (dept_id) REFERENCES dept(id); -- 删除外键 ALTER TABLE emp DROP FOREIGN KEY fk_emp_dept_id;\",\"-- 添加外键 CREATE TABLE 表名( 字段名 数据类型 ... [CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名) ); ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段) REFERENCES 主表(主表列名); -- 删除外键 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\",\"外键的(删除/更新)行为：\",\"行为\",\"说明\",\"NO ACTION\",\"当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。(与 RESTRICT一致)\",\"RESTRICT\",\"当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。(与NO ACTION 一致\",\"CASCADE\",\"当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录。\",\"SET NULL\",\"当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null(这就要求该外键允许取null)\",\"SET DEFAULT\",\"父表有变更时，子表将外键列设置成一个默认的值(Innodb不支持)\",\"ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段) ON UPDATE CASCADE ON DELETE CASCADE; ALTER TABLE emp ADD CONSTRAINT fk_emp_dept_id FOREIGN KEY (dept_id) REFERENCES dept(id) ON UPDATE CASCADE ON DELETE CASCADE;\"]},\"91\":{\"h\":\"MySQL的锁\"},\"92\":{\"h\":\"全局锁\",\"t\":[\"一般适用于：数据库的备份以及迁移\",\"flush tables with read lock\",\"加上全局锁之后，数据库就属于只读的状态。其他操作都会被阻塞，直到全局锁被释放。\",\"unlock tables\"]},\"93\":{\"h\":\"表级锁定\"},\"94\":{\"h\":\"普通表锁：\",\"t\":[\"//表级别的共享锁，也就是读锁； lock tables table_name read; //表级别的独占锁，也就是写锁； lock tables table_name write; unlock tables\"]},\"95\":{\"h\":\"元数据锁（MDL）\",\"t\":[\"在数据库中不需要直接加上元数据锁：\",\"在MySQL中当我们进行CURD时，会自动给这个表加上MDL读锁\",\"当我们进行结构操作时，会自动加上MDL写锁\",\"在语句执行的时候会立即加锁，但是在语句执行完毕之后不会立即释放，一直到事务提交才会释放锁\",\"警告\",\"在数据库被大量调用的时候，轻易不要去改变数据库的结构包括增加一个字段或者去增加一个索引，会造成严重的业务问题\"]},\"96\":{\"h\":\"意向锁\",\"t\":[\"在innodb对数据加锁之前会先在表级加上一个意向锁\",\"//先在表上加上意向共享锁，然后对读取的记录加共享锁 select ... lock in share mode; //先表上加上意向独占锁，然后对读取的记录加独占锁 select ... for update;\",\"意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables ... read）和独占表锁（lock tables ... write）发生冲突。\",\"当一个被插上意向锁，说明这个表中是有锁的。\"]},\"97\":{\"h\":\"AUTO-INC 锁\",\"t\":[\"在插入数据时，会加一个表级别的 AUTO-INC 锁，然后为被 AUTO_INCREMENT 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。\",\"其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 AUTO_INCREMENT 修饰的字段的值是连续递增的。\",\"InnoDB 存储引擎提供了一种轻量级的锁来实现自增。一样也是在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁。\"]},\"98\":{\"h\":\"行级锁\",\"t\":[\"//对读取的记录加共享锁 select ... lock in share mode; //对读取的记录加独占锁 select ... for update;\",\"共享锁（S锁）满足读读共享，读写共享。独占锁（X锁）满足写写互斥，读写互斥。\"]},\"99\":{\"h\":\"Record Lock\",\"t\":[\"Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：\",\"当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;\",\"当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。\"]},\"100\":{\"h\":\"Gap Lock\",\"t\":[\"间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的\"]},\"101\":{\"h\":\"Next-Key Lock\",\"t\":[\"next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的\"]},\"102\":{\"h\":\"插入意向锁\",\"t\":[\"一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。\",\"如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个插入意向锁，将锁的状态设置为等待状态，表明有事务想在某个区间插入新记录，但是现在处于等待状态。\",\"[!IMPORTANT]\",\"MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁\"]},\"103\":{\"h\":\"高性能的redis\"},\"104\":{\"h\":\"Redis\",\"t\":[\"Redis最主动的特点就是高性能，高并发；因为Redis是基于内存的且是单线程的，实现I/O的多路复用\"]},\"105\":{\"h\":\"redis和Memcached的区别：\",\"t\":[\"两者都是基于内存的数据库，一般被当作缓存来使用。\",\"都有过期策略。\",\"两者的性能都非常高。\",\"两者的区别：\",\"redis支持的数据类型丰富（String，Hash，List，Set，Zset），而Memcached只支持最简单的key-value数据类型\",\"Redis支持数据的持久化，可以将内存中的数据保存到磁盘中，重启的时候后重新加载，而Memcached没有持久化功能，数据全在内存中，Memcached重启或者挂掉，数据就没有了\",\"Redis 原生支持集群模式，Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据;\",\"Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持\"]},\"106\":{\"h\":\"redis的内存淘汰\"},\"107\":{\"h\":\"当Redis内存满了\",\"t\":[\"在 Redis 的运行内存达到了某个阀值，就会触发内存淘汰机制，这个阀值就是我们设置的最大运行内存此值在 Redis 的配置文件中可以找到，配置项为 maxmemory。\",\"这个时候就需要进行内存淘汰了，在redis中大体有两种策略：\"]},\"108\":{\"h\":\"不进行数据淘汰的策略\",\"t\":[\"noeviction(Redis3.0之后，默认的内存淘汰策略)：它表示当运行内存超过最大设置内存时，不淘汰任何数据，而是不再提供服务，直接返回错误。\"]},\"109\":{\"h\":\"进行数据淘汰的策略\",\"t\":[\"这个策略又可以分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。\"]},\"110\":{\"h\":\"1. 在设置了过期时间的数据中进行淘汰\",\"t\":[\"volatile-random：随机淘汰设置了过期时间的任意键值\",\"volatile-ttl：优先淘汰更早过期的键值。\",\"volatile-lru (Redis3.0 之前，默认的内存淘汰策略)：淘汰所有设置了过期时间的键值中，最久未使用的键值\",\"volatile-lfu (Redis 4.0 后新增的内存淘汰策略)：淘汰所有设置了过期时间的键值中，最少使用的键值\"]},\"111\":{\"h\":\"2. 在所有数据范围内进行淘汰\",\"t\":[\"allkeys-random：随机淘汰任意键值\",\"allkeys-Iru：淘汰整个键值中最久未使用的键值\",\"allkeys-lfu (Redis 4.0 后新增的内存淘汰策略)：淘汰整个键值中最少使用的键值\"]},\"112\":{\"h\":\"LRU算法和LFU算法\"},\"113\":{\"h\":\"LRU算法：\",\"t\":[\"LRU算法是什么？\",\"LRU 全称是Least Recently Used翻译为最近最少使用，会选择淘汰最近最少使用的数据。\",\"传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素\",\"传统的 LRU 算法存在两个问题\",\"需要用链表管理所有的缓存数据，这会带来额外的空间开销\",\"当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能\",\"Redis是如何实现LRU算法的？\",\"Redis 实现的是一种近似 LRU 算法，目的是为了更好的节约内存。\",\"它的实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间。 当 Redis 进行内存淘汰时，会使用随机采样的方式来淘汰数据它是随机取 5 个值（此值可配置），然后淘汰最久没有使用的那个\",\"优点\",\"不用为所有的数据维护一个大链表，节省了空间占用\",\"不用在每次数据访问时都移动链表项，提升了缓存的性能\",\"缺点\",\"无法解决缓存污染问题，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染。因此，在 Redis 4.0 之后引入了 LFU 算法来解决这人问题。\"]},\"114\":{\"h\":\"LFU算法\",\"t\":[\"什么是LFU算法？\",\"LFU 全称是Least Frequently Used翻译为最近最不常用的，LFU 算法是根据数据访问次数来淘汰数据的它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。\",\"所以，LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。\",\"Redis是如何实现LFU算法的？\",\"在 LRU 算法中，Redis 对象头的 24 bits 的lru 字段是用来记录 key 的访问时间戳，因此在LRU 模式下，Redis可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key。\",\"在LFU 算法中，Redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存诸ldt(Last DecrementTime)，用来记录 key 的访问时间戳；低 8bit 存储 logc(Logistic Counter)「访问频次」，用来记录 key 的访问频次。\"]},\"115\":{\"h\":\"穿透、击穿、雪崩\"},\"116\":{\"h\":\"缓存雪崩\",\"t\":[\"现象：当大量缓存数据在同一时间过期失效，如果此时有大量请求访问，就只能全打到你的db上，让数据库的压力骤增，严重会造成数据库宕机，从而造成一系列服务崩溃\",\"应对方式：\",\"合理的设置缓存过期时间，有意识地将过期时间分开\",\"加锁，在处理请求的时候如果发现Redis中没有要查找的数据，就加一个锁，保证同一时间内针对某一条数据就只有一个请求会去访问数据库，然后将数据发给所有的请求。当缓存构建之后，在释放锁。\",\"实现互斥锁的时候，最好设置超时时间，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。\",\"将缓存设置为永不过期，由后台自主的去更新缓存数据。这样可能会造成内存负担，然后会有Redis的缓存淘汰机制，会将一部分数据给淘汰掉，那直到下一次数据更新，这些被淘汰的数据是无法展示给数据库的，就造成数据丢失。解决这个问题可以有两种办法：\",\"给更新缓存的线程再加一个用途用来频繁的去检测缓存是否有效，当缓存失效是就立马去数据库中读取数据更新到缓存（检测时间不能太长会造成用户体验差）\",\"当业务线程发现缓存失效后，通过消息队列的形式发送一条消息给后台更新缓存，然后后台可以在更新前检查一下缓存状态，再决定是否更新\",\"在业务刚刚上线的时候，进行缓存预热\"]},\"117\":{\"h\":\"Redis服务宕机造成缓存雪崩\",\"t\":[\"解决：\",\"服务熔断请求限流，在Redis宕机的时候，启动服务熔断，暂停对缓存的访问直接返回错误，不去访问数据库，降低对数据库的压力。 为了减少对服务的影响，我们可以对请求进行限流，只允许部分请求去找数据，再多的就直接拒绝\",\"构建缓存集群，在主节点崩溃后服务也可以正常运行\"]},\"118\":{\"h\":\"缓存击穿\",\"t\":[\"hot key问题，在一个频繁访问的缓存过期，那这个大量的请求也会达到db上造成数据库宕机\",\"互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。\",\"不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间。\"]},\"119\":{\"h\":\"缓存穿透\",\"t\":[\"当用户访问的数据，既不在缓存中也不再数据库中，这样也不能构建缓存，所有打进来的请求都会直接到db上，这就是穿透\",\"缓存穿透的发生一般有这两种情况:\",\"业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据\",\"黑客恶意攻击，故意大量访问某些读取不存在数据的业务\",\"应对缓存穿透的方案：\",\"第一种方案，非法请求的限制\",\"第二种方案，缓存空值或者默认值\",\"第二种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在\",\"第一种方案，非法请求的限制\",\"当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。\",\"第二种方案缓存空值或者默认值\",\"当我们线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。\",\"第三种方案，使用布隆过滤器判断数据是否存在\",\"在数据库中加入数据的时候，在布隆过滤器中标记一下，后面在缓存失效的情况下请求直接打到db上，就可以先去查询布隆过滤器就判断这个数据是否存在数据库中，如果不在就不需要再去访问数据库\",\"布隆过滤器\",\"布隆过滤器由「初始值都为 0 的位图数组」和「 N 个哈希函数」两部分组成。\",\"布隆过滤器会通过 3 个操作完成标记\",\"第一步，使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值。\",\"第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。\",\"第二步，将每个哈希值在位图数组的对应位置的值设置为 1。\",\"布隆过滤器由于是基于哈希函数实现查找的，高效查找的同时存在哈希冲突的可能性，所以在查询的时候布隆过滤器说这个数据存在，那么这个数据不一定存在；如果他说不存在，就一定不存在。\"]},\"120\":{\"h\":\"数据一致性\"},\"121\":{\"h\":\"数据一致性\"},\"122\":{\"h\":\"双写策略\",\"t\":[\"先写数据库，再写缓存\",\"在遇到并发的时候会出现问题：A 请求先将数据库的数据更新为 1，然后在更新缓存前，请求 B 将数据库的数据更新为 2，紧接着也把缓存更新为 2，然后 A 请求更新缓存为 1。\",\"先写缓存，再写数据库\",\"也会因为并发问题，A 请求先将缓存的数据更新为 1，然后在更新数据库前，请求 B 将缓存的数据更新为 2，紧接着也把数据库更新为 2，然后 A 请求更新数据库为 1。\",\"解决双写策略的问题，我们可以：\",\"在缓存执行更新之前去加一个分布式锁，保证在同一时间只去运行同一个请求的更新（单飞）。但这也会带来性能问题。\",\"在更新完缓存的时候，给缓存加上一个较短的过期时间，这样哪怕出现数据不一致的问题，也仅仅只是一会，不会影响业务。\"]},\"123\":{\"h\":\"读时更新，写时删除\",\"t\":[\"先删缓存，再写数据库\",\"如果有两个请求中一个请求执行数据的更新，那么他就会先去删除缓存；在这期间另一个请求去读取数据，然后将数据库中未修改的数据更新到缓存中；然后第一个请求去修改数据库中的数据；这就会导致最终数据库中的数据和缓存中的数据不一致。\",\"解决这个问题，我们可以采用延时双删的策略，下面是延时双删的伪代码：\",\"//删除缓存 redis.DEL(context.Background(),\\\"x\\\") //更新数据库 db.update(x) //睡眠 time.sleep(N) //在删除缓存 redis.DEL(context.Background(),\\\"x\\\")\",\"中间睡几秒是为了，请求B能够完成从数据库读取数据，并存到缓存中。\",\"先更新数据库，再删除缓存\",\"假如某个用户数据在缓存中不存在，请求 A 读取数据时从数据库中查询到年龄为 20，在未写入缓存中时另一个请求 B 更新数据。它更新数据库中的年龄为 21，并且清空缓存。这时请求A 把从数据库中读到的年龄为 20 的数据写入到缓存中。\",\"但这只是理论上的，在实际中缓存写入是远比数据库写入快的。所以很难出现请求A的缓存还没写入请求B就已经更新数据的情况，并且如果A的数据缓存更新在B删除缓存之前，也是后面回去数据库直接查找数据。所以他是可以保证数据一致性的。\",\"注\",\"由于这是两步操作，所以可能会出现第二个操作失败的情况，这时候我们就可以采用消息队列重试机制。当操作失败就重式直到完成，或达到上限，返回错误。\"]},\"124\":{\"h\":\"永不过期，由后端自主更新\",\"t\":[\"设置一个定时器，定时去数据库中拉去新的数据。\",\"采用监听binlog，当数据库有更新操作的时候，再去更新数据\"]},\"125\":{\"h\":\"单飞\",\"t\":[\"package main import ( \\\"context\\\" \\\"fmt\\\" \\\"github.com/go-redis/redis/v8\\\" \\\"time\\\" ) var ( Rdb *redis.Client ctx = context.Background() lockKey = \\\"my-lock-key\\\" ) func getRdb() { Rdb = redis.NewClient(&redis.Options{ Addr: \\\"8.130.17.124:6379\\\", Password: \\\"021001\\\", DB: 2, }) fmt.Println(\\\"Redis连接成功\\\") } func Close() { err := Rdb.Close() if err != nil { return } fmt.Println(\\\"Redis关闭成功\\\") } // 尝试去获取锁 func acquireLock() (bool, error) { result, err := Rdb.SetNX(ctx, lockKey, \\\"1\\\", 5*time.Second).Result() if err != nil { return false, err } return result, nil } // 释放锁 func releaseLock() error { _, err := Rdb.Del(ctx, lockKey).Result() if err != nil { return err } return nil } func main() { getRdb() defer Close() locked, err := acquireLock() if err != nil { fmt.Println(err) return } if locked { fmt.Println(\\\"获取锁成功\\\") // 业务逻辑 time.Sleep(6 * time.Second) //释放锁 err = releaseLock() if err != nil { fmt.Println(err) return } fmt.Println(\\\"释放锁成功\\\") } else { fmt.Println(\\\"获取锁失败,另一个进程持有锁\\\") } } //func main() { // getRdb() // defer Close() // // lockKey = \\\"my-lock-key\\\" // // // 模拟另一个进程持有锁 // fmt.Println(\\\"模拟另一个进程持有锁...\\\") // locked, err := acquireLock() // if err != nil { // fmt.Println(\\\"锁初始化失败:\\\", err) // return // } // // if locked { // fmt.Println(\\\"锁已设置 (模拟另一个进程持有锁)\\\") // // // 等待一段时间后尝试获取锁 // time.Sleep(2 * time.Second) // // // 当前进程尝试获取锁 // fmt.Println(\\\"当前进程尝试获取锁...\\\") // lockedAgain, err := acquireLock() // if err != nil { // fmt.Println(\\\"获取锁失败:\\\", err) // return // } // // if lockedAgain { // fmt.Println(\\\"成功获取锁，处理任务中...\\\") // } else { // fmt.Println(\\\"获取锁失败，另一进程仍持有锁。\\\") // } // // // 释放锁 // fmt.Println(\\\"释放锁...\\\") // err = releaseLock() // if err != nil { // fmt.Println(\\\"释放锁失败:\\\", err) // } else { // fmt.Println(\\\"锁已释放\\\") // } // // } else { // fmt.Println(\\\"无法设置模拟锁，可能锁已被占用。\\\") // } //}\"]},\"126\":{\"h\":\"延时队列\"},\"127\":{\"h\":\"使用Redis实现延时队列\",\"t\":[\"Redis 实现延迟队列可以通过多种方法，主要依赖于 Redis 提供的基本数据结构和命令。最常用的方法包括使用 sorted sets（有序集合）和 list（列表）。\",\"func (c cmdable) ZAdd(ctx context.Context, key string, members ...*Z) *IntCmd\",\"members ...*Z，代表有序集合的元素，是一个或多个redis.Z结构体的切片。每个结构体包含Score和Member两个字段，Score代表元素的分数，Member是元素的值。\",\"package main import ( \\\"fmt\\\" \\\"github.com/go-redis/redis/v8\\\" \\\"golang.org/x/net/context\\\" \\\"time\\\" ) var ( Rdb *redis.Client ctx = context.Background() lockKey = \\\"my-lock-key\\\" ) func getRdb() { Rdb = redis.NewClient(&redis.Options{ Addr: \\\"\\\", Password: \\\"\\\", DB: 2, }) fmt.Println(\\\"Redis连接成功\\\") } func Close() { err := Rdb.Close() if err != nil { return } fmt.Println(\\\"Redis关闭成功\\\") } func main() { getRdb() //defer Close() Rdb.ZAdd(ctx, \\\"delay_queue\\\", &redis.Z{ //10秒后执行 Score: float64(time.Now().Add(10 * time.Second).Unix()), Member: \\\"task1\\\", }) ticker := time.NewTicker(1 * time.Second) for { select { case <-ticker.C: //查询到期任务 now := float64(time.Now().Unix()) tasks, err := Rdb.ZRangeByScore(ctx, \\\"delay_queue\\\", &redis.ZRangeBy{ Min: \\\"-inf\\\", //负无穷大 Max: fmt.Sprintf(\\\"%f\\\", now), }).Result() if err != nil { fmt.Println(\\\"查询任务时发生错误:\\\", err) return } for _, task := range tasks { fmt.Println(\\\"到期的任务:\\\", task) // 删除任务 Rdb.ZRem(ctx, \\\"delay_queue\\\", task) fmt.Println(\\\"删除到期任务成功:\\\", task) } } } }\",\"使用 Redis 列表和 BRPOPLPUSH 命令也可以实现延迟队列。你可以将任务放入一个“延迟队列”列表中，定期从该列表中取出任务并处理。\",\"package main import ( \\\"context\\\" \\\"fmt\\\" \\\"github.com/go-redis/redis/v8\\\" \\\"strconv\\\" \\\"strings\\\" \\\"time\\\" ) func main() { rdb := redis.NewClient(&redis.Options{ Addr: \\\"localhost:6379\\\", DB: 0, }) ctx := context.Background() for { // 从延迟队列中阻塞地获取任务 task, err := rdb.BRPopLPush(ctx, \\\"delay_queue\\\", \\\"processing_queue\\\", 0).Result() if err != nil { fmt.Println(\\\"获取任务时发生错误:\\\", err) continue } // 处理任务 parts := strings.Split(task, \\\"|\\\") timestamp, job := parts[0], parts[1] execTime, err := strconv.ParseFloat(timestamp, 64) if err != nil { fmt.Println(\\\"解析时间戳时发生错误:\\\", err) continue } if time.Now().Unix() >= int64(execTime) { fmt.Println(\\\"处理任务:\\\", job) } else { // 如果任务未到期，将其放回延迟队列 rdb.LPush(ctx, \\\"delay_queue\\\", task) } // 从处理队列中移除任务 rdb.RPop(ctx, \\\"processing_queue\\\") } }\",\"有序集合 (ZSET)：适用于任务的执行时间可确定的情况，可以通过分数（时间戳）快速查询到期任务。优点是可以通过分数轻松查询到期任务，缺点是需要定期扫描集合。\",\"列表 (LIST)：适用于对任务执行时间要求不那么精确的情况。可以使用 BRPOPLPUSH 命令来阻塞等待任务，并处理到期任务。优点是可以阻塞等待任务，缺点是需要处理到期任务的复杂性和周期性扫描。\"]},\"128\":{\"h\":\"redis的事务\"},\"129\":{\"h\":\"Redis是否支持回滚操作\",\"t\":[\"Redis中并没有提供回滚机制，虽然有一个DISCARD命令，但是这个命令只能去主动放弃事务的执行，不会进行回滚操作。\",\"Redis提供事务支持，可以通过MULTI、EXEC、DISCARD、WATCH来实现\",\"MULTI：开始一个事务。Redis 会将后续的命令进入队列，直到执行 EXEC 或 DISCARD 命令为止。在 MULTI 之后的命令不会立即执行，而是被放入事务队列中。\",\"MULTI SET key1 \\\"value1\\\" SET key2 \\\"value2\\\" EXEC\",\"EXEC：执行事务中队列的所有命令。当执行 EXEC 时，所有的命令会按顺序执行。如果中有命令出现错误，Redis不回去对执行成功的命令进行回滚，也不会中止后续命令的执行。\",\"SET key1 \\\"value1\\\" # 这个命令将成功 INCR key2 # 如果 key2 不是整数，这个命令将失败 SET key3 \\\"value3\\\" # 这个命令仍然会执行 EXEC\",\"DISCARD：取消事务，清空事务队列，放弃在 MULTI 之后添加的所有命令。 \",\"在这个例子中，DISCARD 会清空事务队列，之前排队的 SET 命令不会执行。\",\"MULTI SET key1 \\\"value1\\\" SET key2 \\\"value2\\\" DISCARD\",\"WATCH 命令用于监视一个或多个键。当使用 WATCH 监视某个键时，如果在执行事务之前，该键被其他客户端修改了，那么当前事务将会被中止，EXEC 命令将返回 nil，表示事务失败。 \",\"在这个例子中，WATCH 命令监视 key1。如果在 EXEC 之前，key1 被其他客户端修改过，那么事务将失败，EXEC 会返回 nil，并且事务中的命令不会执行。\",\"WATCH key1 MULTI SET key1 \\\"new_value\\\" SET key2 \\\"value2\\\" EXEC\",\"注意\",\"Redis 事务中的“原子性”主要体现在事务中的命令要么全部执行，要么全部不执行的过程中不会被其他客户端插入命令。也就是说，当你执行 EXEC 时，Redis 确保所有命令在执行过程中不被其他命令打断，它们按顺序执行。\",\"并没有传统意义上的“全部成功或全部失败”的回滚机制，而是确保命令的执行顺序不会被外部破坏\",\"Redis支持管道（Pipeline），使用管道技术，客户端可以一次性将多条命令发送给 Redis 服务器，而不必等待每一条命令的执行结果。这意味着，客户端可以在一条网络连接中批量发送多个请求，减少了网络往返次数，从而显著提高通信效率。\",\"警告\",\"管道技术本质上是客户端提供的功能，而非Redis服务器端的功能\",\"package main import \\\"fmt\\\" func main() { //创建一个管道 pipe := Rdb.Pipeline() //在管道中添加多个命令 pipe.Set(ctx, \\\"key1\\\", \\\"value1\\\", 0) pipe.Set(ctx, \\\"key2\\\", \\\"value2\\\", 0) get1 := pipe.Get(ctx, \\\"key1\\\") get2 := pipe.Get(ctx, \\\"key2\\\") //执行管道中的命令 _, err := pipe.Exec(ctx) if err != nil { fmt.Println(\\\"执行管道命令时发生错误:\\\", err) return } // 获取结果 value1, err := get1.Result() if err != nil { fmt.Println(\\\"获取 key1 的值时发生错误:\\\", err) return } value2, err := get2.Result() if err != nil { fmt.Println(\\\"获取 key2 的值时发生错误:\\\", err) return } fmt.Println(\\\"key1 的值:\\\", value1) fmt.Println(\\\"key2 的值:\\\", value2) }\"]},\"130\":{\"h\":\"分布式锁\"},\"131\":{\"h\":\"使用Redis实现一个分布式锁\",\"t\":[\"package main import ( \\\"context\\\" \\\"fmt\\\" \\\"github.com/go-redis/redis/v8\\\" \\\"github.com/google/uuid\\\" \\\"time\\\" ) var ( Rdb *redis.Client ctx = context.Background() lockKey = \\\"my-lock-key\\\" ) func getRdb() { Rdb = redis.NewClient(&redis.Options{ Addr: \\\"8.130.17.124:6379\\\", Password: \\\"021001\\\", DB: 2, }) fmt.Println(\\\"Redis连接成功\\\") } func Close() { err := Rdb.Close() if err != nil { return } fmt.Println(\\\"Redis关闭成功\\\") } // 尝试去获取锁 func acquireLock() (bool, error) { // 生成唯一标识符作为锁的 value uniqueValue := uuid.New().String() // 使用 SETNX 命令尝试获取锁 result, err := Rdb.SetNX(ctx, lockKey, uniqueValue, 5*time.Second).Result() if err != nil { return false, err } return result, nil } // 释放锁,使用Lua脚本保证只有拥有锁的客户端能释放锁 func releaseLock() (bool, error) { // Lua脚本 script := ` if redis.call(\\\"GET\\\", KEYS[1]) == ARGV[1] then return redis.call(\\\"DEL\\\", KEYS[1]) else return 0 end` result, err := Rdb.Eval(ctx, script, []string{lockKey}, \\\"1\\\").Result() if err != nil { return false, err } return result.(int64) == 1, nil } func main() { getRdb() defer Close() locked, err := acquireLock() if err != nil { fmt.Println(err) return } if locked { fmt.Println(\\\"获取锁成功\\\") // 业务逻辑 time.Sleep(6 * time.Second) //释放锁 unlocked, err := releaseLock() if err != nil { fmt.Println(err) return } if unlocked { fmt.Println(\\\"锁已释放\\\") } else { fmt.Println(\\\"未能释放锁，锁可能已被其他客户端持有\\\") } } else { fmt.Println(\\\"获取锁失败,另一个进程持有锁\\\") } }\",\"在加锁的时候，应该保证这个锁的key值和value值的唯一性。这样可以在后面解除锁的时候，方便定位目标是否持有锁。\",\"重要\",\"在Redis集群下，可以使用Redlock（红锁）来保证分布式锁的可靠性。它是基于多个Redis节点的分布式锁，基本思路就是让客户端和多个Redis节点去申请锁，如果和超过半数以上的节点申请到锁，并且加锁时间没有超过锁的有效时间，就认为加锁成功\",\"加锁失败之后，或者锁的有效期不足以对共享数据进行保护就可以释放锁；过程就是客户端向所有的Redis节点发起释放锁的操作，释放锁的操作和单节点一样，执行Lua脚本即可\"]},\"132\":{\"h\":\"异步队列\"},\"133\":{\"h\":\"使用Redis实现一个异步队列\",\"t\":[\"Redis 异步队列是一种常用的方式，用于处理异步任务或消息传递。它通常基于 Redis 的 LIST 结构实现，结合生产者-消费者模式，可以实现高效的异步任务处理。\",\"生产者（Producer）：将任务或消息推送到队列中。\",\"消费者（Consumer）：从队列中弹出任务或消息并处理。\",\"队列（Queue）：在 Redis 中使用 LIST 作为队列，通常使用 LPUSH（从左侧插入）和 RPOP（从右侧弹出）来实现任务的先进先出（FIFO）顺序。\"]},\"134\":{\"h\":\"Redis 异步队列的实现\",\"t\":[\"生产者代码（Producer）\",\"生产者负责将任务放入队列中。你可以使用 LPUSH 命令将任务推送到 Redis 列表中。\",\"package main import ( \\\"context\\\" \\\"fmt\\\" \\\"github.com/go-redis/redis/v8\\\" ) func main() { rdb := redis.NewClient(&redis.Options{ Addr: \\\"localhost:6379\\\", DB: 0, }) ctx := context.Background() // 模拟任务数据 task := \\\"task1\\\" // 将任务放入队列 err := rdb.LPush(ctx, \\\"task_queue\\\", task).Err() if err != nil { fmt.Println(\\\"将任务放入队列时发生错误:\\\", err) } else { fmt.Println(\\\"成功将任务放入队列:\\\", task) } }\",\"消费者代码（Consumer）\",\"消费者负责从队列中获取任务并进行处理。可以使用 RPOP 命令从队列中弹出任务。\",\"package main import ( \\\"context\\\" \\\"fmt\\\" \\\"github.com/go-redis/redis/v8\\\" ) func main() { rdb := redis.NewClient(&redis.Options{ Addr: \\\"localhost:6379\\\", DB: 0, }) ctx := context.Background() for { // 从队列中弹出任务 task, err := rdb.RPop(ctx, \\\"task_queue\\\").Result() if err == redis.Nil { fmt.Println(\\\"队列中没有任务\\\") break } else if err != nil { fmt.Println(\\\"从队列中弹出任务时发生错误:\\\", err) continue } // 处理任务 fmt.Println(\\\"处理任务:\\\", task) // 这里可以加入任务处理逻辑 } }\",\"使用 BRPOP 实现阻塞式消费\",\"为了避免不断轮询队列，导致资源浪费，消费者可以使用 BRPOP 命令来实现阻塞式消费，即当队列中没有任务时，消费者会阻塞，直到有新的任务进入队列。\",\"package main import ( \\\"context\\\" \\\"fmt\\\" \\\"github.com/go-redis/redis/v8\\\" \\\"time\\\" ) func main() { rdb := redis.NewClient(&redis.Options{ Addr: \\\"localhost:6379\\\", DB: 0, }) ctx := context.Background() for { // 使用 BRPOP 实现阻塞式消费 task, err := rdb.BRPop(ctx, 0*time.Second, \\\"task_queue\\\").Result() if err != nil { fmt.Println(\\\"从队列中弹出任务时发生错误:\\\", err) continue } // 处理任务 fmt.Println(\\\"处理任务:\\\", task[1]) // 这里可以加入任务处理逻辑 } }\",\"任务异步处理：在任务量较大时，使用异步队列可以将任务放入队列中，由消费者逐一处理，避免阻塞主流程。\",\"消息队列：在微服务架构中，Redis 异步队列可以用作轻量级的消息队列，实现不同服务之间的解耦和异步通信。\",\"任务调度：可以将需要延迟处理的任务放入队列中，消费者按照一定顺序逐个处理。\",\"多消费者：可以启动多个消费者实例同时消费任务，提高任务处理能力。\",\"持久化：Redis 的数据持久化机制（RDB 或 AOF）可以确保队列中的任务在 Redis 重启后不会丢失。\",\"高可用：通过 Redis 的主从复制和哨兵机制，可以实现异步队列的高可用性。\",\"Redis 异步队列通过使用 LIST 结构和生产者-消费者模式，实现了高效的异步任务处理。在 Go 中，可以通过 LPUSH 和 RPOP（或 BRPOP）命令轻松实现生产者和消费者的逻辑，适用于任务异步处理、消息队列和任务调度等多种场景。\"]},\"135\":{\"h\":\"redis常用的数据类型\"},\"136\":{\"h\":\"\"},\"137\":{\"h\":\"1.string\"},\"138\":{\"h\":\"底层原理\",\"t\":[\"String：Key-Value，底层是int和SDS（简单的动态字符串）\",\"SDS相比于原生的C字符串L:\",\"SDS不仅可以保存文本数据，还可以保存二进制数据。因为 SDS 使用 len 属性的值而不是空字符判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。\",\"SDS 获取字符串长度的时间复杂度是 0(1)。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 0(n);而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 0(1)。\",\"Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出。因为 SDS 在拼接字符串之前会检查SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。\",\"字符串对象的内部编码 (encoding) 有3 种: int、raw和 embstr.\",\"embstr编码是专门用于保存短字符串的一种优化编码方式，row编码是用来存储长字符串的\",\"可以看到embstr和raw编码都会使用SDS来保存值，但不同之处在于embstr会通过一次内存分配函数来分配一块连续的内存空间来保存redisObject和SDS，而raw编码会通过调用两次内存分配函数来分别分配两块空间来保存redisObject和SDS。\",\"embstr 编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次\",\"释放embstr 编码的字符串对象同样只需要调用一次内存释放函数:\",\"因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用 CPU 缓存提升性能。\",\"但是 embstr 也有缺点的:\",\"如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，所以embsti编码的字符串对象实际上是只读的，redis没有为embstr编码的字符串对象编写任何相应的修改程序。当我们对embstr编码的字符串对象执行任何修改命令(例如append) 时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令\"]},\"139\":{\"h\":\"常用命令\",\"t\":[\"# 设置 key-value 类型的值 > SET name lin OK # 根据 key 获得对应的 value > GET name \\\"lin\\\" # 判断某个 key 是否存在 > EXISTS name (integer) 1 # 返回 key 所储存的字符串值的长度 > STRLEN name (integer) # 删除某个 key 对应的值 > DEL name (integer)1 # 批量设置 key-value 类型的值 > MSET key1 value1 key2 value2 OK # 批量获取多个 key 对应的 value > MGET key1 key2 1) \\\"value1\\\" 2) \\\"value2' # 设置 key-value 类型的值 > SET number 0 OK # 将 key 中储存的数字值增 > INCR number (integer)1 # 将key中存储的数字值加 10 > INCRBY number 10 (integer) 11 #将 key 中储存的数字值减1 > DECR number (integer) 10 # 将key中存储的数字值减 10 > DECRBY number 10 (integer) # 设置 key 在 60 秒后过期 (该方法是针对已经存在的key设置过期时间) > EXPIRE name 60 (integer)1 # 查看数据还有多久过期 > TTL name (integer)51 #设置 key-value 类型的值，并设置该key的过期时间为 60 秒 > SET key value EX 60 OK > SETEX key 60 value OK #不存在就插入 (not exists) > SETNX key value (integer)1\"]},\"140\":{\"h\":\"使用场景\",\"t\":[\"缓存，常规计数场景像访问次数、转发等\",\"分布式锁：SET 命令有个 NX 参数可以实现 [key不存在才插入]，可以用它来实现分布式锁\",\"SET lock_key unique_value NX PX 10000\",\"如果 key 不存在，则显示插入成功，可以用来表示加锁成功\",\"如果 key 存在，则会显示插入失败，可以用来表示加锁失败。\",\"SetNX加锁，可以设置一个过期时间。如果想要解除锁，就要把lock_key删除掉，在此之前需要判断这个客户端是不是加锁的那个。这就是两步，所以就可以使用lua脚本，在Resids中执行lua脚本是可以以原子性进行。\",\"共享session信息\"]},\"141\":{\"h\":\"2.List\"},\"142\":{\"h\":\"底层原理\",\"t\":[\"List 列表是简单的字符串列表，按照插入顺序排序，可以从头部或尾部向 List 列表添加元素，列表的最大长度为 2^32 - 1 ，也即每个列表支持超过 40 亿 个元素\",\"List 类型的底层数据结构是由双向链表或压缩列表实现的:\",\"如果列表的元素个数小于 512 个(默认值，可由 list-max-ziplist-entries 配置)，列表每个元素的值都小于 64 字节(默认值，可由 list-max-ziplist-value 配置)，Redis 会使用压缩列表作为List 类型的底层数据结构;\",\"如果列表的元素不满足上面的条件，Redis 会使用双向链表作为 List 类型的底层数据结构；\",\"但是在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表。\"]},\"143\":{\"h\":\"常用命令\",\"t\":[\"# 将一个或多个值value插入到key列表的表头(最左边),最后的值在最前面 LPUSH key value [value ...] # 将一个或多个值value插入到key列表的表尾(最右边) RPUSH key value [value ...] # 移除并返回key列表的头元素 LPOP key # 移除并返回key列表的尾元素 RPOP key # 返回列表key中指定区间内的元素,区间以偏移量start和stop指定,从0开始 LRANGE key start stop # 从key列表表头弹出一个元素,没有就阻塞timeout秒,如果timeout=0则一直阻塞 BLPOP key [key ...] timeout # 从key列表表尾弹出一个元素,没有就阻塞timeout秒,如果timeout=0则一直阻塞 BRPOP key [key ...] timeout\"]},\"144\":{\"h\":\"使用场景\",\"t\":[\"消息队列：消息保序、处理重复的消息和保证消息可靠性\",\"List本身就是先进先出的顺序对数据进行存取LPUSH + RPOP（左进右出），阻塞读取：使用 BRPOP；\",\"要实现处理重复消息，每一个消息都一个全局ID。消费者要记录已经处理过的消息ID，后续在收到消息的时候，将ID与已经处理的进行比较。List本身不会生成，需要我们自己生成然后插入List\",\"将读取的List进行备份，防止在处理过程中造成数据丢失,BRPOPLPUSH在每次读取的时候将元素加到另一个List\",\"缺点：不支持消费组的形式，因为在一个消费者读取之后list就被弹出来\"]},\"145\":{\"h\":\"3.Hash\"},\"146\":{\"h\":\"底层原理\",\"t\":[\"Hash 是一个键值对（key - value）集合，其中 value 的形式如：value=[{field1，value1}，...{fieldN，valueN}]。Hash 类型的底层数据结构是由压缩列表或哈希表实现的\",\"如果列表的元素个数小于 512 个(默认值，可由 list-max-ziplist-entries 配置)，列表每个元素的值都小于 64 字节(默认值，可由 list-max-ziplist-value 配置)，Redis 会使用压缩列表作为List 类型的底层数据结构\",\"如果不满足上面的情况，就会使用哈希表作为底层数据结构\",\"在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了\"]},\"147\":{\"h\":\"常用命令\",\"t\":[\"# 存储一个哈希表key的键值 HSET key field value # 获取哈希表key对应的field键值 HGET key field # 在一个哈希表key中存储多个键值对 HMSET key field value [field value...] # 批量获取哈希表key中多个field键值 HMGET key field [field ...] # 删除哈希表key中的field键值 HDEL key field [field ...] # 返回哈希表key中field的数量 HLEN key # 返回哈希表key中所有的键值 HGETALL key #为哈希表key中field键的值加上增量n HINCRBY key field n\"]},\"148\":{\"h\":\"使用场景\",\"t\":[\"缓存类型为（key，field，value），可以用来存储对象\",\"一般对象用 String + Json 存储，对象中某些频繁变化的属性可以考虑抽出来用 Hash 类型存储。\",\"购物车，key代表用户id，field代表商品id，value是数量\"]},\"149\":{\"h\":\"4.Set\"},\"150\":{\"h\":\"底层原理\",\"t\":[\"Set类型是一个无序并唯一的键值集合。\",\"Set的底层是哈希表或整数集合：\",\"在数据都是整数且小于512个使用整数集合\",\"不满足上面就是用哈希表\"]},\"151\":{\"h\":\"常用命令\",\"t\":[\"# 往集合key中存入元素，元素存在则忽略，若key不存在则新建 SADD key member [member ...] # 从集合key中删除元素 SREM key member [member ...] # 获取集合key中所有元素 SMEMBERS key # 获取集合key中的元素个数 SCARD key # 判断member元素是否存在于集合key中 SISMEMBER key member #从集合key中随机选出count个元素，元素不从key中删除 SRANDMEMBER key [count] # 从集合key中随机选出count个元素，元素从key中删除 spop key [count] # 交集运算 SINTER key [key ...] # 将交集结果存入新集合destination中 SINTERSTORE destination key [key...] # 并集运算 SUNION key [key] # 将并集结果存入新集合destination中 SUNIONSTORE destination key [key ...] # 差集运算 SDIFF key [key ...] # 将差集结果存入新集合destination中 SDIFFSTORE destination key [key ...]\"]},\"152\":{\"h\":\"使用场景\",\"t\":[\"Set的交、并、差集，计算复杂度较高，在数据量较大的时候，执行会导致redis阻塞（可以采用主从集群，在从库中计算返回数据给主库）。\",\"点赞，可以确保一个用户只能点一次\",\"计算两个之间的交集，可以用开计算共同关注的好友、公众号等。\",\"抽奖，可以确保一个用户在中奖之后就把它踢出\"]},\"153\":{\"h\":\"5.Zset\"},\"154\":{\"h\":\"底层原理\",\"t\":[\"比Set多另一个排序分值score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是排序值。\",\"Zset的底层实现是压缩列表或跳表：\",\"如果有序集合的元素个数小于 128个，并且每个元素的值小于 64 字节时，Redis 会使用压缩列表作为 Zset 类型的底层数据结构；\",\"如果有序集合的元素不满足上面的条件，Redis 会使用跳表作为 Zset 类型的底层数据结构;\",\"在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了\"]},\"155\":{\"h\":\"常用命令\",\"t\":[\"# 往有序集合key中加入带分值元素 ZADD key score member [[score member]...] # 往有序集合key中删除元素 ZREM key member [member ...] # 返回有序集合key中元素member的分值 ZSCORE key member # 返回有序集合key中元素个数 ZCARD key # 为有序集合key中元素member的分值加上increment ZINCRBY key increment member # 正序获取有序集合key从start下标到stop下标的元素 ZRANGE key start stop [WITHSCORES] # 倒序获取有序集合key从start下标到stop下标的元素 ZREVRANGE key start stop [WITHSCORES] # 返回有序集合中指定分数区间内的成员，分数由低到高排序 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] # 返回指定成员区间内的成员，按字典正序排列，分数必须相同。 ZRANGEBYLEX key min max [LIMIT offset count] # 返回指定成员区间内的成员，按字典倒序排列，分数必须相同 ZREVRANGEBYLEX key max min [LIMIT offset count] # 并集计算(相同元素分值相加) ZUNIONSTORE destkey numberkeys key [key...] # 交集计算(相同元素分值相加)，numberkeys代表有多少个集合，WEIGHTS 你可以为键指定权重最后分值会乘以你设置的权重 ZINTERSTORE destkey numberkeys key [key...]\"]},\"156\":{\"h\":\"使用场景\",\"t\":[\"排行榜，对电话姓名进行排序\"]},\"157\":{\"h\":\"6.BitMap\"},\"158\":{\"h\":\"底层原理\",\"t\":[\"用一串连续的二进制数组（用bit来进行0|1的设置），使用String 类型作为底层数据结构实现的一种统计二值状态的数据类型\"]},\"159\":{\"h\":\"常用命令\",\"t\":[\"# 设置值，其中value只能是0 和 1 SETBIT key offset value # 获取值 GETBIT key offset # 获取指定范围内值为 1 的个数 # start 和 end 以字节为单位 BITCOUNT key start end # BitMap间的运算 # operations 位移操作符，枚举值 # AND 与运算 & # OR 或运算 # XOR 异或^ # NOT 取反 # result 计算的结果，会存储在该key中 # keyl ... keyn 参与运算的key，可以有多个，空格分割，not运算只能一个key # 当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0。返回值# 是保存到 destket BITOp [operations] [result] [key1] [keyn...] # 返回指定key中第一次出现指定value(0/1)的位置 BITPOS [key] [valuel]\"]},\"160\":{\"h\":\"使用场景\",\"t\":[\"签到统计，可以找到首次打卡时间\",\"判断用户登录态，连续签到用户总数\"]},\"161\":{\"h\":\"redis是”单线程“\"},\"162\":{\"h\":\"redis是单线程的吗？\",\"t\":[\"Redis 单线程指的是[接收客户端请求→解析请求→进行数据读写等操作→发送数据给客户端] 这个过程是由一个线程 (主线程)来完成的\",\"Redis 程并不是单线程的，Redis 在启动的时候，是会启动后台线程 (BIO)\",\"Redis 在 2.6 版本，会启动 2 个后台线程，分别处理关闭文件、AOF 刷盘这两个任务;\",\"Redis 在 4.0 版本之后，新增了一个新的后台线程，用来异步释放 Redis 内存，也就是 lazyfree 线程\",\"关闭文件、AOF 刷盘、释放内存这三个任务都有各自的任务队列:\",\"BIO_CLOSE_FILE，关闭文件任务队列: 当队列有任务后，后台线程会调用 close(fd)，将文件关闭\",\"BIO_AOF_FSYNC，AOF刷盘任务队列: 当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到队列中。当发现队列有任务后，后台线程会调用 fsync(fd)，将 AOF 文件刷盘，\",\"BIO LAZY FREE，lazy free 任务队列: 当队列有任务后，后台线程会 free(obi) 释放对象/free(dict)删除数据库所有对象/free(skiplist) 释放跳表对象\"]},\"163\":{\"h\":\"Redis单线程还这么快\",\"t\":[\"Redis是基于内存的，大部分操作都在内存中完成\",\"Redis单线程模型避免多线程之间的竞争，也省去了多线程之间切换带来的时间和性能上的开销\",\"Redis采用I/O多路复用处理大量的客户端Socket请求\",\"Redis采用单线程的原因：CPU不是制约Redis性能表现的瓶颈，减少系统复杂度，同时不会存在在线程切换、加锁解锁、死锁的问题\",\"后面采用多线程的原因：网络硬件性能的提升，Redis的性能瓶颈也会出现在网络I/O上，索引在6.0之后Redis采用多线程，提升了Redis的I/O性能，默认还是一个线程处理命令但是也可以自己设置\"]},\"164\":{\"h\":\"持久化\"},\"165\":{\"h\":\"Redis持久化\",\"t\":[\"AOF 日志：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里 RDB 快照：将某一时刻的内存数据，以二进制的方式写入磁盘 混合持久化方式：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点\"]},\"166\":{\"h\":\"AOF\",\"t\":[\"先执行命令再写日志\",\"避免额外的检查开销：如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错.\",\"不会阻塞当前写操作命令的执行：因为当写操作命令执行成功后，才会将命令记录到 AOF 日志\",\"风险\",\"数据可能会丢失：执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。\",\"可能阻塞其他操作：因为 AOF 日志也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。\"]},\"167\":{\"h\":\"AOF的写回策略\",\"t\":[\"AOF日志不可以过大，不然在恢复数据的时候会很慢。\"]},\"168\":{\"h\":\"AOF重写机制\",\"t\":[\"如何避免：AOF重写机制，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到新的 AOF 文件，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件\"]},\"169\":{\"h\":\"重写过程\",\"t\":[\"后台子进程 bgrewriteaof 来完成的，两个好处：\",\"子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程\",\"子进程带有主进程的数据副本，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生【写时复制】，于是父子进程就有了独立的数据副本就不用加锁来保证数据安全。\",\"重写 AOF 日志过程中，如果主进程修改了已经存在 key-value 就会造成数据不一致问题，为了解决这种数据不一致问题，Redis 设置了一个 AOF 重写缓冲区，这个缓冲区在创建 bgrewriteaof子进程之后开始使用。\",\"在重写AOF 期间，当 Redis 执行完一个写命令之后，它会同时将这个写命令写入到 「AOF 缓冲区」和「AOF 重写缓冲区」。\",\"当子进程结束会向主进程发送一个信号，主程在接受之后会将「AOF 重写缓冲区」的内容追加到AOF文件中\"]},\"170\":{\"h\":\"RDB\",\"t\":[\"将某一时刻的内存数据，全部记录下来，再回复内存的时候只需要将RDB文件读入就可以\",\"Redis 提供了两个命令来生成RDB文件，分别是save和bgsave\",\"执行了save命令，就会在主线程生成RDB 文件，由于和执行操作命令在同一个线程，所以如果写入RDB 文件的时间太长，会阻塞主线程;\",\"执行了bqsave 命令，会创建一个子进程来生成 RDB 文件，这样可以避免主线程的阻塞\",\"在快照期间，数据库是可以进行修改的\"]},\"171\":{\"h\":\"混合持久化\",\"t\":[\"混合持久化工作在 AOF 日志重写过程，当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换日的的 AOF 文件。\",\"这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样加载的时候速度会很快。\",\"加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间主线程处理的操作命令，可以使得数据更少的丢失\",\"混合持久化缺点:\",\"AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差\",\"兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。\",\"AOF持久化大Key的影响：\",\"当使用 Always 策略的时候，如果写入是一个大 Key，主线程在执行 fsync()函数的时候，阻塞的时间会比较久\",\"当使用Everysec策略的时候，由于是异步执行 fsync() 函数，所以大 Key 持久化的过程(数据同步磁盘)不会影响主线程。\",\"当使用 No 策略的时候，由于永不执行 fsync()函数，所以大 Key 持久化的过程不会影响主线程\",\"RDB持久化大Key的影响：\",\"随着 Redis 存在越来越多的大 Key，那么 Redis 就会占用很多内存，对应的页表就会越大\",\"在通过 fork() 函数创建子进程的时候，虽然不会复制父进程的物理内存，但是内核会把父进程的页表复制一份给子进程，如果页表很大，那么这个复制过程是会很耗时的，那么在执行 fork 函数的时候就会发生阻塞现象\",\"如果创建完子进程后，父进程对共享内存中的大 Key 进行了修改，那么内核就会发生写时复制，会把物理内存复制一份，由于大 Key 占用的物理内存是比较大的，那么在复制物理内存这一过程中，也是比较耗时的，于是父进程(主线程)就会发生阻塞。\"]},\"172\":{\"h\":\"redis的主从复制\"},\"173\":{\"h\":\"主从复制\",\"t\":[\"主服务器上可以进行读写操作，当发生写操作时自动将写操作同步到从服务器，而从服务器一般是只读状态，并接受服务器同步过来写操作命令，然后执行\"]},\"174\":{\"h\":\"\",\"t\":[\"# 服务器执行 replicaof <服务器A的IP地址> <服务器A的Redis端口号>\",\"之后服务器B就会变成A的从\",\"第一阶段建立连接，同步协商\",\"从服务器向主服务器发送psync命令，包含主服务器的runID和复制进度offset\",\"runID，每个Redis服务器在启动的时候都会产生一个随机ID来标识自己。第一次同步的时候由于不知道主服务器的runID所以设置为“ ? ”\",\"offset,表示复制进度，第一次同步时，其值为-1\",\"主服务器在接收之后，会返回FULLRESYNC，带着两个参数主服务器runID和目前的复制进度offset，从服务器接收后会记录下来，\",\"FULLRESYNC命令意图时全量复制，也就是主服务器的所有数据全部同步到从服务器\",\"第二阶段是主服务器同步数据给从服务器\",\"主服务器用bgsave命令来异步生成RDB，然后发送给从服务器。\",\"从服务在接收之后会清空当前数据，然后载入RDB文件。\",\"为了保证数据一致性，主服务器会在下面三个时间段内的写操作，写入到replication buffer缓冲区里\",\"主服务器生成RDB期间\",\"主服务器发送RDB文件给从服务器期间\",\"从服务器加载RDB文件期间\",\"第三阶段是主服务器发送新的写操作命令给从服务器\",\"在从服务器完成RDB的载入之后，主服务器会将replication buffer内的操作命令发送给从服务器，从服务器执行命令完成数据一致\",\"之后双方会维持一个TCP长连接，后续主服务器通过这个连接实现命令传播，称之为基于长连接的命令传播\"]},\"175\":{\"h\":\"分摊压力\",\"t\":[\"为了避免从服务器过多，主服务器频繁生成子进程或者在大数据量的情况下发生阻塞，以及传输RDB占用服务器流量\",\"从库也可以有从库（从从库），然后可以将复制交给这个有从库的从库\",\"replicaof <目标服务器IP地址> 6379\"]},\"176\":{\"h\":\"增量复制\",\"t\":[\"在网络断开之后恢复，主从服务器会采用增量复制继续同步，就只是把网络断开期间主服务器接收到的写操作命令，同步给从服务器CONTINUE\",\"repl_backlog_buffer：是一个[环形] 缓冲区，用于主从服务器断连后，从中找到差异的数据\",\"replication offset：标记上面那个缓冲区的同步进度，主从服务器都有各自的偏移量，主服务器使用master_repl_offset来记录自己[写] 到的位置，从服务器使用slave repl offset来记录自己[读]到的位置。\",\"在主服务器进行命令传播时，不仅会将写命令发送给从服务器，还会将写命令写入到repl backlog bufer缓冲区里，因此这个缓冲区里会保存着最近传播的写命令\",\"网络断开后，在从服务器重新连接主服务器时，从服务器会通过 psync 命令将自己的复制偏移量slave repl offset发送给主服务器，主服务器根据自己的master repl offset和slave repl offset之间的差距，然后来决定对从服务器执行哪种同步操作:\",\"如果判断出从服务器要读取的数据还在repl backlog buffer缓冲区里，那么主服务器将采用增量同步的方式\",\"相反，如果判断出从服务器要读取的数据已经不存在repl backlog buffer缓冲区里，那么主服务器将采用全量同步的方式。\",\"当主服务器在repl backlog buffer中找到主从服务器差异(增量)的数据后，就会将增量的数据写入到replication buffer缓冲区\",\"为了避免在网络恢复时，服务器频繁的使用全量同步的方式，可以调整repl_backlog_buffer 缓冲区大小，尽可能的大一些减少出现从服务器要读取的数据被覆盖的概率，从而使得主服务器采用增量同步的方式\"]},\"177\":{\"h\":\"在主从库中如何确定对方还活着\",\"t\":[\"相互ping-pong心态检测，如果有一半以上的节点去ping一个节点没有pong回应，集群就会认为这个节点挂掉了，会断开与这个节点的连接\",\"Redis 主从节点发送的心态间隔是不一样的，而且作用也有一点区别：\",\"Redis 主节点默认每隔 10 秒对从节点发送ping命令，判断从节点的存活性和连接状态，可通过参数repl-ping-slave-period控制发送频率。\",\"Redis 从节点每隔1秒发送replconf ack{offset}命令，给主节点上报自身当前的复制偏移量，目的是为 \",\"实时监测主从节点网络状态\",\"上报自身复制偏移量，检查复制数据是否丢失，如果从节点数据丢失，再从主节点的复制缓冲区中拉取丢失数据\",\"过期一个Key，主库会模拟一个del命令\"]},\"178\":{\"h\":\"哨兵模式\",\"t\":[\"哨兵的作用\",\"实现主从节点故障转移，发现主节点挂掉之后，会将一个从节点切换为主节点，并把主节点的相关信息通知给从节点和客户端\"]},\"179\":{\"h\":\"\",\"t\":[\"哨兵会每隔一秒向从节点发送PING命令，如果主从节点在规定时间内没有回复，哨兵就会将他们标记为【主观下线】\",\"哨兵在部署的时候要用多个节点，使用哨兵集群的形式（至少要三台服务器），通过多个哨兵节点一起判断，就可以避免单个哨兵也因为自身网络状况，而误判的情况\",\"当哨兵判定主节点【主观下线】之后，会向其他哨兵发起命令，其他哨兵会根据自身和主节点的状态做出投票，当赞同数达到阈值之后，改主节点就会标记为**【客观下线】，然后哨兵就需要重新选择主节点**\"]},\"180\":{\"h\":\"\",\"t\":[\"哪个哨兵判断主节点【客观下线】，谁就是候选者\",\"候选者会向其他哨兵发送命令，表明希望成为 Leader 来执行主从切换\",\"每个哨兵只有一次投票机会，如果用完后就不能参与投票了，可以投给自己或投给别人，但是只有候选者才能把票投给自己。\",\"那么在投票过程中，任何一个[候选者] ，要满足两个条件：\",\"第一，拿到半数以上的赞成票\",\"第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值\",\"如果有两个候选者，先投给哪个就是哪个，谁先满足条件谁就是Leader\",\"quorum的值建议为哨兵个数的二分之一加1且为奇数\"]},\"181\":{\"h\":\"主\",\"t\":[\"主从故障转移操作包含以下四个步骤\",\"第一步：在已下线主节点(旧主节点)属下的所有[从节点]里面，挑选出一个从节点，并将其转换为主节点，哨兵发送SLAVEOF no one命令，然后一秒一次INFO观察角色信息，当从slave变为master转移完毕。\",\"先过滤掉网络状态不好的【判断断连次数】\",\"在进行每一轮考察的时候，哪个从节点优先胜出，就选择其作为新主节点。\",\"第一轮考察：哨兵首先会根据从节点的优先级来进行排序，优先级最高胜出\",\"第二轮考察：如果优先级相同，则查看复制的下标，哪个从[主节点] 接收的复制数据多，哪个就靠前，最靠前的胜出\",\"第三轮考察:如果优先级和下标都相同，就选择从节点 ID 较小的那个\",\"第二步：让已下线主节点属下的所有[从节点]修改复制目标，修改为复制[新主节点]\",\"哨兵向所有的从节点发送SLAVEOF命令<新主节点的IP和端口>，让他们成为新主节点的从节点\",\"第三步：将新主节点的IP地址和信息，通过[发布者/订阅者机制]通知给客户端\",\"主从切换完成后，哨兵就会向+switch-master 频道发布新主节点的IP地址和端口的消息，这个时候客户端就可以收到这条信息 通过发布者/订阅者机制机制，可以监控到主从节点切换过程中发生的各个重要事件。\",\"第四步：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点\"]},\"182\":{\"h\":\"如何组成哨兵集群\",\"t\":[\"哨兵节点之间是通过 Redis 的发布者/订阅者机制来相互发现的，配置好哨兵IP和端口之后，会发送到__sentinel__:hello频道，其他哨兵就会获取到，从而建立起哨兵集群\",\"之后，哨兵会向主节点发送INFO，主节点会将从节点列表发给哨兵，然后哨兵就可以和从节点链接了\"]},\"183\":{\"h\":\"redis的切片集群模式\"},\"184\":{\"h\":\"切片集群模式\",\"t\":[\"当Redis的缓存数据量大到一台服务器无法缓存时，就需要使用Redis切片集群（Redis Cluster），他将数据分布在不同的服务器上，以此来降低系统对于单主节点的依赖，从而提高Redis服务的读写性能\",\"Redis Cluster方案采用哈希槽（Hash Slot），来处理数据和节点之间的映射关系。在Redis Cluster方案中，一个切片集群共有16384个哈希槽。之后会根据Key来映射到对应的槽中\",\"根据键值对的 key，按照CRC16算法计算一个16 bit的值\",\"再用 16 bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。\",\"然后就是将槽映射到Redis上\",\"平均分配: 在使用cluster create 命令创建 Redis 集群时，Redis 会自动把所有哈希槽平均分布到集群节点上。比如集群中有 9 个节点，则每个节点上槽的个数为 16384/9 个。\",\"手动分配: 可以使用cluster meet 命令手动建立节点间的连接，组成集群，再使用 cluster addslots 命令，指定每个节点上的哈希槽个数。再手动分配的时候要将所有槽都分配完\"]},\"185\":{\"h\":\"脑裂现象\"},\"186\":{\"h\":\"集群脑裂，数据丢失\"},\"187\":{\"h\":\"现象\",\"t\":[\"主节点网络波动，哨兵认为主节点下线，就会重新选出新的主节点，但是在这个过程中客户端和主节点是联通的还在通信，当主节点重新连接时，哨兵就会自动将这个主节点设置为从节点，这个时候就会触发全量复制，原主节点就会把所有数据删除，然后复制新主节点的数据，造成在这个期间客户端和Redis的操作数据丢失\"]},\"188\":{\"h\":\"解决方法\",\"t\":[\"当主节点发现从节点挂掉大半，小于他的阈值的时候。或者在主从复制的时候延迟过高，主节点会限制写操作。\"]},\"189\":{\"h\":\"Redis过期删除\",\"t\":[\"当我们对Key设置过期时间，Redis就将这个Key和我们设置的过期时间保存到过期字典\",\"当我们查询一个Key的时候，就会先去查看字典中是否有：\",\"如果不在，就正常获取\",\"如果在，去找到这个key对应的过期时间和系统时间进行比较，没有过期就查询，过期删除\",\"Redis采用「惰性删除+定期删除」的策略\"]},\"190\":{\"h\":\"惰性删除\",\"t\":[\"不主动删除过期键，每次访问的时候，会去查询Key是否过期，如果过期删除\",\"优点 因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，情性删除策略对 CPU 友好\",\"缺点 如果一个 key 已经过期，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好\"]},\"191\":{\"h\":\"定期删除\",\"t\":[\"每隔一段时间[随机]从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。\",\"Redis 的定期删除的流程:\",\"从过期字典中随机抽取 20 个 key;\",\"检查这 20 个 key 是否过期，并删除已过期的 key;\",\"如果本轮检查的已过期 key 的数量，超过 5个(20/4)，也就是[已过期 key 的数量] 占比随机抽取 key 的数量] 大于 25%，则继续重复步 1; 如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。\",\"Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms。\",\"优点 通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。\",\"缺点 难以确定删除操作执行的时长和频率。如果执行的太频繁，就会对 CPU 不友好，如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。\"]},\"192\":{\"h\":\"定时删除\",\"t\":[\"定时删除策略的做法是，在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作。\",\"优点 可以保证过期 key 会被尽快删除，也就是内存可以被尽快地释放。因此，定时删除对内存是最友好的\",\"缺点 在过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间，在内存不紧张 CPU 时间紧张的情况下，将 CPU 时间用于删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。所以，定时删除策略对 CPU 不友好。\"]},\"193\":{\"h\":\"\",\"t\":[\"RDB文件有两个阶段，文件生成和文件加载阶段\",\"RDB 文件生成阶段：从内存状态持久化成 RDB (文件)的时候，会对 key 进行过期检查，过期的键[不会] 被保存到新的 RDB 文件中，因此 Redis 中的过期键不会对生成新 RDB 文件产生任何影响。\",\"RDB 加载阶段：RDB 加载阶段时，要看服务器是主服务器还是从服务器，分别对应以下两种情况: \",\"如果 Redis 是**[主服务器]运行模式的话，在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键[不会] 被载入到数据库**中。所以过期键不会对载入 RDB 文件的主服务器造成影响\",\"如果 Redis 是**[从服务器]运行模式的话，在载入 RDB 文件时，不论键是否过期都会被载入到数据库**中。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。所以一般来说，过期键对载入 RDB 文件的从服务器也不会造成影响。\",\"AOF 文件分为两个阶段，AOF 文件写入阶段和 AOF 重写阶段。\",\"AOF 文件写入阶段：当 Redis 以 AOF 模式持久化时，如果数据库某个过期键还没被除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会 AOF 文件追加一条 DEL 命令来显式地除该键值\",\"AOF 重写阶段：执行 AOF 重写时，会对 Redis 中的键值对进行检查，已过期的键不会被保存到重写后的 AOF 文件中，因此不会对 AOF 重写造成任何影响。\"]},\"194\":{\"h\":\"\",\"t\":[\"当 Redis 运行在主从模式下时，从库不会进行过期扫描，从库对过期的处理是被动的。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。\",\"从库的过期键处理依靠主服务器控制，主库在 key 到期时，会在 AOF 文里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指今来删除过期的 key。\"]},\"195\":{\"h\":\"CPU Cache\"},\"196\":{\"h\":\"cup cache\"},\"197\":{\"h\":\"如何写出让 CPU 跑得更快的代码？\"},\"198\":{\"h\":\"数据缓存\"},\"199\":{\"h\":\"指令缓存\"},\"200\":{\"h\":\"多核 CPU 的缓存命中率\"},\"201\":{\"h\":\"CUP是如何执行任务的?\"},\"202\":{\"h\":\"CPU如何执行任务的\"},\"203\":{\"h\":\"Cache 伪共享是什么？\"},\"204\":{\"h\":\"避免伪共享的方法\"},\"205\":{\"h\":\"CPU 是根据什么来选择当前要执行的线程。\"},\"206\":{\"h\":\"调度类\"},\"207\":{\"h\":\"完全公平调度\"},\"208\":{\"h\":\"CPU 运行队列\"},\"209\":{\"h\":\"调整优先级\"},\"210\":{\"h\":\"CUP的缓存一致性\"},\"211\":{\"h\":\"CPU Cache 的数据写入\"},\"212\":{\"h\":\"写直达\"},\"213\":{\"h\":\"写回\"},\"214\":{\"h\":\"缓存一致性问题\"},\"215\":{\"h\":\"总线嗅探\"},\"216\":{\"h\":\"MESI 协议\"},\"217\":{\"h\":\"什么是中断？\"},\"218\":{\"h\":\"中断\"},\"219\":{\"h\":\"软中断\"},\"220\":{\"h\":\"内存管理\"},\"221\":{\"h\":\"1. 虚拟内存\"},\"222\":{\"h\":\"问题背景\"},\"223\":{\"h\":\"基本概念\"},\"224\":{\"h\":\"1.1 内存分段\"},\"225\":{\"h\":\"内存碎片\"},\"226\":{\"h\":\"内存交换效率低\"},\"227\":{\"h\":\"1.2 内存分页\"},\"228\":{\"h\":\"简单分页（有缺陷）\"},\"229\":{\"h\":\"多级页表\"},\"230\":{\"h\":\"TLB\"},\"231\":{\"h\":\"1.3 段页式内存管理\"},\"232\":{\"h\":\"Linux内存布局\"},\"233\":{\"h\":\"内核空间与用户空间的区别\"},\"234\":{\"h\":\"虚拟内存的作用\"},\"235\":{\"h\":\"虚拟内存的功能\"},\"236\":{\"h\":\"虚拟内存管理器\"},\"237\":{\"h\":\"冯诺依曼模型\"},\"238\":{\"h\":\"内存：\"},\"239\":{\"h\":\"中央处理器：\"},\"240\":{\"h\":\"总线：\"},\"241\":{\"h\":\"输入、输出设备\"},\"242\":{\"h\":\"存储器的层次结构\"},\"243\":{\"h\":\"线程\"},\"244\":{\"h\":\"线程的优势\"},\"245\":{\"h\":\"理解线程\"},\"246\":{\"h\":\"线程与进程的比较\"},\"247\":{\"h\":\"线程的上下文切换\"},\"248\":{\"h\":\"线程的实现方式\"},\"249\":{\"h\":\"线程的优劣势\"},\"250\":{\"h\":\"计算机保存数据的形式\"},\"251\":{\"h\":\"用补码的形式保存负数\"},\"252\":{\"h\":\"十进制小数与二进制的转换\"},\"253\":{\"h\":\"计算机是怎么存小数的？\"},\"254\":{\"h\":\"。\"},\"255\":{\"h\":\"进程\"},\"256\":{\"h\":\"进程的状态：\"},\"257\":{\"h\":\"进程的控制结构：\"},\"258\":{\"h\":\"进程的控制\"},\"259\":{\"h\":\"进程的上下文切换\"},\"260\":{\"h\":\"泛型函数\",\"t\":[\"package main import ( \\\"encoding/json\\\" \\\"fmt\\\" ) type Number interface { int | uint | int64 | uint64 | float64 | float32 } func plus[T Number](n1, n2 T) T { return n1 + n2 } func myPrint[T int, K string | int](u1 T, u2 K) { } type response[T any] struct { Code int `json:\\\"code\\\"` Msg string `json:\\\"msg\\\"` Data T `json:\\\"data\\\"` } func main() { plus(1, 2) var u1, u2 = uint(2), uint(3) plus(u1, u2) type user1 struct { Name string `json:\\\"name\\\"` Age int `json:\\\"age\\\"` } type userInfo struct { Name string `json:\\\"name\\\"` Age int `json:\\\"age\\\"` Cord string `json:\\\"cord\\\"` } user := response{ Code: 0, Msg: \\\"Flipped\\\", Data: user1{ Name: \\\"Tom\\\", Age: 18, }, } body, err := json.Marshal(user) if err != nil { panic(err) } fmt.Println(string(body)) useInfo := response{ Code: 0, Msg: \\\"Flipped\\\", Data: userInfo{ Name: \\\"Tom\\\", Age: 18, Cord: \\\"北京\\\", }, } body1, err := json.Marshal(useInfo) if err != nil { panic(err) } fmt.Println(string(body1)) var useInfo response[userInfo] var user response[user1] json.Unmarshal([]byte(`{\\\"code\\\":0,\\\"msg\\\":\\\"Flipped\\\",\\\"data\\\":{\\\"name\\\":\\\"Tom\\\",\\\"age\\\":18}}`), &user) fmt.Println(user.Data.Age) _ = json.Unmarshal([]byte(`{\\\"code\\\":0,\\\"msg\\\":\\\"Flipped\\\",\\\"data\\\":{\\\"name\\\":\\\"Tom\\\",\\\"age\\\":18,\\\"cord\\\":\\\"北京\\\"}}`), &useInfo) fmt.Println(useInfo.Data.Name) //泛型切片 type MySlice[T int | string] []T var myslice = MySlice[int]{1, 2, 3} fmt.Println(myslice[0] + 1) // map的key只能是基本数据类型 type MyMap[T string, K any] map[T]K var mymap = MyMap[string, int]{ \\\"name\\\": 12, } fmt.Println(mymap) }\"]},\"261\":{\"h\":\"List\",\"t\":[\"# List # 定义 a=[] b=list() [1,2,3,45] # 在python中一个list可以保存多个数据类型不同的元素，元素甚至可以是列表 my_list=['it',12,True] print(my_list) print(type(my_list)) # 列表的下标可以反向索引最后一个数据下标为-1，往前依次是-2、-3、-4···· # 正向索引 print(my_list[0]) print(my_list[1]) print(my_list[2]) # 反向索引 print(my_list[-1]) print(my_list[-2]) print(my_list[-3]) # 从嵌套列表中选取数据 my_list = [[1,2,3],[4,5,6]] print(my_list[0][0]) print(my_list[0][1]) print(my_list[1][2]) # 用list的方法查询 my_list = [1, 2, 3, 4, 5, 6,] # 查询2在list中下标 index=my_list.index(2) # 修改特定下标的值 my_list[1]=\\\"程序猿\\\" print(my_list[1]) # 在指定的下标处插入某个元素 my_list.insert(1,\\\"it\\\") print(my_list) # 追加元素 my_list.append(\\\"尼豪\\\") print(my_list) # 追加一堆元素，其他的list my_list2=[7,8,9] my_list.extend(my_list2) print(my_list) # 删除list中元素 del my_list2[2] print(my_list2) # 下标1的元素提取出来并返回 num=my_list2.pop(1) print(my_list2,num) # 删除在例表中第一个匹配的值 my_list.remove(\\\"it\\\") print(my_list) # 清空列表 # my_list.clear() # 统计某元素在列表中的数量 num2=my_list.count(\\\"程序猿\\\") print(num2) # 例表的长度 len(my_list) # 使用While遍历list def While_list (): my_list = [1,2,3,4,5] index = 0 while index<len(my_list): print(my_list[index]) index += 1 While_list() # 使用for遍历list def for_list(): my_list = [1,2,3,4,5] for i in my_list: print(i) for_list()\"]},\"262\":{\"h\":\"while和for\",\"t\":[\"age=input(\\\"请输入你的年龄\\\") print(\\\"你的年龄是%s\\\" % age) # input语句会将所有输入的数据当成字符串，如果需要自行转换类型 # age=input(\\\"请输入你的年龄\\\") print(\\\"你的年龄是%s\\\" % age) age=int(age) if age < 18 : print(\\\"未成年\\\") else: print(\\\"成年\\\") # tall=int(input(\\\"请输入你的身高\\\")) vip=int(input(\\\"请输入你的VIP等级\\\")) if tall<120: print(\\\"你可以不买票\\\") elif vip>3: print(\\\"您快去\\\") else: print(\\\"去买票\\\") # 1-10内的随机数 num=random.randint(1,10) print(num) # while循环 i=0 while i<10: print(\\\"第%s次循环\\\" % i) i+=1 # 99乘法表 i=0 while i<=9: j=1 while j<=i: print(f\\\"{j} * {i} = {j*i}\\\\t\\\",end=\\\" \\\") j+=1 i+=1 print() #for循环 name=\\\"Flipped1001\\\" for i in name: print(i,end=\\\"\\\") const=0 name=\\\"itheima is a brand of itcast\\\" for i in name: if i == 'a' : const=const+1 print(const) # range(num1,num2,step):获取一个从num1到num2步长为step的数字序列(不会包含num2) for i in range(1,18,2) print(i) num=101 count=0 for i in range(1,num): if i %2 ==0: count+=1 print(f\\\"在0到{num-1}内有{count}个偶数\\\") # 使用for循环99乘法表 for i in range(1,10): for j in range(1,i+1): print(f\\\"{j} * {i} = {j*i}\\\\t\\\",end=\\\" \\\") print() # continue 跳过本次循环 # 直接结束所在循环\"]},\"263\":{\"h\":\"元组\",\"t\":[\"# 元组(tupel 一旦完成封装就不可以被修改) # 元组也可以嵌套，即元组中元素也可以是元组，元组也可以包含不同的数据类型 # 定义 (1,2,3,4,5) a=(1,2,3,4,5) b=() c=tuple() # 定义单个元组的时候后面必须写上','不然系统会默认你写的是string类型 t = (\\\"ni\\\",) # 由于元组不可修改，所以只有index,len,count # 用while遍历元组 index=0 while index<len(t1): print(t1[index]) index+=1 # 用for遍历 for i in t1: print(i) # 元组不可修改，但元组中的list可以修改 t2 = (1, 2, 3, [4, 5, 6]) t2[3][0] = \\\"it\\\" print(t2)\"]},\"264\":{\"h\":\"函数\",\"t\":[\"# 函数 str1=\\\"hsdhaui\\\" str2=\\\"nmksadsi\\\" str3=\\\"dnsajknd\\\" def my_len (data): # 可以给函数加一个说明文档，方便后续应用 \\\"\\\"\\\" 函数说明 :param data:形参 :return:data的长度 \\\"\\\"\\\" count = 0 for i in data: count += 1 return count num1=my_len(str1) num2=my_len(str2) num3=my_len(str3) print(num1,num2,num3) # 无return会返回一个None值，None在if中使false name = None ## # 在函数外面定义的是全局变量 num = 100 #在函数内部定义的是局部变量 def test_a(): #使用global关键字，可以将函数内部的变量成为全局变量 global num num = 500 test_a() print(num) # 函数的传参 def user_info (name,age,gender): print(\\\"Hello {}!, age {} gender {} \\\".format(name,age,gender)) user_info(\\\"小明\\\",20,\\\"女\\\") user_info(name=\\\"小明\\\",age=20,gender=\\\"女\\\") user_info(name=\\\"萧峰\\\",gender=\\\"男\\\",age=30) user_info(\\\"天天\\\",age=20,gender=\\\"男\\\") #设置默认值的时候，必须是设置在最后 def user_info (name,age,gender='沃尔玛购物袋'): print(\\\"Hello {}!, age {} gender {} \\\".format(name,age,gender)) user_info(\\\"枫枫\\\",20) user_info(\\\"正\\\",age=20,gender=\\\"男\\\") # 位置不定长,接受不定长的数据,参数形成一个元组 def user_info(*args): print(type(args),args) user_info(\\\"dasij\\\",132,\\\"dbau \\\") # 关键字不定长，参数必须是kv形式的,参数以字典的形式存在 def user_info(**kwargs): print(kwargs) user_info(name=\\\"dias\\\",age=20) # 匿名函数 def test_func(compute): result=compute(1,2) print(result) print(type(compute)) print(type(result)) def compute(x,y): return x+y test_func(compute) # 关键字lambda(不接受的话就是一个临时函数，不可以写多行数据) # lambda 参入参数: 函数体(一行代码) def test_func(compute): print(compute(1,2)) test_func(lambda x,y:x+y)\"]},\"265\":{\"h\":\"字典\",\"t\":[\"# 字典dict \\\"\\\"\\\" 1.键值对的Key和Value可以是任意类型(Key不可为字典) 2.字典内Key不允许重复，重复添加等同于覆盖原有数据 \\\"\\\"\\\" # 定义字典(dict) map = {\\\"王力宏\\\": 99, \\\"周小阶\\\": 88, \\\"高\\\": 77} map1 = {} map2 = dict() print(map) print(type(map1)) # 用key获取value value = map[\\\"王力宏\\\"] print(value) # 定义嵌套字典 stud_score = { \\\"王力宏\\\": { \\\"数学\\\": 99, \\\"语文\\\": 88, \\\"外语\\\": 99, }, \\\"小周\\\": { \\\"数学\\\": 66, \\\"语文\\\": 98, \\\"外语\\\": 77, } } score = stud_score[\\\"小周\\\"][\\\"语文\\\"] print(score) my_dict = {\\\"周杰轮\\\": 99, \\\"林俊节\\\": 88, \\\"张学油\\\": 77} # 新增元素 my_dict[\\\"张信哲\\\"] = 66 print(f\\\"字典经过新增元素后，结果: {my_dict}\\\") # 更新元素 my_dict[\\\"周杰轮\\\"] = 33 print(f\\\"字典经过更新后，结果: {my_dict}\\\") # 删除元素 value=my_dict.pop(\\\"周杰轮\\\") print(my_dict) print(value) # 清空元素 # my_dict.clear() # 获取全部的key,遍历 value=my_dict.keys() print(value) # 跟据keys for key in value: print(my_dict[key]) # 直接for for key in my_dict: print(my_dict[key]) len(my_dict)\",\"数据容器可以从以下视角进行简单的分类:\",\"是否支持下标索引 \",\"支持：列表、元组、字符串 - 序列类型\",\"不支持：集合、字典- 非序列类型\",\"是否支持重复元素 \",\"支持：列表、元组、字符串 序列类型\",\"不支持：集合、字典- 非序列类型\",\"是否可以修改 \",\"支持：列表、集合、字典\",\"不支持：元组、字符串\",\"类型转换：\",\"支持所有容器转为list，tuple，set，使用list[]，tuple(),set{}。但是字典,元组转换时，元素为key没有保留value；字符串转换的时候元素为 ‘ 字符 ’\",\"支持所有容器转为str，使用str()。都会转为字符串，字典在转换过程中value保留\",\"sorted给数据容器排序，sorted(序列，[renerse=True]),true降序，默认升序\"]},\"266\":{\"h\":\"字符串\",\"t\":[\"# 字符串 # 字符串可以看成是一个存放字符的数据容器，无法修改 my_str=\\\"Flipped string\\\" # 通过下标索引取值 value=my_str[2] print(value) # 字符串Index value2=my_str.index(\\\"F\\\") print(value2) # 字符串的替换replace,获取一个新的字符串 value3=my_str.replace(\\\"string\\\",\\\"title\\\") print(value3) # spilt分割字符串 my_list=\\\"python flipped studey\\\" value4=my_list.split(\\\" \\\") print(value4) # strip去除前后的空格 my_str=\\\" ni hao \\\" value5=my_str.strip() # 不传入参数，去除前后空格 print(value5) value6=my_str.strip(\\\" ni\\\")# 去除前后指定字符 print(value6) # count len value=my_str.count(\\\"a\\\") value2= len(my_str) print(value) print(value2)\"]},\"267\":{\"h\":\"序列的切片\",\"t\":[\"# 序列的切片(list,tuple,str) # 对list进行切片，从1开始，4结束，步长1 my_list = [0, 1, 2, 3, 4, 5, 6] result1 = my_list[1:4] # 步长默认是1，所以可以省略不写 print(f\\\"结果1: {result1}\\\") # tuple进行切片，从头开始，到最后结束，步长1 my_tuple = (0, 1, 2, 3, 4, 5, 6) result2 = my_tuple[:] # 起始和结束不写表示从头到尾，步长为1可以省略 print(f\\\"结果2: {result2}\\\") # 对str进行切片，从头开始，到最后结束，步长2 my_str = \\\"01234567\\\" result3 = my_str[::2] print(f\\\"结果3: {result3}\\\") # 对str进行切片，从头开始，到最后结束，步长-1 my_str = \\\"01234567\\\" result4 = my_str[::-1] print(f\\\"结果4: {result4}\\\") # 等同于将序列反转了 # 对列表进行切片，从3开始，到结束，步长-1 my_list = [0, 1, 2, 4, 5, 6] result5 = my_list[3:1:-1] print(f\\\"结果5: {result5}\\\") # 对元组进行切片，从头开始，到尾结束，步长-2 my_tuple = (0, 1, 2, 3, 4, 5, 6) result6 = my_tuple[::-2] print(f\\\"结果6: {result6}\\\")\"]},\"268\":{\"h\":\"python的数据类型\",\"t\":[\"类型\",\"描述\",\"说明\",\"数字(Number)\",\"整数(int)浮点数(float)复数(complex)布尔(bool)\",\"整数(int),如:10、-10浮点数(float),如:13.14、-13.14复数(complex)，如:4+3j，以j结尾表示复数布尔(bool)表达现实生活中的逻辑,即真和假,True表示真,False表示假。True本质上是一个数字记作1,False记作0\",\"字符串(String)\",\"描述文本的一种数据类型\",\"字符串(string)由任意数量的字符组成\",\"列表(List)\",\"有序的可变序列\",\"Python中使用最频繁的数据类型,可有序记录一堆数据\",\"元组(Tuple)\",\"有序的不可变序列\",\"可有序记录一堆不可变的Python数据集合\",\"集合(Set)\",\"无序不重复集合\",\"可无序记录一堆不重复的Python数据集合\",\"字典(Dictionary)\",\"无序Key-Value集合\",\"可无序记录一堆Key-Value型的Python数据集合\",\"type（数据） 查看数据的类型,也可以查看变量的数据类型\",\"print(type(\\\"字符串\\\")) # 输出 <class 'str'> # 数据类型转换 a=str(11) # 只有双引号里都是数字才可以转为int类型 b=int(\\\"123\\\") c=float(\\\"1.2\\\") print(type(a)) print(type(b)) print(type(c)) <class 'str'> <class 'int'> <class 'float'>\",\"标识符命名规则 - 内容限定\",\"标识符命名中，只允许出现：\",\"英文\",\"中文\",\"数字\",\"下划线(_)\",\"这四类元素。\",\"其余任何内容都不被允许。\",\"大小写敏感\",\"不可使用关键字\",\"运算符\",\"描述\",\"实例\",\"+\",\"两个对象相加a+b 输出结果 30\",\"-\",\"得到负数或是一个数减去另一个数a-b输出结果-10\",\"*\",\"两个数相乘或是返回一个被重复若干次的字符串a*b输出结果200\",\"/\",\"b /a 输出结果 2\",\"//\",\"取整除\",\"返回商的整数部分9//2输出结果 4,9.0//2.0 输出结果 4.0\",\"%\",\"取余\",\"返回除法的余数b%a 输出结果0\",\"**\",\"指数\",\"a ** b为10的20次方,输出结果 100000000000000000000\",\"# 算术(数学)运算符 print(\\\"1 +1=\\\",1+1) print(\\\"2 - 1 =\\\", 2 -1) print(\\\"3 * 3=\\\", 3*3) print(\\\"4 / 2 = \\\", 4 / 2) print(\\\"11 // 2=\\\", 11 // 2) print(\\\"9 % 2 = \\\", 9 % 2) print(\\\"2 ** 2 =\\\", 2 ** 2) #复合运算符 num = 1 num += 1 # num = num + 1 print(\\\"num += 1: \\\", num) num -= 1 print(\\\"num -= 1: \\\", num) num *= 4 print(\\\"num *= 4: \\\", num) num /= 2 print(\\\"num /= 2: \\\", num) num = 3 num %= 2 print(\\\"num %= 2: \\\", num) num **= 2 print(\\\"num **= 2: \\\", num) num = 9 num //= 2 print(\\\"num //= 2:\\\", num)\",\"字符串\",\"print(type(name)) # 单引号定义法,使用单引号进行包围 name ='黑马程序员’ print(type(name)) # 双引号定义法 name =\\\"黑马程序员” print(type(name)) # 三引号定义法,写法和多行注释是一样的 name = \\\"\\\"\\\"字符串\\\"\\\"\\\" print(type(name)) # 在字符串内 包含双引号 name ='\\\"黑马程序员”' print(name) # 在字符串内 包含单引号 name =\\\"'黑马程序员'\\\" print(name) # 使用转义字符 \\\\ 解除引号的效用 name =\\\"\\\\\\\"黑马程序员\\\\\\\"\\\" print (name) name='\\\\'黑马程序员\\\\'' print(name) # %s 一个字符串类型的占位符 name=\\\"这是一个%s\\\" % \\\"字符串\\\" print(name) \\\"\\\"\\\" %s 一个字符串类型的占位符 %d 一个整数类型的占位符 %f 一个浮点数类型的占位符 \\\"\\\"\\\" name=\\\"这是一个%s，这是一个%d，这是一个%f\\\" % (\\\"字符串\\\",12,12) print(name)\",\"字符串格式化-数字精度控制\",\"我们可以使用辅助符号\\\"m.n”来控制数据的宽度和精度\",\"m，控制宽度,要求是数字(很少使用)，设置的宽度小于数字自身，不生效\",\".n，控制小数点精度,要求是数字，会进行小数的四舍五入\",\"示例：\",\"%5d：表示将整数的宽度控制在5位,如数字11，被设置为5d,就会变成： 11，用三个空格补足\",\"宽度。\",\"%5.2f：表示将宽度控制为5,将小数点精度设置为2\",\"小数点和小数部分也算入宽度计算。如，对11.345设置了%7.2f后,结果是： 11.35。2个空格补足宽度,小数部分限制2位精度后,四舍五入为.35\",\"num1 = 11 num2 = 11.345 print(\\\"数字11宽度限制5,结果是:%5d\\\"% num1) print(\\\"数字11宽度限制1,结果是:%1d\\\"% num1) print(\\\"数字11.345宽度限制7,小数精度2,结果是:%7.2f\\\"% num2) print(\\\"数字11.345不限制,小数精度2,结果是:%.2f\\\"% num2) name =\\\"程序猿\\\" set_up_year = 2006 stock_price = 19.99 # f: format print(f\\\"我是{name},我成立于:{set_up_year}年,我今天的股价是:{stock_price}\\\") name=\\\"cheng\\\" stock_price=100 stock_code= \\\"003032\\\" stock_growth=1.2 growth_day=7 finally_stock_price=stock_price*stock_growth**growth_day print(f\\\"公司{name},股票代码{stock_code}，当前股价{stock_price}，每日增长系数{stock_growth},经过{growth_day},股价达到{finally_stock_price}\\\")\",\"age=input(\\\"请输入你的年龄\\\") print(\\\"你的年龄是%s\\\" % age) # input语句会将所有输入的数据当成字符串，如果需要自行转换类型 # age=input(\\\"请输入你的年龄\\\") print(\\\"你的年龄是%s\\\" % age) age=int(age) if age < 18 : print(\\\"未成年\\\") else: print(\\\"成年\\\") # tall=int(input(\\\"请输入你的身高\\\")) vip=int(input(\\\"请输入你的VIP等级\\\")) if tall<120: print(\\\"你可以不买票\\\") elif vip>3: print(\\\"您快去\\\") else: print(\\\"去买票\\\") # 1-10内的随机数 num=random.randint(1,10) print(num) # while循环 i=0 while i<10: print(\\\"第%s次循环\\\" % i) i+=1 # 99乘法表 i=0 while i<=9: j=1 while j<=i: print(f\\\"{j} * {i} = {j*i}\\\\t\\\",end=\\\" \\\") j+=1 i+=1 print() #for循环 name=\\\"Flipped1001\\\" for i in name: print(i,end=\\\"\\\") const=0 name=\\\"itheima is a brand of itcast\\\" for i in name: if i == 'a' : const=const+1 print(const) # range(num1,num2,step):获取一个从num1到num2步长为step的数字序列(不会包含num2) for i in range(1,18,2) print(i) num=101 count=0 for i in range(1,num): if i %2 ==0: count+=1 print(f\\\"在0到{num-1}内有{count}个偶数\\\") # 使用for循环99乘法表 for i in range(1,10): for j in range(1,i+1): print(f\\\"{j} * {i} = {j*i}\\\\t\\\",end=\\\" \\\") print() # continue 跳过本次循环 # 直接结束所在循环\"]},\"269\":{\"h\":\"文件操作\",\"t\":[\"\\\"\\\"\\\" open(name,model,encoding) name: 文件名 model: 设置打开文件的模式：r 只读 w 写入 （原来的数据删除,不存在就创建） a 追加（在原有的内容该后面追加，不存在就创建） encoding:编码格式（一般推荐UTF-8） \\\"\\\"\\\" f = open(\\\"文件名\\\",\\\"r\\\",encoding=\\\"utf-8\\\") # read()参入参数表示传入多少字节，不传参表示默认读取全部 f.read(10) # 多次调用read，第二个read将会从第一个read后面继续查询（因为有一个指针） f.read() # 读取文件的全部行，封装到列表中，在执行的时候要把上面的读取注释掉，不然在完全读取之后，指针到了最后，在查就没有数据了 lines=f.readlines() # 一次读取一行 f.readline() # 用for循环读取每一行 for line in f: print(line) # 关闭 f.close() # with open可以在执行之后自动对调用文件进行一个关闭 with open(\\\"文件名\\\",\\\"r\\\",encoding=\\\"utf-8\\\") as f: for line in f: print(line) f = open(\\\"文件名\\\",\\\"w\\\",encoding=\\\"utf-8\\\") # 写入数据 f.write(\\\"hello world\\\") # flush刷新，把数据刷到硬盘里 f.flush() # close (内置了flush函数) f.close() # 追加写入,在已有文件后面追加写 f = open(\\\"文件名\\\",\\\"a\\\",encoding=\\\"utf-8\\\") f.write(\\\"hello world\\\") f.close()\"]},\"270\":{\"h\":\"集合\",\"t\":[\"# 集合Set 自带去重操作 \\\"\\\"\\\" 1.可以容纳多个数据 2.可以容纳不同类型的数据 (混装) 3.数据是无序存储的 (不支持下标索引) 4.不允许重复数据存在(自带去重) 5.可以修改 (增加或删除元素等) 6.支持for循环 \\\"\\\"\\\" # 集合的定义 my_set = {1, 2, 2, 3, 4, 5, 6} {1, 2, 3, 4, 5, 6} setn = set() # 添加新元素 my_set.add(\\\"sha\\\") print(my_set) # 移除元素remove my_set.remove(2) print(my_set) # 随机提取出元素 value=my_set.pop() print(value) # 清空集合 my_set.clear() # 提取两个集合的差集(集合1有集合2没有的元素) set1={1,2,3} set2={4,5,6} set3=set1.difference(set2) print(set3) # 消除两个集合的差集(在集合1里面删除与集合2相同的元素,集合2不变化) set1={1,2,3,5} set2={4,5,6} set1.difference_update(set2) print(set1) # 合并两个集合 set3=set1.union(set2) print(set3) # 集合的长度len l= len(set1) print(l) # 遍历集合，不支持下标索引，只能用for遍历 set1={1,2,3,4,5,6} for i in set1: print(i)\"]},\"271\":{\"h\":\"HTTP\"},\"272\":{\"h\":\"HTTP基本概念\"},\"273\":{\"h\":\"HTTP是什么？\"},\"274\":{\"h\":\"HTTP常见的状态码：\"},\"275\":{\"h\":\"HTTP常见字段有哪些：\"},\"276\":{\"h\":\"GET与POST请求:\"},\"277\":{\"h\":\"GET与POST的区别:\"},\"278\":{\"h\":\"GET和POST的方法都是安全和幂等的吗？\"},\"279\":{\"h\":\"HTTP缓存技术\"},\"280\":{\"h\":\"强缓存：\"},\"281\":{\"h\":\"协商缓存：\"},\"282\":{\"h\":\"HTTP特性：\"},\"283\":{\"h\":\"HTTP的更迭\"},\"284\":{\"h\":\"1.如何避免发送HTTP请求\"},\"285\":{\"h\":\"2.如何减少HTTP请求次数\"},\"286\":{\"h\":\"3.如何减少HTTP响应的数据大小？\"},\"287\":{\"h\":\"1.HTTP的性能问题\"},\"288\":{\"h\":\"2.兼容HTTP1.1\"},\"289\":{\"h\":\"3.头部压缩\"},\"290\":{\"h\":\"静态表编码\"},\"291\":{\"h\":\"动态编码表\"},\"292\":{\"h\":\"4.二进制帧\"},\"293\":{\"h\":\"5.并发传输\"},\"294\":{\"h\":\"6.服务器主动推送资源\"},\"295\":{\"h\":\"1.HTTP2的问题\"},\"296\":{\"h\":\"1.队头阻塞：\"},\"297\":{\"h\":\"2.TCP与TLS的握手延迟\"},\"298\":{\"h\":\"3.网络迁移需要重新连接\"},\"299\":{\"h\":\"2.QUIC协议的特点\"},\"300\":{\"h\":\"1.无队头阻塞\"},\"301\":{\"h\":\"2.更快连接建立\"},\"302\":{\"h\":\"3.连接迁移\"},\"303\":{\"h\":\"3.HTTP3协议\"},\"304\":{\"h\":\"HTTPS如何优化\"},\"305\":{\"h\":\"1.分析性能损耗\"},\"306\":{\"h\":\"硬件优化\"},\"307\":{\"h\":\"软件优化\"},\"308\":{\"h\":\"证书优化\"},\"309\":{\"h\":\"会话复用\"},\"310\":{\"h\":\"\"},\"311\":{\"h\":\"HTTP和HTTPS的区别\"},\"312\":{\"h\":\"HTTP和HTTPS：\"},\"313\":{\"h\":\"1.HTTP和HTTPS的区别：\"},\"314\":{\"h\":\"2.HTTPS解决了HTTP的那些问题?\"},\"315\":{\"h\":\"如何解决的?\"},\"316\":{\"h\":\"3.HTTPS是如何建立连接的,期间交互了什么?\"},\"317\":{\"h\":\"4.HTTPS的应用数据时如保证完整性的\"},\"318\":{\"h\":\"应用层的协议\"},\"319\":{\"h\":\"TCP 是有三个特点， 、 、基于 。\"},\"320\":{\"h\":\"1.HTTP和RPC的区别\"},\"321\":{\"h\":\"2.WebSocket是什么\"},\"322\":{\"h\":\"IP协议的相关技术\"},\"323\":{\"h\":\"APR\"},\"324\":{\"h\":\"DHCP\"},\"325\":{\"h\":\"NAT\"},\"326\":{\"h\":\"ICMP\"},\"327\":{\"h\":\"ping的工作原理\"},\"328\":{\"h\":\"ping的工作原理\"},\"329\":{\"h\":\"查询报文类型\"},\"330\":{\"h\":\"traceroute :\"},\"331\":{\"h\":\"断网了还能ping通127.0.0.1吗？\"},\"332\":{\"h\":\"什么是127.0.0.1\"},\"333\":{\"h\":\"TCP和Ping数据的区别：\"},\"334\":{\"h\":\"为什么断网了还能ping通127.0.0.1？\"},\"335\":{\"h\":\"127.0.0.1和localhost和0.0.00有什么区别？\"},\"336\":{\"h\":\"基础IP\"},\"337\":{\"h\":\"IP基本认识\"},\"338\":{\"h\":\"IP的基础知识\"},\"339\":{\"h\":\"IP的分类：\"},\"340\":{\"h\":\"什么是A，B，C类？\"},\"341\":{\"h\":\"什么是D类，E类？\"},\"342\":{\"h\":\"无分类地址CIDR\"},\"343\":{\"h\":\"公有 IP 地址与私有 IP 地址\"},\"344\":{\"h\":\"IP 地址与路由控制\"},\"345\":{\"h\":\"IP分片与重组\"},\"346\":{\"h\":\"IPv6 基本认识\"},\"347\":{\"h\":\"IPv6的首部改进：\"},\"348\":{\"h\":\"CLOSE_WAIT和TIME_WAIT\"},\"349\":{\"h\":\"为什么 TIME_WAIT 等待的时间是 2MSL？\"},\"350\":{\"h\":\"为什么需要 TIME_WAIT 状态？\"},\"351\":{\"h\":\"TIME_WAIT 过多有什么危害？\"},\"352\":{\"h\":\"如何优化 TIME_WAIT？\"},\"353\":{\"h\":\"服务器出现大量 TIME_WAIT 状态的原因有哪些？\"},\"354\":{\"h\":\"服务器出现大量 CLOSE_WAIT 状态的原因有哪些？\"},\"355\":{\"h\":\"SYN延时和泛洪攻击\"},\"356\":{\"h\":\"什么是SYN攻击，如何避免SYN攻击？\"},\"357\":{\"h\":\"什么时SYN超时，如何解决SYN超时？\"},\"358\":{\"h\":\"TCP和UDP的区别\"},\"359\":{\"h\":\"UDP和TCP的区别和应用场景：\"},\"360\":{\"h\":\"TCP和UDP的区别：\"},\"361\":{\"h\":\"TCP的socket编程\"},\"362\":{\"h\":\"1.针对TCP应该如何socket编程？\"},\"363\":{\"h\":\"2.listen 时候参数 backlog 的意义？\"},\"364\":{\"h\":\"3.accept 发生在三次握手的哪一步？\"},\"365\":{\"h\":\"4.客户端调用 close 了，连接是断开的流程是什么？\"},\"366\":{\"h\":\"5.服务端没有调用Listen,客户端请求建立连接会发生什么？\"},\"367\":{\"h\":\"6.没有listen可以建立TCP连接吗？\"},\"368\":{\"h\":\"7.没有Accpet，能建立TCP连接吗？\"},\"369\":{\"h\":\"8.为什么半连接队列要设计成哈希表？\"},\"370\":{\"h\":\"9.会有一个cookies队列吗\"},\"371\":{\"h\":\"10.cookies方案为什么不直接取代半连接队列？\"},\"372\":{\"h\":\"TCP和UDP可以同时绑定相同的端口吗？\"},\"373\":{\"h\":\"1.TCP和UDP可以同时绑定相同的端口吗？\"},\"374\":{\"h\":\"2.\"},\"375\":{\"h\":\"\"},\"376\":{\"h\":\"4.重启 TCP 服务进程时，如何避免“Address in use”的报错信息？\"},\"377\":{\"h\":\"\"},\"378\":{\"h\":\"\"},\"379\":{\"h\":\"7.客户端 TCP 连接 TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立新的连接吗？\"},\"380\":{\"h\":\"TCP的优化\"},\"381\":{\"h\":\"如何优化TCP？\"},\"382\":{\"h\":\"TCP三次握手的性能提升？\"},\"383\":{\"h\":\"TCP四次挥手性能的提升？\"},\"384\":{\"h\":\"TCP传输数据的性能提升？\"},\"385\":{\"h\":\"TCP的基本认识\"},\"386\":{\"h\":\"TCP基本认识\"},\"387\":{\"h\":\"TCP的头格式：\"},\"388\":{\"h\":\"TCP工作在那一层：\"},\"389\":{\"h\":\"什么是TCP协议：\"},\"390\":{\"h\":\"什么是TCP连接:\"},\"391\":{\"h\":\"如何确定一个TCP连接：\"},\"392\":{\"h\":\"如何理解TCP是基于字节流的协议？\"},\"393\":{\"h\":\"先来说说为什么 UDP 是面向报文的协议？\"},\"394\":{\"h\":\"再来说说为什么 TCP 是面向字节流的协议？\"},\"395\":{\"h\":\"TCP半连接队列和全连接队列\"},\"396\":{\"h\":\"SYN报文在什么情况下会被丢弃？\"},\"397\":{\"h\":\"拔掉网线之后，TCP连接会消失吗？\"},\"398\":{\"h\":\"\"},\"399\":{\"h\":\"用了TCP传输数据就一定不会丢包吗？\"},\"400\":{\"h\":\"TCP的拥塞控制\"},\"401\":{\"h\":\"拥塞控制：\"},\"402\":{\"h\":\"慢启动\"},\"403\":{\"h\":\"拥塞避免\"},\"404\":{\"h\":\"拥塞发生\"},\"405\":{\"h\":\"快速恢复\"},\"406\":{\"h\":\"TCP的流量控制\"},\"407\":{\"h\":\"滑动窗口\"},\"408\":{\"h\":\"窗口大小由哪一方决定？\"},\"409\":{\"h\":\"发送方的滑动窗口：\"},\"410\":{\"h\":\"程序如何表示发送方的四个部分呢？\"},\"411\":{\"h\":\"接收方的滑动窗口：\"},\"412\":{\"h\":\"接收窗口和发送窗口的大小是相等的吗？\"},\"413\":{\"h\":\"流量控制\"},\"414\":{\"h\":\"操作系统缓冲区和滑动窗口的关系：\"},\"415\":{\"h\":\"窗口关闭\"},\"416\":{\"h\":\"糊涂窗口综合征\"},\"417\":{\"h\":\"TCP的重传机制\"},\"418\":{\"h\":\"TCP的重传机制\"},\"419\":{\"h\":\"1.超时重传\"},\"420\":{\"h\":\"2.快速重传\"},\"421\":{\"h\":\"3.SACK方法\"},\"422\":{\"h\":\"4.Duplicate SACK\"},\"423\":{\"h\":\"TCP连接的建立\"},\"424\":{\"h\":\"TCP连接的建立：\"},\"425\":{\"h\":\"为什么是三次握手：\"},\"426\":{\"h\":\"为什么每次建立TCP链接的时候，初始化序列号的都要求不一样？\"},\"427\":{\"h\":\"初始序列号ISN是如何随机产生的？\"},\"428\":{\"h\":\"既然IP层会分片，为什么TCP层还需要MSS？\"},\"429\":{\"h\":\"第一次握手丢失\"},\"430\":{\"h\":\"第二次握手丢失\"},\"431\":{\"h\":\"第三次握手丢失\"},\"432\":{\"h\":\"为什么每次建立TCP连接，初始化序列号都要不一样？\"},\"433\":{\"h\":\"TCP 序列号和确认号是如何变化的？\"},\"434\":{\"h\":\"万能公式\"},\"435\":{\"h\":\"已建立的TCP连接，收到SYN会发生什么？\"},\"436\":{\"h\":\"killcx 的工具\"},\"437\":{\"h\":\"tcpkill 的工具\"},\"438\":{\"h\":\"\"},\"439\":{\"h\":\"TCP连接的断开\"},\"440\":{\"h\":\"TCP断开连接\"},\"441\":{\"h\":\"TCP的四次挥手：\"},\"442\":{\"h\":\"第一次挥手丢失：\"},\"443\":{\"h\":\"第二次挥手丢失：\"},\"444\":{\"h\":\"第三次挥手丢失：\"},\"445\":{\"h\":\"第四次挥手丢失\"},\"446\":{\"h\":\"TCP四次挥手可以变成三次吗？\"},\"447\":{\"h\":\"粗暴关闭VS优雅关闭：\"},\"448\":{\"h\":\"什么情况下会出现三次挥手？\"},\"449\":{\"h\":\"四次挥手中收到乱序的FIN包怎么办\"},\"450\":{\"h\":\"在TIME_WAIT状态的TCP接收到SYN报文会怎么样？\"},\"451\":{\"h\":\"SYN合法：\"},\"452\":{\"h\":\"SYN非法：\"},\"453\":{\"h\":\"在 TIME_WAIT 状态，收到 RST 会断开连接吗？\"},\"454\":{\"h\":\"如果已经建立了链接，客户端突然挂怎么办\"},\"455\":{\"h\":\"如果已经建立了链接，服务端突然挂怎么办\"},\"456\":{\"h\":\"TCP连接，一端断电和进程崩溃有什么区别？\"},\"457\":{\"h\":\"客户端主机宕机又重启？\"},\"458\":{\"h\":\"QUIC协议\"},\"459\":{\"h\":\"\"},\"460\":{\"h\":\"QUIC是如何实现可靠传输的？\"},\"461\":{\"h\":\"Packet Header\"},\"462\":{\"h\":\"QUIC Frame Header\"},\"463\":{\"h\":\"QUIC 是如何解决 TCP 队头阻塞问题的？\"},\"464\":{\"h\":\"QUIC 是如何做流量控制的？\"},\"465\":{\"h\":\"QUIC 对拥塞控制改进\"},\"466\":{\"h\":\"QUIC 更快的连接建立\"},\"467\":{\"h\":\"QUIC 是如何迁移连接的？\"},\"468\":{\"h\":\"常见的网络分层模型\"},\"469\":{\"h\":\"网络模型：\"},\"470\":{\"h\":\"\"},\"471\":{\"h\":\"\"},\"472\":{\"h\":\"：\"},\"473\":{\"h\":\"基础计网\"},\"474\":{\"h\":\"应用层：\"},\"475\":{\"h\":\"用户态和内核态：\"},\"476\":{\"h\":\"传输层：（作为传输媒介）\"},\"477\":{\"h\":\"网络层:(有着实际的传输功能)\"},\"478\":{\"h\":\"IP协议的寻址作用：\"},\"479\":{\"h\":\"IP协议还可以\"},\"480\":{\"h\":\"网络接口层：\"},\"481\":{\"h\":\"键入一个URL网络世界发生了什么？\"},\"482\":{\"h\":\"1.浏览器第一步工作是解析ULR，然后生产HTTP请求消息，然后会\"},\"483\":{\"h\":\"2.在发送之前， ，在委托操作系统发送消息时必须提供\"},\"484\":{\"h\":\"DNS服务器:专门保存了 服务器域名与 的对应关系\"},\"485\":{\"h\":\"只指路不带路\"},\"486\":{\"h\":\"3.通过DNS获取到IP后，把传输工作给操作系统中的协议栈\"},\"487\":{\"h\":\"4.http协议是基于TCP协议传输的\"},\"488\":{\"h\":\"1.第一次握手\"},\"489\":{\"h\":\"2.第二次握手\"},\"490\":{\"h\":\"3.第三次握手\"},\"491\":{\"h\":\"完整的TCP报文：\"},\"492\":{\"h\":\"4.IP\"},\"493\":{\"h\":\"5.MAC\"},\"494\":{\"h\":\"5.网卡（真正的数据发送）\"},\"495\":{\"h\":\"6.交换机\"},\"496\":{\"h\":\"7.路由器\"},\"497\":{\"h\":\"8.客户端&服务器\"},\"498\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"499\":{\"h\":\"Work\"},\"500\":{\"h\":\"一问一答\"},\"501\":{\"h\":\"My SQL\"},\"502\":{\"h\":\"Redis\"},\"503\":{\"h\":\"计算机操作系统\"},\"504\":{\"h\":\"Go基础\"},\"505\":{\"h\":\"Python基础\"},\"506\":{\"h\":\"HTTP\"},\"507\":{\"h\":\"计算机网络\"},\"508\":{\"h\":\"IP\"},\"509\":{\"h\":\"TCP\"},\"510\":{\"h\":\"计算机网络基础\"}},\"dirtCount\":0,\"index\":[[\"路由器\",{\"0\":{\"496\":1}}],[\"真正的数据发送\",{\"0\":{\"494\":1}}],[\"完整的tcp报文\",{\"0\":{\"491\":1}}],[\"完全公平调度\",{\"0\":{\"207\":1}}],[\"专门保存了\",{\"0\":{\"484\":1}}],[\"浏览器第一步工作是解析ulr\",{\"0\":{\"482\":1}}],[\"键入一个url网络世界发生了什么\",{\"0\":{\"481\":1}}],[\"键值对的key和value可以是任意类型\",{\"1\":{\"265\":1}}],[\"作为传输媒介\",{\"0\":{\"476\":1}}],[\"作为队列\",{\"1\":{\"133\":1}}],[\"传输层\",{\"0\":{\"476\":1}}],[\"传统的\",{\"1\":{\"113\":1}}],[\"传统\",{\"1\":{\"113\":1}}],[\"收到\",{\"0\":{\"453\":1}}],[\"收到syn会发生什么\",{\"0\":{\"435\":1}}],[\"粗暴关闭vs优雅关闭\",{\"0\":{\"447\":1}}],[\"万能公式\",{\"0\":{\"434\":1}}],[\"既然ip层会分片\",{\"0\":{\"428\":1}}],[\"既不在缓存中也不再数据库中\",{\"1\":{\"119\":1}}],[\"糊涂窗口综合征\",{\"0\":{\"416\":1}}],[\"操作系统缓冲区和滑动窗口的关系\",{\"0\":{\"414\":1}}],[\"流量控制\",{\"0\":{\"413\":1}}],[\"流程函数\",{\"0\":{\"87\":1}}],[\"窗口关闭\",{\"0\":{\"415\":1}}],[\"窗口大小由哪一方决定\",{\"0\":{\"408\":1}}],[\"窗口函数通常搭配over\",{\"1\":{\"27\":1}}],[\"拔掉网线之后\",{\"0\":{\"397\":1}}],[\"能建立tcp连接吗\",{\"0\":{\"368\":1}}],[\"能被正确的关闭\",{\"1\":{\"69\":1}}],[\"了\",{\"0\":{\"365\":1}}],[\"针对tcp应该如何socket编程\",{\"0\":{\"362\":1}}],[\"什么情况下会出现三次挥手\",{\"0\":{\"448\":1}}],[\"什么时syn超时\",{\"0\":{\"357\":1}}],[\"什么是tcp连接\",{\"0\":{\"390\":1}}],[\"什么是tcp协议\",{\"0\":{\"389\":1}}],[\"什么是syn攻击\",{\"0\":{\"356\":1}}],[\"什么是d类\",{\"0\":{\"341\":1}}],[\"什么是a\",{\"0\":{\"340\":1}}],[\"什么是127\",{\"0\":{\"332\":1}}],[\"什么是中断\",{\"0\":{\"217\":1}}],[\"什么是lfu算法\",{\"1\":{\"114\":1}}],[\"什么是restful风格\",{\"0\":{\"71\":1}}],[\"什么是oauth2\",{\"0\":{\"43\":1}}],[\"地址与路由控制\",{\"0\":{\"344\":1}}],[\"地址与私有\",{\"0\":{\"343\":1}}],[\"地址\",{\"0\":{\"343\":1}}],[\"断网了还能ping通127\",{\"0\":{\"331\":1}}],[\"软件优化\",{\"0\":{\"307\":1}}],[\"软中断\",{\"0\":{\"219\":1}}],[\"硬件优化\",{\"0\":{\"306\":1}}],[\"连接\",{\"0\":{\"379\":1}}],[\"连接是断开的流程是什么\",{\"0\":{\"365\":1}}],[\"连接迁移\",{\"0\":{\"302\":1}}],[\"连续签到用户总数\",{\"1\":{\"160\":1}}],[\"更快的连接建立\",{\"0\":{\"466\":1}}],[\"更快连接建立\",{\"0\":{\"301\":1}}],[\"更新元素\",{\"1\":{\"265\":1}}],[\"更新数据\",{\"1\":{\"123\":1}}],[\"更新数据库\",{\"1\":{\"123\":1}}],[\"更新外键在子表中的记录\",{\"1\":{\"90\":1}}],[\"更新对应记录时\",{\"1\":{\"90\":3}}],[\"更新\",{\"1\":{\"90\":3}}],[\"更新上次填充的时间\",{\"1\":{\"39\":1}}],[\"更新桶中令牌数\",{\"1\":{\"39\":1}}],[\"队头阻塞问题的\",{\"0\":{\"463\":1}}],[\"队头阻塞\",{\"0\":{\"296\":1}}],[\"队列中没有任务\",{\"1\":{\"134\":1}}],[\"队列\",{\"1\":{\"133\":1}}],[\"二进制帧\",{\"0\":{\"292\":1}}],[\"二线城市\",{\"1\":{\"87\":2}}],[\"动态编码表\",{\"0\":{\"291\":1}}],[\"静态表编码\",{\"0\":{\"290\":1}}],[\"头部压缩\",{\"0\":{\"289\":1}}],[\"兼容http1\",{\"0\":{\"288\":1}}],[\"兼容性差\",{\"1\":{\"171\":1}}],[\"协商缓存\",{\"0\":{\"281\":1}}],[\"协议\",{\"0\":{\"216\":1},\"1\":{\"71\":1}}],[\"强缓存\",{\"0\":{\"280\":1}}],[\"强调了资源的标识\",{\"1\":{\"71\":1}}],[\"合并两个集合\",{\"1\":{\"270\":1}}],[\"合理的设置缓存过期时间\",{\"1\":{\"116\":1}}],[\"移除元素remove\",{\"1\":{\"270\":1}}],[\"移除并返回key列表的尾元素\",{\"1\":{\"143\":1}}],[\"移除并返回key列表的头元素\",{\"1\":{\"143\":1}}],[\"添加新元素\",{\"1\":{\"270\":1}}],[\"添加外键\",{\"1\":{\"90\":2}}],[\"混装\",{\"1\":{\"270\":1}}],[\"混合持久化缺点\",{\"1\":{\"171\":1}}],[\"混合持久化工作在\",{\"1\":{\"171\":1}}],[\"混合持久化\",{\"0\":{\"171\":1}}],[\"混合持久化方式\",{\"1\":{\"165\":1}}],[\"自带去重\",{\"1\":{\"270\":1}}],[\"自带去重操作\",{\"1\":{\"270\":1}}],[\"自定义消息结构\",{\"1\":{\"56\":1}}],[\"封装到列表中\",{\"1\":{\"269\":1}}],[\"股价达到\",{\"1\":{\"268\":1}}],[\"股票代码\",{\"1\":{\"268\":1}}],[\"经过\",{\"1\":{\"268\":1}}],[\"公有\",{\"0\":{\"343\":1}}],[\"公司\",{\"1\":{\"268\":1}}],[\"公众号等\",{\"1\":{\"152\":1}}],[\"年\",{\"1\":{\"268\":1}}],[\"年龄\",{\"1\":{\"89\":1,\"90\":1}}],[\"年龄相同按入职时间升序排序\",{\"1\":{\"80\":1}}],[\"年龄小于60岁的\",{\"1\":{\"80\":1}}],[\"我今天的股价是\",{\"1\":{\"268\":1}}],[\"我成立于\",{\"1\":{\"268\":1}}],[\"我是\",{\"1\":{\"268\":1}}],[\"我们可以使用辅助符号\",{\"1\":{\"268\":1}}],[\"我们可以采用延时双删的策略\",{\"1\":{\"123\":1}}],[\"我们可以\",{\"1\":{\"122\":1}}],[\"我们可以对请求进行限流\",{\"1\":{\"117\":1}}],[\"我们可以自定义一个消息结构\",{\"1\":{\"56\":1}}],[\"四舍五入为\",{\"1\":{\"268\":1}}],[\"四次挥手中收到乱序的fin包怎么办\",{\"0\":{\"449\":1}}],[\"四次挥手\",{\"0\":{\"64\":1}}],[\"宽度\",{\"1\":{\"268\":1}}],[\"很少使用\",{\"1\":{\"268\":1}}],[\"控制小数点精度\",{\"1\":{\"268\":1}}],[\"控制宽度\",{\"1\":{\"268\":1}}],[\"控制数据库的访问权限\",{\"1\":{\"73\":1}}],[\"三引号定义法\",{\"1\":{\"268\":1}}],[\"三次握手的目的是确认双方都有发送和接受的能力\",{\"1\":{\"63\":1}}],[\"三次握手\",{\"0\":{\"60\":1}}],[\"黑马程序员\",{\"1\":{\"268\":6}}],[\"黑客恶意攻击\",{\"1\":{\"119\":1}}],[\"算术\",{\"1\":{\"268\":1}}],[\"算法中\",{\"1\":{\"114\":2}}],[\"算法会记录每个数据的访问次数\",{\"1\":{\"114\":1}}],[\"算法是根据数据访问次数来淘汰数据的它的核心思想是\",{\"1\":{\"114\":1}}],[\"算法来解决这人问题\",{\"1\":{\"113\":1}}],[\"算法\",{\"1\":{\"113\":1}}],[\"算法存在两个问题\",{\"1\":{\"113\":1}}],[\"算法的实现是基于\",{\"1\":{\"113\":1}}],[\"运算符\",{\"1\":{\"268\":2}}],[\"运行队列\",{\"0\":{\"208\":1}}],[\"运行在主从模式下时\",{\"1\":{\"194\":1}}],[\"运行模式的话\",{\"1\":{\"193\":2}}],[\"英文\",{\"1\":{\"268\":1}}],[\"英语\",{\"1\":{\"87\":1}}],[\"布尔\",{\"1\":{\"268\":1}}],[\"布隆过滤器会通过\",{\"1\":{\"119\":1}}],[\"布隆过滤器由于是基于哈希函数实现查找的\",{\"1\":{\"119\":1}}],[\"布隆过滤器由\",{\"1\":{\"119\":1}}],[\"布隆过滤器\",{\"1\":{\"119\":1}}],[\"复合运算符\",{\"1\":{\"268\":1}}],[\"复数\",{\"1\":{\"268\":1}}],[\"复制select\",{\"1\":{\"23\":1}}],[\"浮点数\",{\"1\":{\"268\":1}}],[\"整数\",{\"1\":{\"268\":2}}],[\"整个redisobject和sds都需要重新分配空间\",{\"1\":{\"138\":1}}],[\"整个系统就会出现无响应的现象\",{\"1\":{\"116\":1}}],[\"起始和结束不写表示从头到尾\",{\"1\":{\"267\":1}}],[\"起始索引可以省略\",{\"1\":{\"80\":1}}],[\"起始索引=\",{\"1\":{\"80\":1}}],[\"起始索引从0开始\",{\"1\":{\"80\":1}}],[\"起始索引\",{\"1\":{\"80\":1}}],[\"步长\",{\"1\":{\"267\":3}}],[\"步长2\",{\"1\":{\"267\":1}}],[\"步长为1可以省略\",{\"1\":{\"267\":1}}],[\"步长默认是1\",{\"1\":{\"267\":1}}],[\"步长1\",{\"1\":{\"267\":2}}],[\"序列号和确认号是如何变化的\",{\"0\":{\"433\":1}}],[\"序列的切片\",{\"0\":{\"267\":1},\"1\":{\"267\":1}}],[\"序列\",{\"1\":{\"265\":1}}],[\"序列类型\",{\"1\":{\"265\":2}}],[\"支持for循环\",{\"1\":{\"270\":1}}],[\"支持所有容器转为str\",{\"1\":{\"265\":1}}],[\"支持所有容器转为list\",{\"1\":{\"265\":1}}],[\"支持\",{\"1\":{\"265\":3}}],[\"支持发布订阅模型\",{\"1\":{\"105\":1}}],[\"跟据keys\",{\"1\":{\"265\":1}}],[\"遍历集合\",{\"1\":{\"270\":1}}],[\"遍历\",{\"1\":{\"265\":1}}],[\"张信哲\",{\"1\":{\"265\":1}}],[\"张学油\",{\"1\":{\"265\":1}}],[\"张无忌\",{\"1\":{\"90\":1}}],[\"林俊节\",{\"1\":{\"265\":1}}],[\"周杰轮\",{\"1\":{\"265\":3}}],[\"周小阶\",{\"1\":{\"265\":1}}],[\"王力宏\",{\"1\":{\"265\":3}}],[\"匿名函数\",{\"1\":{\"264\":1}}],[\"接受不定长的数据\",{\"1\":{\"264\":1}}],[\"接收窗口和发送窗口的大小是相等的吗\",{\"0\":{\"412\":1}}],[\"接收方的滑动窗口\",{\"0\":{\"411\":1}}],[\"接收的复制数据多\",{\"1\":{\"181\":1}}],[\"接收客户端请求→解析请求→进行数据读写等操作→发送数据给客户端\",{\"1\":{\"162\":1}}],[\"接收放在接收完数据之后将其放到缓冲区\",{\"1\":{\"57\":1}}],[\"位置不定长\",{\"1\":{\"264\":1}}],[\"位移操作符\",{\"1\":{\"159\":1}}],[\"枫枫\",{\"1\":{\"264\":1}}],[\"沃尔玛购物袋\",{\"1\":{\"264\":1}}],[\"必须是设置在最后\",{\"1\":{\"264\":1}}],[\"天天\",{\"1\":{\"264\":1}}],[\"萧峰\",{\"1\":{\"264\":1}}],[\"女\",{\"1\":{\"264\":2}}],[\"形参\",{\"1\":{\"264\":1}}],[\"跳过本次循环\",{\"1\":{\"262\":1,\"268\":1}}],[\"您快去\",{\"1\":{\"262\":1,\"268\":1}}],[\"成年\",{\"1\":{\"262\":1,\"268\":1}}],[\"成功将任务放入队列\",{\"1\":{\"134\":1}}],[\"成功获取锁\",{\"1\":{\"125\":1}}],[\"未成年\",{\"1\":{\"262\":1,\"268\":1}}],[\"未能释放锁\",{\"1\":{\"131\":1}}],[\"未能获取互斥锁的请求\",{\"1\":{\"118\":1}}],[\"你的年龄是\",{\"1\":{\"262\":2,\"268\":2}}],[\"你可以不买票\",{\"1\":{\"262\":1,\"268\":1}}],[\"你可以为键指定权重最后分值会乘以你设置的权重\",{\"1\":{\"155\":1}}],[\"你可以使用\",{\"1\":{\"134\":1}}],[\"你可以将任务放入一个\",{\"1\":{\"127\":1}}],[\"请输入你的vip等级\",{\"1\":{\"262\":1,\"268\":1}}],[\"请输入你的身高\",{\"1\":{\"262\":1,\"268\":1}}],[\"请输入你的年龄\",{\"1\":{\"262\":2,\"268\":2}}],[\"请求b能够完成从数据库读取数据\",{\"1\":{\"123\":1}}],[\"请求更新数据库为\",{\"1\":{\"122\":1}}],[\"请求更新缓存为\",{\"1\":{\"122\":1}}],[\"请求先将缓存的数据更新为\",{\"1\":{\"122\":1}}],[\"请求先将数据库的数据更新为\",{\"1\":{\"122\":1}}],[\"请求\",{\"1\":{\"122\":2,\"123\":1}}],[\"请求字段是否存在\",{\"1\":{\"119\":1}}],[\"请求参数是否含有非法值\",{\"1\":{\"119\":1}}],[\"清空集合\",{\"1\":{\"270\":1}}],[\"清空元素\",{\"1\":{\"265\":1}}],[\"清空列表\",{\"1\":{\"261\":1}}],[\"清空事务队列\",{\"1\":{\"129\":1}}],[\"下划线\",{\"1\":{\"268\":1}}],[\"下标1的元素提取出来并返回\",{\"1\":{\"261\":1}}],[\"下面是延时双删的伪代码\",{\"1\":{\"123\":1}}],[\"追加写入\",{\"1\":{\"269\":1}}],[\"追加\",{\"1\":{\"269\":1}}],[\"追加一堆元素\",{\"1\":{\"261\":1}}],[\"追加元素\",{\"1\":{\"261\":1}}],[\"尼豪\",{\"1\":{\"261\":1}}],[\"反向索引\",{\"1\":{\"261\":1}}],[\"正\",{\"1\":{\"264\":1}}],[\"正向索引\",{\"1\":{\"261\":1}}],[\"正序获取有序集合key从start下标到stop下标的元素\",{\"1\":{\"155\":1}}],[\"泛型切片\",{\"1\":{\"260\":1}}],[\"泛型函数\",{\"0\":{\"260\":1}}],[\"killcx\",{\"0\":{\"436\":1}}],[\"kwargs\",{\"1\":{\"264\":2}}],[\"k\",{\"1\":{\"260\":4}}],[\"key不可为字典\",{\"1\":{\"265\":1}}],[\"key不存在才插入\",{\"1\":{\"140\":1}}],[\"keyn\",{\"1\":{\"159\":2}}],[\"keyl\",{\"1\":{\"159\":1}}],[\"key代表用户id\",{\"1\":{\"148\":1}}],[\"key删除掉\",{\"1\":{\"140\":1}}],[\"keys\",{\"1\":{\"131\":2,\"265\":1}}],[\"key3\",{\"1\":{\"129\":1}}],[\"key2\",{\"1\":{\"129\":9,\"139\":2}}],[\"key1\",{\"1\":{\"129\":11,\"139\":2,\"159\":1}}],[\"key问题\",{\"1\":{\"118\":1}}],[\"key\",{\"0\":{\"101\":1},\"1\":{\"89\":3,\"90\":9,\"101\":3,\"102\":1,\"114\":5,\"125\":2,\"127\":2,\"131\":1,\"138\":1,\"139\":15,\"140\":3,\"143\":9,\"146\":1,\"147\":8,\"148\":1,\"151\":19,\"155\":14,\"159\":4,\"169\":1,\"171\":6,\"184\":1,\"190\":3,\"191\":10,\"192\":5,\"193\":1,\"194\":4,\"265\":4}}],[\"十进制小数与二进制的转换\",{\"0\":{\"252\":1}}],[\"理解线程\",{\"0\":{\"245\":1}}],[\"输入\",{\"0\":{\"241\":1}}],[\"输出结果0\",{\"1\":{\"268\":1}}],[\"输出结果\",{\"1\":{\"268\":4}}],[\"输出设备\",{\"0\":{\"241\":1}}],[\"输出\",{\"1\":{\"29\":1,\"268\":1}}],[\"冯诺依曼模型\",{\"0\":{\"237\":1}}],[\"段页式内存管理\",{\"0\":{\"231\":1}}],[\"问题背景\",{\"0\":{\"222\":1}}],[\"虚拟内存管理器\",{\"0\":{\"236\":1}}],[\"虚拟内存的功能\",{\"0\":{\"235\":1}}],[\"虚拟内存的作用\",{\"0\":{\"234\":1}}],[\"虚拟内存\",{\"0\":{\"221\":1}}],[\"调整优先级\",{\"0\":{\"209\":1}}],[\"调度类\",{\"0\":{\"206\":1}}],[\"伪共享是什么\",{\"0\":{\"203\":1}}],[\"跑得更快的代码\",{\"0\":{\"197\":1}}],[\"指针到了最后\",{\"1\":{\"269\":1}}],[\"指数\",{\"1\":{\"268\":1}}],[\"指今来删除过期的\",{\"1\":{\"194\":1}}],[\"指令缓存\",{\"0\":{\"199\":1}}],[\"指令\",{\"1\":{\"194\":1}}],[\"指定每个节点上的哈希槽个数\",{\"1\":{\"184\":1}}],[\"像未过期的键值对一样返回\",{\"1\":{\"194\":1}}],[\"依然可以得到\",{\"1\":{\"194\":1}}],[\"难以确定删除操作执行的时长和频率\",{\"1\":{\"191\":1}}],[\"超过\",{\"1\":{\"191\":1}}],[\"超时重传\",{\"0\":{\"419\":1},\"1\":{\"54\":1}}],[\"已建立的tcp连接\",{\"0\":{\"435\":1}}],[\"已建立连接或者正在建立连接的两方\",{\"1\":{\"54\":2}}],[\"已过期的键不会被保存到重写后的\",{\"1\":{\"193\":1}}],[\"已过期\",{\"1\":{\"191\":1}}],[\"已经过期\",{\"1\":{\"190\":1}}],[\"友好\",{\"1\":{\"190\":1}}],[\"友情链接\",{\"0\":{\"0\":1}}],[\"情性删除策略对\",{\"1\":{\"190\":1}}],[\"惰性删除策略对内存不友好\",{\"1\":{\"190\":1}}],[\"惰性删除\",{\"0\":{\"190\":1}}],[\"惰性删除+定期删除\",{\"1\":{\"189\":1}}],[\"脑裂现象\",{\"0\":{\"185\":1}}],[\"组成集群\",{\"1\":{\"184\":1}}],[\"手动分配\",{\"1\":{\"184\":1}}],[\"平均分配\",{\"1\":{\"184\":1}}],[\"平均值\",{\"1\":{\"80\":1}}],[\"范围内的模数\",{\"1\":{\"184\":1}}],[\"他将数据分布在不同的服务器上\",{\"1\":{\"184\":1}}],[\"切片集群模式\",{\"0\":{\"184\":1}}],[\"继续监视旧主节点\",{\"1\":{\"181\":1}}],[\"继续去左边查询第一个元素\",{\"1\":{\"26\":1}}],[\"频道发布新主节点的ip地址和端口的消息\",{\"1\":{\"181\":1}}],[\"订阅者机制来相互发现的\",{\"1\":{\"182\":1}}],[\"订阅者机制机制\",{\"1\":{\"181\":1}}],[\"订阅者机制\",{\"1\":{\"181\":1}}],[\"订单最多的客户\",{\"0\":{\"28\":1},\"1\":{\"28\":1}}],[\"较小的那个\",{\"1\":{\"181\":1}}],[\"较短的那个字符串所缺少的部分会被看作\",{\"1\":{\"159\":1}}],[\"哪个就靠前\",{\"1\":{\"181\":1}}],[\"哪个从\",{\"1\":{\"181\":1}}],[\"哪个从节点优先胜出\",{\"1\":{\"181\":1}}],[\"哪个哨兵判断主节点\",{\"1\":{\"180\":1}}],[\"挑选出一个从节点\",{\"1\":{\"181\":1}}],[\"里面\",{\"1\":{\"181\":1}}],[\"属下的所有\",{\"1\":{\"181\":1}}],[\"属性记录了字符串长度\",{\"1\":{\"138\":1}}],[\"属性的值而不是空字符判断字符串是否结束\",{\"1\":{\"138\":1}}],[\"旧主节点\",{\"1\":{\"181\":1}}],[\"谁先满足条件谁就是leader\",{\"1\":{\"180\":1}}],[\"谁就是候选者\",{\"1\":{\"180\":1}}],[\"拿到的票数同时还需要大于等于哨兵配置文件中的\",{\"1\":{\"180\":1}}],[\"拿到半数以上的赞成票\",{\"1\":{\"180\":1}}],[\"候选者\",{\"1\":{\"180\":1}}],[\"候选者会向其他哨兵发送命令\",{\"1\":{\"180\":1}}],[\"任何一个\",{\"1\":{\"180\":1}}],[\"任务队列\",{\"1\":{\"162\":1}}],[\"任务调度\",{\"1\":{\"134\":1}}],[\"任务异步处理\",{\"1\":{\"134\":1}}],[\"客观下线\",{\"1\":{\"179\":1,\"180\":1}}],[\"客户端主机宕机又重启\",{\"0\":{\"457\":1}}],[\"客户端主动想要断开连接\",{\"1\":{\"65\":1}}],[\"客户端突然挂怎么办\",{\"0\":{\"454\":1}}],[\"客户端\",{\"0\":{\"379\":1,\"497\":1}}],[\"客户端请求建立连接会发生什么\",{\"0\":{\"366\":1}}],[\"客户端调用\",{\"0\":{\"365\":1}}],[\"客户端可以在一条网络连接中批量发送多个请求\",{\"1\":{\"129\":1}}],[\"客户端可以一次性将多条命令发送给\",{\"1\":{\"129\":1}}],[\"客户端向服务端发送ack报文\",{\"1\":{\"68\":1}}],[\"客户端接收之后进入fin\",{\"1\":{\"66\":1}}],[\"客户端和服务器都进入established\",{\"1\":{\"63\":1}}],[\"客户端在接收服务器的带有syn和ack\",{\"1\":{\"63\":1}}],[\"客户端处于syn\",{\"1\":{\"61\":1,\"62\":1}}],[\"客户端会发送一个带有syn\",{\"1\":{\"61\":1}}],[\"改主节点就会标记为\",{\"1\":{\"179\":1}}],[\"至少要三台服务器\",{\"1\":{\"179\":1}}],[\"哨兵认为主节点下线\",{\"1\":{\"187\":1}}],[\"哨兵会向主节点发送info\",{\"1\":{\"182\":1}}],[\"哨兵会每隔一秒向从节点发送ping命令\",{\"1\":{\"179\":1}}],[\"哨兵节点之间是通过\",{\"1\":{\"182\":1}}],[\"哨兵就会自动将这个主节点设置为从节点\",{\"1\":{\"187\":1}}],[\"哨兵就会向+switch\",{\"1\":{\"181\":1}}],[\"哨兵就会将他们标记为\",{\"1\":{\"179\":1}}],[\"哨兵向所有的从节点发送slaveof命令<新主节点的ip和端口>\",{\"1\":{\"181\":1}}],[\"哨兵首先会根据从节点的优先级来进行排序\",{\"1\":{\"181\":1}}],[\"哨兵发送slaveof\",{\"1\":{\"181\":1}}],[\"哨兵在部署的时候要用多个节点\",{\"1\":{\"179\":1}}],[\"哨兵的作用\",{\"1\":{\"178\":1}}],[\"哨兵模式\",{\"0\":{\"178\":1}}],[\"实例\",{\"1\":{\"268\":1}}],[\"实时监测主从节点网络状态\",{\"1\":{\"177\":1}}],[\"实现主从节点故障转移\",{\"1\":{\"178\":1}}],[\"实现了\",{\"1\":{\"142\":1}}],[\"实现了高效的异步任务处理\",{\"1\":{\"134\":1}}],[\"实现不同服务之间的解耦和异步通信\",{\"1\":{\"134\":1}}],[\"实现阻塞式消费\",{\"1\":{\"134\":2}}],[\"实现延迟队列可以通过多种方法\",{\"1\":{\"127\":1}}],[\"实现互斥锁的时候\",{\"1\":{\"116\":1}}],[\"实现的是一种近似\",{\"1\":{\"113\":1}}],[\"实现i\",{\"1\":{\"104\":1}}],[\"尽可能的大一些减少出现从服务器要读取的数据被覆盖的概率\",{\"1\":{\"176\":1}}],[\"到尾结束\",{\"1\":{\"267\":1}}],[\"到结束\",{\"1\":{\"267\":1}}],[\"到最后结束\",{\"1\":{\"267\":3}}],[\"到期时\",{\"1\":{\"194\":1}}],[\"到期的任务\",{\"1\":{\"127\":1}}],[\"到的位置\",{\"1\":{\"176\":2}}],[\"环形\",{\"1\":{\"176\":1}}],[\"增量\",{\"1\":{\"176\":1}}],[\"增量复制\",{\"0\":{\"176\":1}}],[\"增加或删除元素等\",{\"1\":{\"270\":1}}],[\"增加\",{\"1\":{\"58\":2}}],[\"称之为基于长连接的命令传播\",{\"1\":{\"174\":1}}],[\"称为记录锁\",{\"1\":{\"99\":1}}],[\"带着两个参数主服务器runid和目前的复制进度offset\",{\"1\":{\"174\":1}}],[\"包含单引号\",{\"1\":{\"268\":1}}],[\"包含双引号\",{\"1\":{\"268\":1}}],[\"包含主服务器的runid和复制进度offset\",{\"1\":{\"174\":1}}],[\"包括重复的行\",{\"1\":{\"24\":1}}],[\"包括\",{\"1\":{\"19\":1}}],[\"于是父进程\",{\"1\":{\"171\":1}}],[\"于是父子进程就有了独立的数据副本就不用加锁来保证数据安全\",{\"1\":{\"169\":1}}],[\"占用的内存不会及时得到释放\",{\"1\":{\"191\":1}}],[\"占用的物理内存是比较大的\",{\"1\":{\"171\":1}}],[\"占比随机抽取\",{\"1\":{\"191\":1}}],[\"占位符\",{\"1\":{\"79\":1}}],[\"虽然不会复制父进程的物理内存\",{\"1\":{\"171\":1}}],[\"虽然有一个discard命令\",{\"1\":{\"129\":1}}],[\"随机提取出元素\",{\"1\":{\"270\":1}}],[\"随机\",{\"1\":{\"191\":1}}],[\"随机淘汰任意键值\",{\"1\":{\"111\":1}}],[\"随机淘汰设置了过期时间的任意键值\",{\"1\":{\"110\":1}}],[\"随着\",{\"1\":{\"171\":1}}],[\"阻塞的时间会比较久\",{\"1\":{\"171\":1}}],[\"阻塞读取\",{\"1\":{\"144\":1}}],[\"策略的时候\",{\"1\":{\"171\":2}}],[\"使得\",{\"1\":{\"171\":1}}],[\"使用转义字符\",{\"1\":{\"268\":1}}],[\"使用单引号进行包围\",{\"1\":{\"268\":1}}],[\"使用str\",{\"1\":{\"265\":1}}],[\"使用string\",{\"1\":{\"158\":1}}],[\"使用list\",{\"1\":{\"265\":1}}],[\"使用lua脚本保证只有拥有锁的客户端能释放锁\",{\"1\":{\"131\":1}}],[\"使用global关键字\",{\"1\":{\"264\":1}}],[\"使用for循环99乘法表\",{\"1\":{\"262\":1,\"268\":1}}],[\"使用for遍历list\",{\"1\":{\"261\":1}}],[\"使用while遍历list\",{\"1\":{\"261\":1}}],[\"使用哨兵集群的形式\",{\"1\":{\"179\":1}}],[\"使用场景\",{\"0\":{\"140\":1,\"144\":1,\"148\":1,\"152\":1,\"156\":1,\"160\":1}}],[\"使用异步队列可以将任务放入队列中\",{\"1\":{\"134\":1}}],[\"使用redis实现一个异步队列\",{\"0\":{\"133\":1}}],[\"使用redis实现一个分布式锁\",{\"0\":{\"131\":1}}],[\"使用redis实现延时队列\",{\"0\":{\"127\":1}}],[\"使用管道技术\",{\"1\":{\"129\":1}}],[\"使用布隆过滤器判断数据是否存在\",{\"1\":{\"119\":1}}],[\"使用布隆过滤器快速判断数据是否存在\",{\"1\":{\"119\":1}}],[\"使用逗号分隔\",{\"1\":{\"73\":1}}],[\"使用特殊符号标识边界\",{\"1\":{\"56\":1}}],[\"使用二分查找可以提供o\",{\"1\":{\"26\":1}}],[\"使用ifnull\",{\"1\":{\"19\":1}}],[\"使用\",{\"1\":{\"19\":1,\"23\":1,\"24\":2,\"73\":1,\"119\":1,\"127\":1,\"131\":1,\"134\":2,\"138\":1,\"144\":1}}],[\"内置了flush函数\",{\"1\":{\"269\":1}}],[\"内有\",{\"1\":{\"262\":1,\"268\":1}}],[\"内核空间与用户空间的区别\",{\"0\":{\"233\":1}}],[\"内容限定\",{\"1\":{\"268\":1}}],[\"内容\",{\"1\":{\"171\":2}}],[\"内存分页\",{\"0\":{\"227\":1}}],[\"内存分段\",{\"0\":{\"224\":1}}],[\"内存交换效率低\",{\"0\":{\"226\":1}}],[\"内存碎片\",{\"0\":{\"225\":1}}],[\"内存管理\",{\"0\":{\"220\":1}}],[\"内存\",{\"0\":{\"238\":1},\"1\":{\"162\":1}}],[\"格式的内容\",{\"1\":{\"171\":1}}],[\"格式的\",{\"1\":{\"171\":1}}],[\"格式和\",{\"1\":{\"171\":1}}],[\"方便后续应用\",{\"1\":{\"264\":1}}],[\"方便定位目标是否持有锁\",{\"1\":{\"131\":1}}],[\"方式写入到\",{\"1\":{\"171\":2}}],[\"出来的重写子进程会先将与主线程共享的内存数据以\",{\"1\":{\"171\":1}}],[\"缓冲区大小\",{\"1\":{\"176\":1}}],[\"缓冲区\",{\"1\":{\"169\":1,\"176\":1}}],[\"缓存一致性问题\",{\"0\":{\"214\":1}}],[\"缓存类型为\",{\"1\":{\"148\":1}}],[\"缓存\",{\"1\":{\"140\":1}}],[\"缓存提升性能\",{\"1\":{\"138\":1}}],[\"缓存空值或者默认值\",{\"1\":{\"119\":1}}],[\"缓存中的数据和数据库中的数据都被误删除了\",{\"1\":{\"119\":1}}],[\"缓存中很长一段时间\",{\"1\":{\"113\":1}}],[\"缓存穿透的发生一般有这两种情况\",{\"1\":{\"119\":1}}],[\"缓存穿透\",{\"0\":{\"119\":1}}],[\"缓存击穿\",{\"0\":{\"118\":1}}],[\"缓存雪崩\",{\"0\":{\"116\":1}}],[\"缓存性能\",{\"1\":{\"113\":1}}],[\"期间交互了什么\",{\"0\":{\"316\":1}}],[\"期间主线程处理的操作命令\",{\"1\":{\"171\":1}}],[\"期间\",{\"1\":{\"169\":1}}],[\"父进程对共享内存中的大\",{\"1\":{\"171\":1}}],[\"父子进程是共享内存数据的\",{\"1\":{\"169\":1}}],[\"父表有变更时\",{\"1\":{\"90\":1}}],[\"还会将写命令写入到repl\",{\"1\":{\"176\":1}}],[\"还是会阻塞后续的操作无法执行\",{\"1\":{\"166\":1}}],[\"还可以保存二进制数据\",{\"1\":{\"138\":1}}],[\"风险\",{\"1\":{\"166\":1}}],[\"集群脑裂\",{\"0\":{\"186\":1}}],[\"集群时\",{\"1\":{\"184\":1}}],[\"集群就会认为这个节点挂掉了\",{\"1\":{\"177\":1}}],[\"集成了\",{\"1\":{\"165\":1}}],[\"集合的长度len\",{\"1\":{\"270\":1}}],[\"集合的定义\",{\"1\":{\"270\":1}}],[\"集合2不变化\",{\"1\":{\"270\":1}}],[\"集合1有集合2没有的元素\",{\"1\":{\"270\":1}}],[\"集合set\",{\"1\":{\"270\":1}}],[\"集合\",{\"0\":{\"270\":1},\"1\":{\"146\":1,\"265\":3,\"268\":1}}],[\"快照\",{\"1\":{\"165\":1}}],[\"快速查询到期任务\",{\"1\":{\"127\":1}}],[\"快速恢复\",{\"0\":{\"405\":1},\"1\":{\"58\":1}}],[\"快速重传解决了超时重传重传周期太长的问题\",{\"1\":{\"54\":1}}],[\"快速重传\",{\"0\":{\"420\":1},\"1\":{\"54\":1}}],[\"索引在6\",{\"1\":{\"163\":1}}],[\"网卡\",{\"0\":{\"494\":1}}],[\"网络接口层\",{\"0\":{\"480\":1}}],[\"网络层\",{\"0\":{\"477\":1}}],[\"网络模型\",{\"0\":{\"469\":1}}],[\"网络迁移需要重新连接\",{\"0\":{\"298\":1}}],[\"网络断开后\",{\"1\":{\"176\":1}}],[\"网络硬件性能的提升\",{\"1\":{\"163\":1}}],[\"网页请求\",{\"1\":{\"51\":1}}],[\"死锁的问题\",{\"1\":{\"163\":1}}],[\"同时创建一个定时事件\",{\"1\":{\"192\":1}}],[\"同时也能删除一部分过期的数据减少了过期键对空间的无效占用\",{\"1\":{\"191\":1}}],[\"同时不会存在在线程切换\",{\"1\":{\"163\":1}}],[\"同步到所有的从库\",{\"1\":{\"194\":1}}],[\"同步给从服务器continue\",{\"1\":{\"176\":1}}],[\"同步协商\",{\"1\":{\"174\":1}}],[\"同步已发送\",{\"1\":{\"61\":1}}],[\"同步序列编号\",{\"1\":{\"61\":1}}],[\"减少系统复杂度\",{\"1\":{\"163\":1}}],[\"减少了网络往返次数\",{\"1\":{\"129\":1}}],[\"大小写敏感\",{\"1\":{\"268\":1}}],[\"大部分操作都在内存中完成\",{\"1\":{\"163\":1}}],[\"大于等于\",{\"1\":{\"79\":1}}],[\"大于\",{\"1\":{\"79\":1,\"191\":1}}],[\"文里增加一条\",{\"1\":{\"194\":1}}],[\"文件名\",{\"1\":{\"269\":5}}],[\"文件操作\",{\"0\":{\"269\":1}}],[\"文件追加一条\",{\"1\":{\"193\":1}}],[\"文件会保留此过期键\",{\"1\":{\"193\":1}}],[\"文件写入阶段\",{\"1\":{\"193\":1}}],[\"文件写入阶段和\",{\"1\":{\"193\":1}}],[\"文件分为两个阶段\",{\"1\":{\"193\":1}}],[\"文件时\",{\"1\":{\"193\":2}}],[\"文件产生任何影响\",{\"1\":{\"193\":1}}],[\"文件中\",{\"1\":{\"193\":2}}],[\"文件中添加了\",{\"1\":{\"171\":1}}],[\"文件生成阶段\",{\"1\":{\"193\":1}}],[\"文件生成和文件加载阶段\",{\"1\":{\"193\":1}}],[\"文件的从服务器也不会造成影响\",{\"1\":{\"193\":1}}],[\"文件的主服务器造成影响\",{\"1\":{\"193\":1}}],[\"文件的可读性变得很差\",{\"1\":{\"171\":1}}],[\"文件的时间太长\",{\"1\":{\"170\":1}}],[\"文件替换日的的\",{\"1\":{\"171\":1}}],[\"文件替换掉现有的\",{\"1\":{\"168\":1}}],[\"文件\",{\"1\":{\"168\":2,\"170\":2,\"171\":4,\"193\":1}}],[\"文件刷盘\",{\"1\":{\"162\":1}}],[\"文章浏览i\",{\"1\":{\"17\":1}}],[\"写法和多行注释是一样的\",{\"1\":{\"268\":1}}],[\"写回\",{\"0\":{\"213\":1}}],[\"写直达\",{\"0\":{\"212\":1}}],[\"写\",{\"1\":{\"176\":1}}],[\"写入数据\",{\"1\":{\"269\":1}}],[\"写入\",{\"1\":{\"269\":1}}],[\"写入到replication\",{\"1\":{\"174\":1}}],[\"写入完成后通知主进程将新的含有\",{\"1\":{\"171\":1}}],[\"写时复制\",{\"1\":{\"169\":1}}],[\"写时删除\",{\"0\":{\"123\":1}}],[\"写日志操作封装成一个任务\",{\"1\":{\"162\":1}}],[\"选项后\",{\"1\":{\"162\":1}}],[\"选择要返回的列\",{\"1\":{\"79\":1}}],[\"日志重写过程\",{\"1\":{\"171\":1}}],[\"日志过程中\",{\"1\":{\"169\":1}}],[\"日志也是在主线程中执行\",{\"1\":{\"166\":1}}],[\"日志里后\",{\"1\":{\"166\":1}}],[\"日志\",{\"1\":{\"165\":1,\"166\":1}}],[\"日志配置成\",{\"1\":{\"162\":1}}],[\"日期函数\",{\"0\":{\"86\":1}}],[\"刷盘\",{\"1\":{\"162\":1}}],[\"刷盘这两个任务\",{\"1\":{\"162\":1}}],[\"关闭\",{\"1\":{\"269\":1}}],[\"关闭文件任务队列\",{\"1\":{\"162\":1}}],[\"关闭文件\",{\"1\":{\"162\":1}}],[\"关键字lambda\",{\"1\":{\"264\":1}}],[\"关键字不定长\",{\"1\":{\"264\":1}}],[\"关键字\",{\"1\":{\"89\":1}}],[\"线程的优劣势\",{\"0\":{\"249\":1}}],[\"线程的优势\",{\"0\":{\"244\":1}}],[\"线程的实现方式\",{\"0\":{\"248\":1}}],[\"线程的上下文切换\",{\"0\":{\"247\":1}}],[\"线程与进程的比较\",{\"0\":{\"246\":1}}],[\"线程\",{\"0\":{\"243\":1},\"1\":{\"162\":1}}],[\"新主节点\",{\"1\":{\"181\":1}}],[\"新增元素\",{\"1\":{\"265\":1}}],[\"新增的方式\",{\"1\":{\"165\":1}}],[\"新增了一个新的后台线程\",{\"1\":{\"162\":1}}],[\"新密码\",{\"1\":{\"73\":1}}],[\"版本\",{\"1\":{\"162\":1}}],[\"版本之后\",{\"1\":{\"142\":1,\"162\":1}}],[\"程并不是单线程的\",{\"1\":{\"162\":1}}],[\"程序如何表示发送方的四个部分呢\",{\"0\":{\"410\":1}}],[\"程序猿\",{\"1\":{\"261\":2,\"268\":1}}],[\"程序会对文件中保存的键进行检查\",{\"1\":{\"193\":1}}],[\"程序会先将对象的编码从embstr转换成raw\",{\"1\":{\"138\":1}}],[\"程序员鼓励师\",{\"1\":{\"90\":1}}],[\"单引号定义法\",{\"1\":{\"268\":1}}],[\"单线程指的是\",{\"1\":{\"162\":1}}],[\"单线程\",{\"0\":{\"161\":1}}],[\"单飞\",{\"0\":{\"125\":1},\"1\":{\"122\":1}}],[\"签到统计\",{\"1\":{\"160\":1}}],[\"空格分割\",{\"1\":{\"159\":1}}],[\"空间是否满足要求\",{\"1\":{\"138\":1}}],[\"参入参数表示传入多少字节\",{\"1\":{\"269\":1}}],[\"参入参数\",{\"1\":{\"264\":1}}],[\"参与运算的key\",{\"1\":{\"159\":1}}],[\"参数以字典的形式存在\",{\"1\":{\"264\":1}}],[\"参数必须是kv形式的\",{\"1\":{\"264\":1}}],[\"参数必须是一个常量或一个变量\",{\"1\":{\"19\":1}}],[\"参数形成一个元组\",{\"1\":{\"264\":1}}],[\"参数可以实现\",{\"1\":{\"140\":1}}],[\"异或^\",{\"1\":{\"159\":1}}],[\"异步队列通过使用\",{\"1\":{\"134\":1}}],[\"异步队列可以用作轻量级的消息队列\",{\"1\":{\"134\":1}}],[\"异步队列的实现\",{\"0\":{\"134\":1}}],[\"异步队列是一种常用的方式\",{\"1\":{\"133\":1}}],[\"异步队列\",{\"0\":{\"132\":1}}],[\"枚举值\",{\"1\":{\"159\":1}}],[\"相互ping\",{\"1\":{\"177\":1}}],[\"相反\",{\"1\":{\"176\":1}}],[\"相同元素分值相加\",{\"1\":{\"155\":2}}],[\"相应改变本端的窗口大小\",{\"1\":{\"57\":1}}],[\"相应的缓冲区就会被释放\",{\"1\":{\"57\":1}}],[\"倒序获取有序集合key从start下标到stop下标的元素\",{\"1\":{\"155\":1}}],[\"往前依次是\",{\"1\":{\"261\":1}}],[\"往有序集合key中删除元素\",{\"1\":{\"155\":1}}],[\"往有序集合key中加入带分值元素\",{\"1\":{\"155\":1}}],[\"往集合key中存入元素\",{\"1\":{\"151\":1}}],[\"抽奖\",{\"1\":{\"152\":1}}],[\"点赞\",{\"1\":{\"152\":1}}],[\"差集\",{\"1\":{\"152\":1}}],[\"差集运算\",{\"1\":{\"151\":1}}],[\"交换机\",{\"0\":{\"495\":1}}],[\"交集计算\",{\"1\":{\"155\":1}}],[\"交集运算\",{\"1\":{\"151\":1}}],[\"交由\",{\"1\":{\"146\":1,\"154\":1}}],[\"若key不存在则新建\",{\"1\":{\"151\":1}}],[\"元组转换时\",{\"1\":{\"265\":1}}],[\"元组不可修改\",{\"1\":{\"263\":1}}],[\"元组也可以包含不同的数据类型\",{\"1\":{\"263\":1}}],[\"元组也可以嵌套\",{\"1\":{\"263\":1}}],[\"元组\",{\"0\":{\"263\":1},\"1\":{\"263\":1,\"265\":3,\"268\":1}}],[\"元素为key没有保留value\",{\"1\":{\"265\":1}}],[\"元素甚至可以是列表\",{\"1\":{\"261\":1}}],[\"元素从key中删除\",{\"1\":{\"151\":1}}],[\"元素不从key中删除\",{\"1\":{\"151\":1}}],[\"元素存在则忽略\",{\"1\":{\"151\":1}}],[\"元数据锁\",{\"0\":{\"95\":1}}],[\"购物车\",{\"1\":{\"148\":1}}],[\"压缩列表数据结构已经废弃了\",{\"1\":{\"146\":1,\"154\":1}}],[\"压缩文件这样的二进制数据\",{\"1\":{\"138\":1}}],[\"左进右出\",{\"1\":{\"144\":1}}],[\"左填充\",{\"1\":{\"84\":1}}],[\"没有accpet\",{\"0\":{\"368\":1}}],[\"没有listen可以建立tcp连接吗\",{\"0\":{\"367\":1}}],[\"没有过期就查询\",{\"1\":{\"189\":1}}],[\"没有就阻塞timeout秒\",{\"1\":{\"143\":2}}],[\"没有原生的集群模式\",{\"1\":{\"105\":1}}],[\"区间以偏移量start和stop指定\",{\"1\":{\"143\":1}}],[\"替代了双向链表和压缩列表\",{\"1\":{\"142\":1}}],[\"quic\",{\"0\":{\"462\":1,\"463\":1,\"464\":1,\"465\":1,\"466\":1,\"467\":1}}],[\"quic是如何实现可靠传输的\",{\"0\":{\"460\":1}}],[\"quic协议\",{\"0\":{\"458\":1}}],[\"quic协议的特点\",{\"0\":{\"299\":1}}],[\"quicklist\",{\"1\":{\"142\":1}}],[\"quorum的值建议为哨兵个数的二分之一加1且为奇数\",{\"1\":{\"180\":1}}],[\"quorum\",{\"1\":{\"180\":1}}],[\"queue\",{\"1\":{\"127\":7,\"133\":1,\"134\":3}}],[\"配置好哨兵ip和端口之后\",{\"1\":{\"182\":1}}],[\"配置\",{\"1\":{\"142\":2,\"146\":2}}],[\"配置项为\",{\"1\":{\"107\":1}}],[\"亿\",{\"1\":{\"142\":1}}],[\"按照crc16算法计算一个16\",{\"1\":{\"184\":1}}],[\"按照插入顺序排序\",{\"1\":{\"142\":1}}],[\"按字典倒序排列\",{\"1\":{\"155\":1}}],[\"按字典正序排列\",{\"1\":{\"155\":1}}],[\"按分类统计薪水\",{\"0\":{\"22\":1},\"1\":{\"24\":1}}],[\"共享session信息\",{\"1\":{\"140\":1}}],[\"共享锁\",{\"1\":{\"98\":1}}],[\"转发等\",{\"1\":{\"140\":1}}],[\"秒对从节点发送ping命令\",{\"1\":{\"177\":1}}],[\"秒\",{\"1\":{\"139\":1}}],[\"秒后过期\",{\"1\":{\"139\":1}}],[\"查看数据的类型\",{\"1\":{\"268\":1}}],[\"查看数据还有多久过期\",{\"1\":{\"139\":1}}],[\"查询报文类型\",{\"0\":{\"329\":1}}],[\"查询2在list中下标\",{\"1\":{\"261\":1}}],[\"查询任务时发生错误\",{\"1\":{\"127\":1}}],[\"查询到期任务\",{\"1\":{\"127\":1}}],[\"查询emp\",{\"1\":{\"87\":1}}],[\"查询所有员工入职天数\",{\"1\":{\"86\":1}}],[\"查询所有年龄小于等于35岁员工的姓名和年龄\",{\"1\":{\"80\":1}}],[\"查询性别为男\",{\"1\":{\"80\":2}}],[\"查询年龄为20\",{\"1\":{\"80\":1}}],[\"查询年龄小于45\",{\"1\":{\"80\":1}}],[\"查询页码\",{\"1\":{\"80\":1}}],[\"查询第二页数据\",{\"1\":{\"80\":1}}],[\"查询第一页数据\",{\"1\":{\"80\":1}}],[\"查询第一个大于等于target+1的索引\",{\"1\":{\"26\":1}}],[\"查询记录数\",{\"1\":{\"80\":1}}],[\"查询其他字段无任何意义\",{\"1\":{\"80\":1}}],[\"查询的字段一般为聚合函数和分组字段\",{\"1\":{\"80\":1}}],[\"查询两个字的姓名\",{\"1\":{\"79\":1}}],[\"查询多个字段\",{\"1\":{\"79\":1}}],[\"查询权限\",{\"1\":{\"73\":1}}],[\"查询数据\",{\"1\":{\"73\":1}}],[\"查询用户\",{\"1\":{\"73\":1}}],[\"批量获取哈希表key中多个field键值\",{\"1\":{\"147\":1}}],[\"批量获取多个\",{\"1\":{\"139\":1}}],[\"批量设置\",{\"1\":{\"139\":1}}],[\"批量添加数据\",{\"1\":{\"77\":1}}],[\"获得对应的\",{\"1\":{\"139\":1}}],[\"获取一个新的字符串\",{\"1\":{\"266\":1}}],[\"获取一个从num1到num2步长为step的数字序列\",{\"1\":{\"262\":1,\"268\":1}}],[\"获取全部的key\",{\"1\":{\"265\":1}}],[\"获取指定范围内值为\",{\"1\":{\"159\":1}}],[\"获取指定date的日期\",{\"1\":{\"86\":1}}],[\"获取指定date的月份\",{\"1\":{\"86\":1}}],[\"获取指定date的年份\",{\"1\":{\"86\":1}}],[\"获取值\",{\"1\":{\"159\":1}}],[\"获取集合key中的元素个数\",{\"1\":{\"151\":1}}],[\"获取集合key中所有元素\",{\"1\":{\"151\":1}}],[\"获取哈希表key对应的field键值\",{\"1\":{\"147\":1}}],[\"获取字符串长度的时间复杂度是\",{\"1\":{\"138\":1}}],[\"获取\",{\"1\":{\"129\":2}}],[\"获取结果\",{\"1\":{\"129\":1}}],[\"获取任务时发生错误\",{\"1\":{\"127\":1}}],[\"获取锁失败\",{\"1\":{\"125\":3,\"131\":1}}],[\"获取锁成功\",{\"1\":{\"125\":1,\"131\":1}}],[\"获取当前的日期\",{\"1\":{\"86\":1}}],[\"获取当前月份\",{\"1\":{\"86\":1}}],[\"获取当前年份\",{\"1\":{\"86\":1}}],[\"获取当前时间\",{\"1\":{\"86\":1}}],[\"获取当前日期和时间\",{\"1\":{\"86\":1}}],[\"获取当前日期\",{\"1\":{\"86\":1}}],[\"获取完整的token字符串\",{\"1\":{\"38\":1}}],[\"获取第一个目标值的地址\",{\"1\":{\"26\":1}}],[\"类型\",{\"1\":{\"268\":1}}],[\"类型转换\",{\"1\":{\"265\":1}}],[\"类型作为底层数据结构实现的一种统计二值状态的数据类型\",{\"1\":{\"158\":1}}],[\"类型存储\",{\"1\":{\"148\":1}}],[\"类型的底层数据结构是由压缩列表或哈希表实现的\",{\"1\":{\"146\":1}}],[\"类型的底层数据结构是由双向链表或压缩列表实现的\",{\"1\":{\"142\":1}}],[\"类型的底层数据结构\",{\"1\":{\"142\":2,\"146\":1,\"154\":2}}],[\"类型的值\",{\"1\":{\"139\":4}}],[\"类似\",{\"1\":{\"27\":1}}],[\"常见的网络分层模型\",{\"0\":{\"468\":1}}],[\"常规计数场景像访问次数\",{\"1\":{\"140\":1}}],[\"常用命令\",{\"0\":{\"139\":1,\"143\":1,\"147\":1,\"151\":1,\"155\":1,\"159\":1}}],[\"常遇春\",{\"1\":{\"90\":1}}],[\"编码格式\",{\"1\":{\"269\":1}}],[\"编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用\",{\"1\":{\"138\":1}}],[\"编码的字符串对象同样只需要调用一次内存释放函数\",{\"1\":{\"138\":1}}],[\"编码的两次降低为一次\",{\"1\":{\"138\":1}}],[\"编码将创建字符串对象所需的内存分配次数从\",{\"1\":{\"138\":1}}],[\"编程语言\",{\"0\":{\"5\":1}}],[\"种\",{\"1\":{\"138\":1}}],[\"拼接字符串不会造成缓冲区溢出\",{\"1\":{\"138\":1}}],[\"语言的字符串并不记录自身长度\",{\"1\":{\"138\":1}}],[\"语文\",{\"1\":{\"87\":1,\"265\":3}}],[\"视频\",{\"1\":{\"138\":1}}],[\"视图\",{\"1\":{\"73\":1}}],[\"音频\",{\"1\":{\"138\":1}}],[\"底层是int和sds\",{\"1\":{\"138\":1}}],[\"底层原理\",{\"0\":{\"138\":1,\"142\":1,\"146\":1,\"150\":1,\"154\":1,\"158\":1}}],[\"持久化的过程不会影响主线程\",{\"1\":{\"171\":1}}],[\"持久化的过程\",{\"1\":{\"171\":1}}],[\"持久化\",{\"0\":{\"164\":1},\"1\":{\"134\":1}}],[\"消除两个集合的差集\",{\"1\":{\"270\":1}}],[\"消息保序\",{\"1\":{\"144\":1}}],[\"消息队列和任务调度等多种场景\",{\"1\":{\"134\":1}}],[\"消息队列\",{\"1\":{\"134\":1,\"144\":1}}],[\"消费者要记录已经处理过的消息id\",{\"1\":{\"144\":1}}],[\"消费者按照一定顺序逐个处理\",{\"1\":{\"134\":1}}],[\"消费者会阻塞\",{\"1\":{\"134\":1}}],[\"消费者可以使用\",{\"1\":{\"134\":1}}],[\"消费者负责从队列中获取任务并进行处理\",{\"1\":{\"134\":1}}],[\"消费者代码\",{\"1\":{\"134\":1}}],[\"消费者\",{\"1\":{\"133\":1}}],[\"消费者模式\",{\"1\":{\"133\":1,\"134\":1}}],[\"导致线程卡死现象\",{\"1\":{\"191\":1}}],[\"导致资源浪费\",{\"1\":{\"134\":1}}],[\"导致接收方无法正确解析数据边界\",{\"1\":{\"56\":1}}],[\"顺序\",{\"1\":{\"133\":1}}],[\"生产者负责将任务放入队列中\",{\"1\":{\"134\":1}}],[\"生产者代码\",{\"1\":{\"134\":1}}],[\"生产者\",{\"1\":{\"133\":1}}],[\"生成唯一标识符作为锁的\",{\"1\":{\"131\":1}}],[\"生成一个六位数的随机验证码\",{\"1\":{\"85\":1}}],[\"过多有什么危害\",{\"0\":{\"351\":1}}],[\"过期了\",{\"1\":{\"194\":1}}],[\"过期键对载入\",{\"1\":{\"193\":1}}],[\"过期键\",{\"1\":{\"193\":1}}],[\"过期的键\",{\"1\":{\"193\":1}}],[\"过期\",{\"1\":{\"191\":1}}],[\"过期删除\",{\"1\":{\"189\":1}}],[\"过期一个key\",{\"1\":{\"177\":1}}],[\"过程就是客户端向所有的redis节点发起释放锁的操作\",{\"1\":{\"131\":1}}],[\"过滤分组后的记录\",{\"1\":{\"79\":1}}],[\"过滤符合条件的记录\",{\"1\":{\"79\":1}}],[\"红锁\",{\"1\":{\"131\":1}}],[\"管道技术本质上是客户端提供的功能\",{\"1\":{\"129\":1}}],[\"事务中的\",{\"1\":{\"129\":1}}],[\"事务等功能\",{\"1\":{\"105\":1}}],[\"该错误的命令记录到\",{\"1\":{\"166\":1}}],[\"该方法是针对已经存在的key设置过期时间\",{\"1\":{\"139\":1}}],[\"该键被其他客户端修改了\",{\"1\":{\"129\":1}}],[\"该恢复过程已经结束\",{\"1\":{\"58\":1}}],[\"监视某个键时\",{\"1\":{\"129\":1}}],[\"监听状态\",{\"1\":{\"61\":1}}],[\"放弃在\",{\"1\":{\"129\":1}}],[\"放入syn报文段中\",{\"1\":{\"61\":1}}],[\"取整除\",{\"1\":{\"268\":1}}],[\"取模\",{\"1\":{\"184\":1}}],[\"取反\",{\"1\":{\"159\":1}}],[\"取消事务\",{\"1\":{\"129\":1}}],[\"取余\",{\"1\":{\"85\":1,\"268\":1}}],[\"开始一个事务\",{\"1\":{\"129\":1}}],[\"开发\",{\"1\":{\"90\":3}}],[\"命令手动建立节点间的连接\",{\"1\":{\"184\":1}}],[\"命令创建\",{\"1\":{\"184\":1}}],[\"命令\",{\"1\":{\"170\":1,\"177\":1,\"184\":1}}],[\"命令有个\",{\"1\":{\"140\":1}}],[\"命令轻松实现生产者和消费者的逻辑\",{\"1\":{\"134\":1}}],[\"命令来显式地除该键值\",{\"1\":{\"193\":1}}],[\"命令来实现阻塞式消费\",{\"1\":{\"134\":1}}],[\"命令来阻塞等待任务\",{\"1\":{\"127\":1}}],[\"命令从队列中弹出任务\",{\"1\":{\"134\":1}}],[\"命令将自己的复制偏移量slave\",{\"1\":{\"176\":1}}],[\"命令将任务推送到\",{\"1\":{\"134\":1}}],[\"命令将返回\",{\"1\":{\"129\":1}}],[\"命令尝试获取锁\",{\"1\":{\"131\":1}}],[\"命令监视\",{\"1\":{\"129\":1}}],[\"命令用于监视一个或多个键\",{\"1\":{\"129\":1}}],[\"命令不会执行\",{\"1\":{\"129\":1}}],[\"命令为止\",{\"1\":{\"129\":1}}],[\"命令也可以实现延迟队列\",{\"1\":{\"127\":1}}],[\"适用于任务异步处理\",{\"1\":{\"134\":1}}],[\"适用于任务的执行时间可确定的情况\",{\"1\":{\"127\":1}}],[\"适用于对任务执行时间要求不那么精确的情况\",{\"1\":{\"127\":1}}],[\"解除引号的效用\",{\"1\":{\"268\":1}}],[\"解析时间戳时发生错误\",{\"1\":{\"127\":1}}],[\"解决这个问题\",{\"1\":{\"123\":1}}],[\"解决这个问题可以有两种办法\",{\"1\":{\"116\":1}}],[\"解决双写策略的问题\",{\"1\":{\"122\":1}}],[\"解决\",{\"1\":{\"117\":1}}],[\"解决方法\",{\"0\":{\"188\":1},\"1\":{\"56\":1}}],[\"|\",{\"1\":{\"127\":1,\"260\":7}}],[\"||\",{\"1\":{\"26\":3,\"38\":1}}],[\"定义嵌套字典\",{\"1\":{\"265\":1}}],[\"定义字典\",{\"1\":{\"265\":1}}],[\"定义单个元组的时候后面必须写上\",{\"1\":{\"263\":1}}],[\"定义\",{\"1\":{\"261\":1,\"263\":1}}],[\"定时删除策略对\",{\"1\":{\"192\":1}}],[\"定时删除策略的做法是\",{\"1\":{\"192\":1}}],[\"定时删除对内存是最友好的\",{\"1\":{\"192\":1}}],[\"定时删除\",{\"0\":{\"192\":1}}],[\"定时去数据库中拉去新的数据\",{\"1\":{\"124\":1}}],[\"定期删除\",{\"0\":{\"191\":1}}],[\"定期从该列表中取出任务并处理\",{\"1\":{\"127\":1}}],[\"延迟队列\",{\"1\":{\"127\":1}}],[\"延时队列\",{\"0\":{\"126\":1}}],[\"负无穷大\",{\"1\":{\"127\":1}}],[\"代表有序集合的元素\",{\"1\":{\"127\":1}}],[\"代表所有\",{\"1\":{\"73\":1}}],[\"zunionstore\",{\"1\":{\"155\":1}}],[\"zinterstore\",{\"1\":{\"155\":1}}],[\"zincrby\",{\"1\":{\"155\":1}}],[\"ziplist\",{\"1\":{\"142\":2,\"146\":2}}],[\"zcard\",{\"1\":{\"155\":1}}],[\"zscore\",{\"1\":{\"155\":1}}],[\"zset的底层实现是压缩列表或跳表\",{\"1\":{\"154\":1}}],[\"zset\",{\"0\":{\"153\":1},\"1\":{\"105\":1,\"127\":1,\"154\":3}}],[\"zrevrangebylex\",{\"1\":{\"155\":1}}],[\"zrevrange\",{\"1\":{\"155\":1}}],[\"zrem\",{\"1\":{\"127\":1,\"155\":1}}],[\"zrange\",{\"1\":{\"155\":1}}],[\"zrangebylex\",{\"1\":{\"155\":1}}],[\"zrangeby\",{\"1\":{\"127\":1}}],[\"zrangebyscore\",{\"1\":{\"127\":1,\"155\":1}}],[\"z结构体的切片\",{\"1\":{\"127\":1}}],[\"z\",{\"1\":{\"127\":3}}],[\"zadd\",{\"1\":{\"127\":2,\"155\":1}}],[\"列表的下标可以反向索引最后一个数据下标为\",{\"1\":{\"261\":1}}],[\"列表的最大长度为\",{\"1\":{\"142\":1}}],[\"列表每个元素的值都小于\",{\"1\":{\"142\":1,\"146\":1}}],[\"列表添加元素\",{\"1\":{\"142\":1}}],[\"列表是简单的字符串列表\",{\"1\":{\"142\":1}}],[\"列表中\",{\"1\":{\"127\":1,\"134\":1}}],[\"列表和\",{\"1\":{\"127\":1}}],[\"列表\",{\"1\":{\"127\":2,\"265\":3,\"268\":1}}],[\"另一进程仍持有锁\",{\"1\":{\"125\":1}}],[\"另一个进程持有锁\",{\"1\":{\"125\":1,\"131\":1}}],[\"处理不同长度的字符串时\",{\"1\":{\"159\":1}}],[\"处理重复的消息和保证消息可靠性\",{\"1\":{\"144\":1}}],[\"处理任务\",{\"1\":{\"127\":2,\"134\":4}}],[\"处理任务中\",{\"1\":{\"125\":1}}],[\"处理表连接\",{\"1\":{\"79\":1}}],[\"业务逻辑\",{\"1\":{\"125\":1,\"131\":1}}],[\"业务误操作\",{\"1\":{\"119\":1}}],[\"释放跳表对象\",{\"1\":{\"162\":1}}],[\"释放对象\",{\"1\":{\"162\":1}}],[\"释放内存这三个任务都有各自的任务队列\",{\"1\":{\"162\":1}}],[\"释放embstr\",{\"1\":{\"138\":1}}],[\"释放锁的操作和单节点一样\",{\"1\":{\"131\":1}}],[\"释放锁失败\",{\"1\":{\"125\":1}}],[\"释放锁成功\",{\"1\":{\"125\":1}}],[\"释放锁\",{\"1\":{\"125\":4,\"131\":2}}],[\"释放间隙锁的时刻\",{\"1\":{\"102\":1}}],[\"尝试去获取锁\",{\"1\":{\"125\":1,\"131\":1}}],[\"采用监听binlog\",{\"1\":{\"124\":1}}],[\"永不过期\",{\"0\":{\"124\":1}}],[\"注\",{\"1\":{\"123\":1}}],[\"注意\",{\"1\":{\"73\":2,\"80\":3,\"129\":1}}],[\"假如某个用户数据在缓存中不存在\",{\"1\":{\"123\":1}}],[\"假如1亿用户体量\",{\"0\":{\"47\":1}}],[\"睡眠\",{\"1\":{\"123\":1}}],[\"读\",{\"1\":{\"176\":1}}],[\"读取文件的全部行\",{\"1\":{\"269\":1}}],[\"读取当前数据库中的所有键值对\",{\"1\":{\"168\":1}}],[\"读取数据时从数据库中查询到年龄为\",{\"1\":{\"123\":1}}],[\"读时更新\",{\"0\":{\"123\":1}}],[\"读写互斥\",{\"1\":{\"98\":1}}],[\"读写共享\",{\"1\":{\"98\":1}}],[\"紧接着也把数据库更新为\",{\"1\":{\"122\":1}}],[\"紧接着也把缓存更新为\",{\"1\":{\"122\":1}}],[\"双引号定义法\",{\"1\":{\"268\":1}}],[\"双写策略\",{\"0\":{\"122\":1}}],[\"双方协商缓冲区大小\",{\"1\":{\"57\":1}}],[\"得到负数或是一个数减去另一个数a\",{\"1\":{\"268\":1}}],[\"得到每个哈希值在位图数组的对应位置\",{\"1\":{\"119\":1}}],[\"得到\",{\"1\":{\"119\":1,\"184\":1}}],[\"初始化序列号都要不一样\",{\"0\":{\"432\":1}}],[\"初始化序列号的都要求不一样\",{\"0\":{\"426\":1}}],[\"初始值都为\",{\"1\":{\"119\":1}}],[\"初始序列号isn是如何随机产生的\",{\"0\":{\"427\":1}}],[\"初始序列号\",{\"1\":{\"61\":1}}],[\"避免伪共享的方法\",{\"0\":{\"204\":1}}],[\"避免额外的检查开销\",{\"1\":{\"166\":1}}],[\"避免阻塞主流程\",{\"1\":{\"134\":1}}],[\"避免进一步访问缓存和数据库\",{\"1\":{\"119\":1}}],[\"避免通过查询数据库来判断数据是否存在\",{\"1\":{\"119\":1}}],[\"入口处我们要判断求请求参数是否合理\",{\"1\":{\"119\":1}}],[\"入职时间\",{\"1\":{\"90\":1}}],[\"故意大量访问某些读取不存在数据的业务\",{\"1\":{\"119\":1}}],[\"构建缓存集群\",{\"1\":{\"117\":1}}],[\"降低对数据库的压力\",{\"1\":{\"117\":1}}],[\"降序\",{\"1\":{\"80\":1}}],[\"暂停对缓存的访问直接返回错误\",{\"1\":{\"117\":1}}],[\"启动服务熔断\",{\"1\":{\"117\":1}}],[\"启动失败\",{\"1\":{\"37\":1}}],[\"再来说说为什么\",{\"0\":{\"394\":1}}],[\"再手动分配的时候要将所有槽都分配完\",{\"1\":{\"184\":1}}],[\"再使用\",{\"1\":{\"184\":1}}],[\"再用\",{\"1\":{\"184\":1}}],[\"再从主节点的复制缓冲区中拉取丢失数据\",{\"1\":{\"177\":1}}],[\"再回复内存的时候只需要将rdb文件读入就可以\",{\"1\":{\"170\":1}}],[\"再去更新数据\",{\"1\":{\"124\":1}}],[\"再删除缓存\",{\"1\":{\"123\":1}}],[\"再写数据库\",{\"1\":{\"122\":1,\"123\":1}}],[\"再写缓存\",{\"1\":{\"122\":1}}],[\"再多的就直接拒绝\",{\"1\":{\"117\":1}}],[\"再决定是否更新\",{\"1\":{\"116\":1}}],[\"再按照入职时间进行降序排序\",{\"1\":{\"80\":1}}],[\"检测时间不能太长会造成用户体验差\",{\"1\":{\"116\":1}}],[\"检查这\",{\"1\":{\"191\":1}}],[\"检查复制数据是否丢失\",{\"1\":{\"177\":1}}],[\"检查约束\",{\"1\":{\"89\":1}}],[\"检查是否还有令牌可以取\",{\"1\":{\"39\":1}}],[\"检查令牌是否在\",{\"1\":{\"38\":1}}],[\"那又和惰性删除一样了\",{\"1\":{\"191\":1}}],[\"那当\",{\"1\":{\"166\":1}}],[\"那这个大量的请求也会达到db上造成数据库宕机\",{\"1\":{\"118\":1}}],[\"那直到下一次数据更新\",{\"1\":{\"116\":1}}],[\"那么只要这个过期\",{\"1\":{\"190\":1}}],[\"那么主服务器将采用全量同步的方式\",{\"1\":{\"176\":1}}],[\"那么主服务器将采用增量同步的方式\",{\"1\":{\"176\":1}}],[\"那么内核就会发生写时复制\",{\"1\":{\"171\":1}}],[\"那么在投票过程中\",{\"1\":{\"180\":1}}],[\"那么在复制物理内存这一过程中\",{\"1\":{\"171\":1}}],[\"那么在执行\",{\"1\":{\"171\":1}}],[\"那么在修改共享内存数据的时候\",{\"1\":{\"169\":1}}],[\"那么此混合持久化\",{\"1\":{\"171\":1}}],[\"那么如果不进行命令语法检查\",{\"1\":{\"166\":1}}],[\"那么事务将失败\",{\"1\":{\"129\":1}}],[\"那么当前事务将会被中止\",{\"1\":{\"129\":1}}],[\"那么他就会先去删除缓存\",{\"1\":{\"123\":1}}],[\"那么将来被访问的频率也更高\",{\"1\":{\"114\":1}}],[\"那么这个复制过程是会很耗时的\",{\"1\":{\"171\":1}}],[\"那么这个数据不一定存在\",{\"1\":{\"119\":1}}],[\"那么这些数据会留存在\",{\"1\":{\"113\":1}}],[\"那么这一方就会认为数据包丢失\",{\"1\":{\"54\":1}}],[\"那么这一方就会认定出现丢包现象\",{\"1\":{\"54\":1}}],[\"那么另外一个事务在获取相同范围的\",{\"1\":{\"101\":1}}],[\"那么\",{\"1\":{\"58\":1,\"171\":1,\"193\":1}}],[\"那么查询将不会返回任何结果\",{\"1\":{\"19\":1}}],[\"应用层\",{\"0\":{\"474\":1}}],[\"应用层的协议\",{\"0\":{\"318\":1}}],[\"应对缓存穿透的方案\",{\"1\":{\"119\":1}}],[\"应对方式\",{\"1\":{\"116\":1}}],[\"应该保证这个锁的key值和value值的唯一性\",{\"1\":{\"131\":1}}],[\"应该使用\",{\"1\":{\"77\":1}}],[\"应该怎么处理\",{\"0\":{\"46\":1}}],[\"严重会造成数据库宕机\",{\"1\":{\"116\":1}}],[\"让他们成为新主节点的从节点\",{\"1\":{\"181\":1}}],[\"让已下线主节点属下的所有\",{\"1\":{\"181\":1}}],[\"让数据库的压力骤增\",{\"1\":{\"116\":1}}],[\"让发送方知道时丢包还是网络延迟\",{\"1\":{\"54\":1}}],[\"现象\",{\"0\":{\"187\":1},\"1\":{\"116\":1}}],[\"雪崩\",{\"0\":{\"115\":1}}],[\"击穿\",{\"0\":{\"115\":1}}],[\"穿透\",{\"0\":{\"115\":1}}],[\"访问频次\",{\"1\":{\"114\":1}}],[\"低\",{\"1\":{\"114\":1}}],[\"存在越来越多的大\",{\"1\":{\"171\":1}}],[\"存在\",{\"1\":{\"140\":1}}],[\"存放在\",{\"1\":{\"138\":1}}],[\"存诸ldt\",{\"1\":{\"114\":1}}],[\"存储器的层次结构\",{\"0\":{\"242\":1}}],[\"存储一个哈希表key的键值\",{\"1\":{\"147\":1}}],[\"存储\",{\"1\":{\"114\":1,\"148\":1}}],[\"存储引擎提供了一种轻量级的锁来实现自增\",{\"1\":{\"97\":1}}],[\"存储令牌到\",{\"1\":{\"40\":1}}],[\"来控制数据的宽度和精度\",{\"1\":{\"268\":1}}],[\"来减少删除操作对\",{\"1\":{\"191\":1}}],[\"来处理数据和节点之间的映射关系\",{\"1\":{\"184\":1}}],[\"来执行主从切换\",{\"1\":{\"180\":1}}],[\"来完成的\",{\"1\":{\"162\":1,\"169\":1}}],[\"来说\",{\"1\":{\"154\":1}}],[\"来实现任务的先进先出\",{\"1\":{\"133\":1}}],[\"来保证分布式锁的可靠性\",{\"1\":{\"131\":1}}],[\"来比较最后一次\",{\"1\":{\"114\":1}}],[\"来合并三个查询的结果\",{\"1\":{\"24\":1}}],[\"因此不会对\",{\"1\":{\"193\":1}}],[\"因此这个缓冲区里会保存着最近传播的写命令\",{\"1\":{\"176\":1}}],[\"因此在\",{\"1\":{\"119\":1}}],[\"因此在lru\",{\"1\":{\"114\":1}}],[\"因此\",{\"1\":{\"113\":1,\"190\":1,\"192\":1,\"193\":1}}],[\"因为有一个指针\",{\"1\":{\"269\":1}}],[\"因为每次访问时\",{\"1\":{\"190\":1}}],[\"因为如果是使用线程\",{\"1\":{\"169\":1}}],[\"因为当写操作命令执行成功后\",{\"1\":{\"166\":1}}],[\"因为在一个消费者读取之后list就被弹出来\",{\"1\":{\"144\":1}}],[\"因为\",{\"1\":{\"138\":4,\"166\":1}}],[\"因为链表尾部的元素就代表最久未被使用的元素\",{\"1\":{\"113\":1}}],[\"因为redis是基于内存的且是单线程的\",{\"1\":{\"104\":1}}],[\"因为间隙锁的目的是防止插入幻影记录而提出的\",{\"1\":{\"100\":1}}],[\"因为它不需要执行额外的步骤来消除重复的行\",{\"1\":{\"24\":1}}],[\"造成了一定的内存空间浪费\",{\"1\":{\"190\":1}}],[\"造成在这个期间客户端和redis的操作数据丢失\",{\"1\":{\"187\":1}}],[\"造成缓存污染\",{\"1\":{\"113\":1}}],[\"造成数据处理错误\",{\"1\":{\"56\":1}}],[\"缺点是需要处理到期任务的复杂性和周期性扫描\",{\"1\":{\"127\":1}}],[\"缺点是需要定期扫描集合\",{\"1\":{\"127\":1}}],[\"缺点\",{\"1\":{\"113\":1,\"144\":1,\"190\":1,\"191\":1,\"192\":1}}],[\"提取两个集合的差集\",{\"1\":{\"270\":1}}],[\"提升了redis的i\",{\"1\":{\"163\":1}}],[\"提升了缓存的性能\",{\"1\":{\"113\":1}}],[\"提高任务处理能力\",{\"1\":{\"134\":1}}],[\"提供了两个命令来生成rdb文件\",{\"1\":{\"170\":1}}],[\"提供的基本数据结构和命令\",{\"1\":{\"127\":1}}],[\"提供一种快速\",{\"1\":{\"51\":1}}],[\"提供一种可靠的数据传输\",{\"1\":{\"51\":1}}],[\"提供一种可靠的数据传输和通信方式\",{\"1\":{\"51\":1}}],[\"提前通知后台线程更新缓存以及重新设置过期时间\",{\"1\":{\"118\":1}}],[\"节省了空间占用\",{\"1\":{\"113\":1}}],[\"此值可配置\",{\"1\":{\"113\":1}}],[\"此时他发送数据的能力呈线性增长\",{\"1\":{\"58\":1}}],[\"链表中的元素按照操作顺序从前往后排列\",{\"1\":{\"113\":1}}],[\"链表\",{\"1\":{\"113\":1}}],[\"全部记录下来\",{\"1\":{\"170\":1}}],[\"全部成功或全部失败\",{\"1\":{\"129\":1}}],[\"全称是least\",{\"1\":{\"113\":1,\"114\":1}}],[\"全局锁\",{\"0\":{\"92\":1}}],[\"淘汰整个键值中最少使用的键值\",{\"1\":{\"111\":1}}],[\"淘汰整个键值中最久未使用的键值\",{\"1\":{\"111\":1}}],[\"淘汰所有设置了过期时间的键值中\",{\"1\":{\"110\":2}}],[\"之前版本了\",{\"1\":{\"171\":1}}],[\"之前排队的\",{\"1\":{\"129\":1}}],[\"之前\",{\"1\":{\"110\":1,\"129\":1}}],[\"之后会根据key来映射到对应的槽中\",{\"1\":{\"184\":1}}],[\"之后\",{\"1\":{\"179\":1,\"182\":1}}],[\"之后双方会维持一个tcp长连接\",{\"1\":{\"174\":1}}],[\"之后服务器b就会变成a的从\",{\"1\":{\"174\":1}}],[\"之后服务端进入last\",{\"1\":{\"67\":1}}],[\"之后添加的所有命令\",{\"1\":{\"129\":1}}],[\"之后的命令不会立即执行\",{\"1\":{\"129\":1}}],[\"之后引入了\",{\"1\":{\"113\":1}}],[\"之后进入close状态\",{\"1\":{\"68\":1}}],[\"之后客户端进入fin\",{\"1\":{\"65\":1}}],[\"优先级最高胜出\",{\"1\":{\"181\":1}}],[\"优先淘汰更早过期的键值\",{\"1\":{\"110\":1}}],[\"优点是可以阻塞等待任务\",{\"1\":{\"127\":1}}],[\"优点是可以通过分数轻松查询到期任务\",{\"1\":{\"127\":1}}],[\"优点\",{\"1\":{\"113\":1,\"190\":1,\"191\":1,\"192\":1}}],[\"优秀\",{\"1\":{\"87\":1}}],[\"脚本\",{\"1\":{\"105\":1}}],[\"原来的数据删除\",{\"1\":{\"269\":1}}],[\"原主节点就会把所有数据删除\",{\"1\":{\"187\":1}}],[\"原子性\",{\"1\":{\"129\":1}}],[\"原生支持集群模式\",{\"1\":{\"105\":1}}],[\"原因是该\",{\"1\":{\"58\":1}}],[\"都会转为字符串\",{\"1\":{\"265\":1}}],[\"都会以处理二进制的方式来处理\",{\"1\":{\"138\":1}}],[\"都会创建一个独立的分区\",{\"1\":{\"27\":2}}],[\"都有过期策略\",{\"1\":{\"105\":1}}],[\"两个数相乘或是返回一个被重复若干次的字符串a\",{\"1\":{\"268\":1}}],[\"两个对象相加a+b\",{\"1\":{\"268\":1}}],[\"两个好处\",{\"1\":{\"169\":1}}],[\"两部分组成\",{\"1\":{\"119\":1}}],[\"两者的区别\",{\"1\":{\"105\":1}}],[\"两者的性能都非常高\",{\"1\":{\"105\":1}}],[\"两者都是基于内存的数据库\",{\"1\":{\"105\":1}}],[\"两次\",{\"0\":{\"70\":1}}],[\"高可用\",{\"1\":{\"134\":1}}],[\"高效查找的同时存在哈希冲突的可能性\",{\"1\":{\"119\":1}}],[\"高\",{\"1\":{\"114\":1,\"265\":1}}],[\"高并发\",{\"1\":{\"104\":1}}],[\"高性能的redis\",{\"0\":{\"103\":1}}],[\"只指路不带路\",{\"0\":{\"485\":1}}],[\"只能用for遍历\",{\"1\":{\"270\":1}}],[\"只读\",{\"1\":{\"269\":1}}],[\"只允许出现\",{\"1\":{\"268\":1}}],[\"只允许部分请求去找数据\",{\"1\":{\"117\":1}}],[\"只有双引号里都是数字才可以转为int类型\",{\"1\":{\"268\":1}}],[\"只有当锁状态为正常状态时\",{\"1\":{\"102\":1}}],[\"只需要删除链表尾部的元素即可\",{\"1\":{\"113\":1}}],[\"只会和共享表锁\",{\"1\":{\"96\":1}}],[\"加载阶段时\",{\"1\":{\"193\":1}}],[\"加载阶段\",{\"1\":{\"193\":1}}],[\"加载完\",{\"1\":{\"171\":1}}],[\"加载数据的时候\",{\"1\":{\"171\":1}}],[\"加锁解锁\",{\"1\":{\"163\":1}}],[\"加锁失败之后\",{\"1\":{\"131\":1}}],[\"加锁\",{\"1\":{\"116\":1}}],[\"加锁时\",{\"1\":{\"102\":1}}],[\"加上全局锁之后\",{\"1\":{\"92\":1}}],[\"需要通过加锁来保证数据的安全\",{\"1\":{\"169\":1}}],[\"需要我们自己生成然后插入list\",{\"1\":{\"144\":1}}],[\"需要在链表上把该数据移动到头端\",{\"1\":{\"113\":1}}],[\"需要用链表管理所有的缓存数据\",{\"1\":{\"113\":1}}],[\"需要依靠客户端来实现往集群中分片写入数据\",{\"1\":{\"105\":1}}],[\"需要判断插入位置是否已被其他事务加了间隙锁\",{\"1\":{\"102\":1}}],[\"需求\",{\"1\":{\"87\":1}}],[\"插入操作就会发生阻塞\",{\"1\":{\"102\":1}}],[\"插入意向锁\",{\"0\":{\"102\":1}}],[\"插入数据\",{\"1\":{\"73\":1,\"90\":2}}],[\"间隙锁之间是兼容的\",{\"1\":{\"100\":1}}],[\"间隙锁虽然存在\",{\"1\":{\"100\":1}}],[\"间隔60天\",{\"1\":{\"86\":1}}],[\"型的\",{\"1\":{\"101\":2}}],[\"型间隙锁\",{\"1\":{\"100\":1}}],[\"型间隙锁和\",{\"1\":{\"100\":1}}],[\"型与\",{\"1\":{\"99\":4}}],[\"型记录锁\",{\"1\":{\"99\":4}}],[\"型记录锁后\",{\"1\":{\"99\":2}}],[\"满足写写互斥\",{\"1\":{\"98\":1}}],[\"满足读读共享\",{\"1\":{\"98\":1}}],[\"独占锁\",{\"1\":{\"98\":1}}],[\"就正常获取\",{\"1\":{\"189\":1}}],[\"就需要使用redis切片集群\",{\"1\":{\"184\":1}}],[\"就选择从节点\",{\"1\":{\"181\":1}}],[\"就选择其作为新主节点\",{\"1\":{\"181\":1}}],[\"就只是把网络断开期间主服务器接收到的写操作命令\",{\"1\":{\"176\":1}}],[\"就只能全打到你的db上\",{\"1\":{\"116\":1}}],[\"就不能用在\",{\"1\":{\"171\":1}}],[\"就将新的\",{\"1\":{\"168\":1}}],[\"就可以避免单个哨兵也因为自身网络状况\",{\"1\":{\"179\":1}}],[\"就可以先去查询布隆过滤器就判断这个数据是否存在数据库中\",{\"1\":{\"119\":1}}],[\"就可能会出错\",{\"1\":{\"166\":1}}],[\"就把该命令以追加的方式写入到一个文件里\",{\"1\":{\"165\":1}}],[\"就把这个轻量级锁释放了\",{\"1\":{\"97\":1}}],[\"就要把lock\",{\"1\":{\"140\":1}}],[\"就认为加锁成功\",{\"1\":{\"131\":1}}],[\"就一定不存在\",{\"1\":{\"119\":1}}],[\"就造成数据丢失\",{\"1\":{\"116\":1}}],[\"就加一个锁\",{\"1\":{\"116\":1}}],[\"就会变成\",{\"1\":{\"268\":1}}],[\"就会对\",{\"1\":{\"191\":1}}],[\"就会先去查看字典中是否有\",{\"1\":{\"189\":1}}],[\"就会重新选出新的主节点\",{\"1\":{\"187\":1}}],[\"就会将增量的数据写入到replication\",{\"1\":{\"176\":1}}],[\"就会占用很多内存\",{\"1\":{\"171\":1}}],[\"就会在主线程生成rdb\",{\"1\":{\"170\":1}}],[\"就会造成数据不一致问题\",{\"1\":{\"169\":1}}],[\"就会发生阻塞\",{\"1\":{\"171\":1}}],[\"就会发生\",{\"1\":{\"169\":1}}],[\"就会使用哈希表作为底层数据结构\",{\"1\":{\"146\":1}}],[\"就会增加该数据的访问次数\",{\"1\":{\"114\":1}}],[\"就会带来很多链表移动操作\",{\"1\":{\"113\":1}}],[\"就会触发内存淘汰机制\",{\"1\":{\"107\":1}}],[\"就会进入拥塞避免算法\",{\"1\":{\"58\":1}}],[\"就会出现连包和拆包的问题\",{\"1\":{\"56\":1}}],[\"修饰的字段加上轻量级锁\",{\"1\":{\"97\":1}}],[\"修饰的字段的值是连续递增的\",{\"1\":{\"97\":1}}],[\"修饰的字段赋值递增的值\",{\"1\":{\"97\":1}}],[\"修改特定下标的值\",{\"1\":{\"261\":1}}],[\"修改为复制\",{\"1\":{\"181\":1}}],[\"修改复制目标\",{\"1\":{\"181\":1}}],[\"修改表\",{\"1\":{\"73\":1}}],[\"修改数据\",{\"1\":{\"73\":1,\"77\":1}}],[\"修改用户密码\",{\"1\":{\"73\":2}}],[\"锁可能已被其他客户端持有\",{\"1\":{\"131\":1}}],[\"锁已释放\",{\"1\":{\"125\":1,\"131\":1}}],[\"锁已设置\",{\"1\":{\"125\":1}}],[\"锁初始化失败\",{\"1\":{\"125\":1}}],[\"锁不兼容\",{\"1\":{\"99\":3}}],[\"锁兼容\",{\"1\":{\"99\":1}}],[\"锁之分的\",{\"1\":{\"99\":1}}],[\"锁和\",{\"1\":{\"99\":1}}],[\"锁住的是一条记录\",{\"1\":{\"99\":1}}],[\"锁释放掉\",{\"1\":{\"97\":1}}],[\"锁\",{\"0\":{\"97\":1},\"1\":{\"97\":1}}],[\"意向共享锁和意向独占锁是表级锁\",{\"1\":{\"96\":1}}],[\"意向锁\",{\"0\":{\"96\":1}}],[\"先来说说为什么\",{\"0\":{\"393\":1}}],[\"先过滤掉网络状态不好的\",{\"1\":{\"181\":1}}],[\"先投给哪个就是哪个\",{\"1\":{\"180\":1}}],[\"先执行命令再写日志\",{\"1\":{\"166\":1}}],[\"先更新数据库\",{\"1\":{\"123\":1}}],[\"先删缓存\",{\"1\":{\"123\":1}}],[\"先写缓存\",{\"1\":{\"122\":1}}],[\"先写数据库\",{\"1\":{\"122\":1}}],[\"先表上加上意向独占锁\",{\"1\":{\"96\":1}}],[\"先在表上加上意向共享锁\",{\"1\":{\"96\":1}}],[\"先进先出\",{\"1\":{\"29\":1}}],[\"轻易不要去改变数据库的结构包括增加一个字段或者去增加一个索引\",{\"1\":{\"95\":1}}],[\"警告\",{\"1\":{\"95\":1,\"129\":1}}],[\"普通表锁\",{\"0\":{\"94\":1}}],[\"与运算\",{\"1\":{\"159\":1}}],[\"与no\",{\"1\":{\"90\":1}}],[\"与\",{\"1\":{\"90\":1}}],[\"与rank\",{\"1\":{\"27\":1}}],[\"首先检查该记录是否有对应外键\",{\"1\":{\"90\":4}}],[\"首先双方都处于closed状态\",{\"1\":{\"61\":1}}],[\"行级锁\",{\"0\":{\"98\":1}}],[\"行为\",{\"1\":{\"90\":2}}],[\"行开始\",{\"1\":{\"20\":1}}],[\"小数精度2\",{\"1\":{\"268\":2}}],[\"小数部分限制2位精度后\",{\"1\":{\"268\":1}}],[\"小数点和小数部分也算入宽度计算\",{\"1\":{\"268\":1}}],[\"小周\",{\"1\":{\"265\":2}}],[\"小明\",{\"1\":{\"264\":2}}],[\"小昭\",{\"1\":{\"90\":1}}],[\"小于他的阈值的时候\",{\"1\":{\"188\":1}}],[\"小于等于\",{\"1\":{\"79\":1}}],[\"小于\",{\"1\":{\"79\":1}}],[\"韦一笑\",{\"1\":{\"90\":1}}],[\"杨道\",{\"1\":{\"90\":1}}],[\"总线\",{\"0\":{\"240\":1}}],[\"总线嗅探\",{\"0\":{\"215\":1}}],[\"总裁\",{\"1\":{\"90\":1}}],[\"总经办\",{\"1\":{\"90\":1}}],[\"金庸\",{\"1\":{\"90\":1}}],[\"员工表\",{\"1\":{\"90\":1}}],[\"直到有新的任务进入队列\",{\"1\":{\"134\":1}}],[\"直到执行\",{\"1\":{\"129\":1}}],[\"直到拥有间隙锁的那个事务提交为止\",{\"1\":{\"102\":1}}],[\"直到全局锁被释放\",{\"1\":{\"92\":1}}],[\"直属领导id\",{\"1\":{\"90\":1}}],[\"直接for\",{\"1\":{\"265\":1}}],[\"直接结束所在循环\",{\"1\":{\"262\":1,\"268\":1}}],[\"直接返回错误\",{\"1\":{\"108\":1}}],[\"直接简写为limit\",{\"1\":{\"80\":1}}],[\"直接将拥塞窗口降为1\",{\"1\":{\"58\":1}}],[\"薪资\",{\"1\":{\"90\":1}}],[\"职位\",{\"1\":{\"90\":1}}],[\"销售部\",{\"1\":{\"90\":1}}],[\"财务部\",{\"1\":{\"90\":1}}],[\"市场部\",{\"1\":{\"90\":1}}],[\"研发部\",{\"1\":{\"90\":1}}],[\"部门id\",{\"1\":{\"90\":1}}],[\"部门表\",{\"1\":{\"90\":1}}],[\"部门名称\",{\"1\":{\"90\":1}}],[\"性别\",{\"1\":{\"89\":1}}],[\"外语\",{\"1\":{\"265\":2}}],[\"外键的\",{\"1\":{\"90\":1}}],[\"外键字段\",{\"1\":{\"90\":2}}],[\"外键字段名\",{\"1\":{\"90\":1}}],[\"外键名称\",{\"1\":{\"90\":4}}],[\"外键用来让两张表的数据之间建立连接\",{\"1\":{\"90\":1}}],[\"外键约束\",{\"0\":{\"90\":1},\"1\":{\"89\":1}}],[\"外层查询找到出最大值的剩余数中的最大值\",{\"1\":{\"19\":1}}],[\"默认升序\",{\"1\":{\"265\":1}}],[\"默认不会超过\",{\"1\":{\"191\":1}}],[\"默认还是一个线程处理命令但是也可以自己设置\",{\"1\":{\"163\":1}}],[\"默认的内存淘汰策略\",{\"1\":{\"108\":1,\"110\":1}}],[\"默认约束\",{\"1\":{\"89\":1}}],[\"默认值\",{\"1\":{\"80\":1,\"142\":2,\"146\":2}}],[\"要求是数字\",{\"1\":{\"268\":2}}],[\"要求非空且唯一\",{\"1\":{\"89\":1}}],[\"要看服务器是主服务器还是从服务器\",{\"1\":{\"193\":1}}],[\"要满足两个条件\",{\"1\":{\"180\":1}}],[\"要实现处理重复消息\",{\"1\":{\"144\":1}}],[\"要么全部不执行的过程中不会被其他客户端插入命令\",{\"1\":{\"129\":1}}],[\"要么就返回空值或者默认值\",{\"1\":{\"118\":1}}],[\"要么等待锁释放后重新读取缓存\",{\"1\":{\"118\":1}}],[\"要返回的记录数\",{\"1\":{\"21\":1}}],[\"唯一约束\",{\"1\":{\"89\":1}}],[\"限制该字段数据不能为null\",{\"1\":{\"89\":1}}],[\"描述文本的一种数据类型\",{\"1\":{\"268\":1}}],[\"描述\",{\"1\":{\"89\":1,\"268\":2}}],[\"有着实际的传输功能\",{\"0\":{\"477\":1}}],[\"有序的不可变序列\",{\"1\":{\"268\":1}}],[\"有序的可变序列\",{\"1\":{\"268\":1}}],[\"有序集合\",{\"1\":{\"127\":2}}],[\"有缺陷\",{\"0\":{\"228\":1}}],[\"有3\",{\"1\":{\"138\":1}}],[\"有意识地将过期时间分开\",{\"1\":{\"116\":1}}],[\"有效性和完整性\",{\"1\":{\"89\":1}}],[\"有两点作用\",{\"1\":{\"69\":1}}],[\"目的是为\",{\"1\":{\"177\":1}}],[\"目的是为了更好的节约内存\",{\"1\":{\"113\":1}}],[\"目的\",{\"1\":{\"89\":1}}],[\"目前不足5位数的全部在前面补0\",{\"1\":{\"84\":1}}],[\"概念\",{\"1\":{\"89\":1,\"90\":1}}],[\"约束是作用于表中字段上的规则\",{\"1\":{\"89\":1}}],[\"约束\",{\"0\":{\"89\":1}}],[\"及格\",{\"1\":{\"87\":1}}],[\"学员成绩表\",{\"1\":{\"87\":1}}],[\"学习疑问\",{\"0\":{\"50\":1}}],[\"学习笔记\",{\"0\":{\"48\":1}}],[\"姓名\",{\"1\":{\"87\":1,\"89\":1,\"90\":1}}],[\"否则\",{\"1\":{\"87\":1}}],[\"否则返回default默认值\",{\"1\":{\"87\":2}}],[\"否则返回value2\",{\"1\":{\"87\":1}}],[\"否则返回f\",{\"1\":{\"87\":1}}],[\"展示不及格\",{\"1\":{\"87\":1}}],[\"展示及格\",{\"1\":{\"87\":1}}],[\"展示优秀\",{\"1\":{\"87\":1}}],[\"展示的规则如下\",{\"1\":{\"87\":1}}],[\"案例\",{\"1\":{\"87\":1}}],[\"其余任何内容都不被允许\",{\"1\":{\"268\":1}}],[\"其值为\",{\"1\":{\"174\":1}}],[\"其他的list\",{\"1\":{\"261\":1}}],[\"其他哨兵就会获取到\",{\"1\":{\"182\":1}}],[\"其他哨兵会根据自身和主节点的状态做出投票\",{\"1\":{\"179\":1}}],[\"其他事务既不可以对该记录加\",{\"1\":{\"99\":1}}],[\"其他事务也可以继续对该记录加\",{\"1\":{\"99\":1}}],[\"其他事务的如果要向该表插入语句都会被阻塞\",{\"1\":{\"97\":1}}],[\"其他操作都会被阻塞\",{\"1\":{\"92\":1}}],[\"其他\",{\"1\":{\"87\":1}}],[\"其中value只能是0\",{\"1\":{\"159\":1}}],[\"其中某一个\",{\"1\":{\"54\":1}}],[\"其中一方在发出数据包之后\",{\"1\":{\"54\":1}}],[\"其中一方在发出数据包之后超一定时间\",{\"1\":{\"54\":1}}],[\"其中\",{\"1\":{\"51\":1,\"146\":1}}],[\"上报自身复制偏移量\",{\"1\":{\"177\":1}}],[\"上海\",{\"1\":{\"87\":2}}],[\"上次填充令牌的时间\",{\"1\":{\"39\":1}}],[\"北京\",{\"1\":{\"87\":2,\"260\":2}}],[\"某一日\",{\"1\":{\"86\":1}}],[\"结合生产者\",{\"1\":{\"133\":1}}],[\"结构里用\",{\"1\":{\"138\":1}}],[\"结构和生产者\",{\"1\":{\"134\":1}}],[\"结构实现\",{\"1\":{\"133\":1}}],[\"结构\",{\"1\":{\"113\":1}}],[\"结束时间date2之间的天数\",{\"1\":{\"86\":1}}],[\"结果是\",{\"1\":{\"268\":5}}],[\"结果6\",{\"1\":{\"267\":1}}],[\"结果5\",{\"1\":{\"267\":1}}],[\"结果4\",{\"1\":{\"267\":1}}],[\"结果\",{\"1\":{\"265\":2}}],[\"结果3\",{\"1\":{\"85\":1,\"267\":1}}],[\"结果1\",{\"1\":{\"85\":1,\"267\":1}}],[\"结果2\",{\"1\":{\"85\":1,\"267\":1}}],[\"保存数据时\",{\"1\":{\"89\":1}}],[\"保留y位小数\",{\"1\":{\"85\":1}}],[\"保证在同一时间只去运行同一个请求的更新\",{\"1\":{\"122\":1}}],[\"保证同一时间只有一个业务线程更新缓存\",{\"1\":{\"118\":1}}],[\"保证同一时间内针对某一条数据就只有一个请求会去访问数据库\",{\"1\":{\"116\":1}}],[\"保证数据的一致性和完整性\",{\"1\":{\"89\":1}}],[\"保证数据库中数据的正确\",{\"1\":{\"89\":1}}],[\"保证字段值满足某一个条件\",{\"1\":{\"89\":1}}],[\"保证该字段的所有数据都是唯一\",{\"1\":{\"89\":1}}],[\"保证\",{\"1\":{\"69\":1}}],[\"求取两个时间之间的天数\",{\"1\":{\"86\":1}}],[\"求参数x的四舍五入的值\",{\"1\":{\"85\":1}}],[\"求和\",{\"1\":{\"80\":1}}],[\"year\",{\"1\":{\"86\":2,\"268\":2}}],[\"y的模\",{\"1\":{\"85\":1}}],[\"y\",{\"1\":{\"85\":2,\"264\":2}}],[\"×\",{\"1\":{\"85\":1}}],[\"x+y\",{\"1\":{\"264\":2}}],[\"xor\",{\"1\":{\"159\":1}}],[\"x锁\",{\"1\":{\"98\":1}}],[\"x\",{\"1\":{\"85\":3,\"99\":8,\"100\":1,\"101\":2,\"123\":3,\"127\":1,\"264\":2}}],[\"数字11\",{\"1\":{\"268\":2}}],[\"数字11宽度限制1\",{\"1\":{\"268\":1}}],[\"数字11宽度限制5\",{\"1\":{\"268\":1}}],[\"数字精度控制\",{\"1\":{\"268\":1}}],[\"数字\",{\"1\":{\"268\":2}}],[\"数组里的数据\",{\"1\":{\"138\":1}}],[\"数学\",{\"1\":{\"87\":2,\"265\":2,\"268\":1}}],[\"数值函数\",{\"0\":{\"85\":1}}],[\"数据是无序存储的\",{\"1\":{\"270\":1}}],[\"数据\",{\"1\":{\"268\":1}}],[\"数据容器可以从以下视角进行简单的分类\",{\"1\":{\"265\":1}}],[\"数据缓存\",{\"0\":{\"198\":1}}],[\"数据丢失\",{\"0\":{\"186\":1}}],[\"数据同步磁盘\",{\"1\":{\"171\":1}}],[\"数据可能会丢失\",{\"1\":{\"166\":1}}],[\"数据结构来实现了\",{\"1\":{\"146\":1,\"154\":1}}],[\"数据一致性\",{\"0\":{\"120\":1,\"121\":1}}],[\"数据就没有了\",{\"1\":{\"105\":1}}],[\"数据全在内存中\",{\"1\":{\"105\":1}}],[\"数据类型转换\",{\"1\":{\"268\":1}}],[\"数据类型底层数据结构就只由\",{\"1\":{\"142\":1}}],[\"数据类型\",{\"1\":{\"90\":1}}],[\"数据包在经过传输层时可能会被拆分成多个小数据包\",{\"1\":{\"55\":1}}],[\"数据将按\",{\"1\":{\"27\":2}}],[\"数据库是可以进行修改的\",{\"1\":{\"170\":1}}],[\"数据库就属于只读的状态\",{\"1\":{\"92\":1}}],[\"数据库的备份以及迁移\",{\"1\":{\"92\":1}}],[\"数据库名和表名可以使用\",{\"1\":{\"73\":1}}],[\"数据库名\",{\"1\":{\"73\":2}}],[\"数据库管理员\",{\"1\":{\"73\":1}}],[\"数据库\",{\"0\":{\"8\":1}}],[\"统一为5位数\",{\"1\":{\"84\":1}}],[\"统计某元素在列表中的数量\",{\"1\":{\"261\":1}}],[\"统计班级各个学员的成绩\",{\"1\":{\"87\":1}}],[\"统计员工表中\",{\"1\":{\"80\":1}}],[\"统计最大值\",{\"1\":{\"80\":1}}],[\"统计平均数\",{\"1\":{\"80\":1}}],[\"统计数量\",{\"1\":{\"80\":2}}],[\"企业员工的工号\",{\"1\":{\"84\":1}}],[\"右填充\",{\"1\":{\"84\":1}}],[\"达到n个字符串长度\",{\"1\":{\"84\":2}}],[\"字符\",{\"1\":{\"265\":1}}],[\"字符串格式化\",{\"1\":{\"268\":1}}],[\"字符串的替换replace\",{\"1\":{\"266\":1}}],[\"字符串index\",{\"1\":{\"266\":1}}],[\"字符串可以看成是一个存放字符的数据容器\",{\"1\":{\"266\":1}}],[\"字符串转换的时候元素为\",{\"1\":{\"265\":1}}],[\"字符串\",{\"0\":{\"266\":1},\"1\":{\"265\":3,\"266\":1,\"268\":7}}],[\"字符串对象的内部编码\",{\"1\":{\"138\":1}}],[\"字符串拼接\",{\"1\":{\"84\":1}}],[\"字符串函数\",{\"0\":{\"84\":1}}],[\"字典在转换过程中value保留\",{\"1\":{\"265\":1}}],[\"字典经过更新后\",{\"1\":{\"265\":1}}],[\"字典经过新增元素后\",{\"1\":{\"265\":1}}],[\"字典内key不允许重复\",{\"1\":{\"265\":1}}],[\"字典dict\",{\"1\":{\"265\":1}}],[\"字典\",{\"0\":{\"265\":1},\"1\":{\"265\":3,\"268\":1}}],[\"字节时\",{\"1\":{\"154\":1}}],[\"字节\",{\"1\":{\"142\":1,\"146\":1}}],[\"字段被分成两段来存储\",{\"1\":{\"114\":1}}],[\"字段记录的值\",{\"1\":{\"114\":1}}],[\"字段是用来记录\",{\"1\":{\"114\":1}}],[\"字段列表\",{\"1\":{\"79\":2,\"80\":4}}],[\"字段3\",{\"1\":{\"79\":1}}],[\"字段2\",{\"1\":{\"79\":2,\"80\":1}}],[\"字段1\",{\"1\":{\"79\":2,\"80\":1}}],[\"字段名\",{\"1\":{\"90\":1}}],[\"字段名2=值2\",{\"1\":{\"77\":1}}],[\"字段名2\",{\"1\":{\"77\":2}}],[\"字段名1=值1\",{\"1\":{\"77\":1}}],[\"字段名1\",{\"1\":{\"77\":2}}],[\"男\",{\"1\":{\"80\":1,\"264\":3}}],[\"男性员工和女性员工的人数\",{\"1\":{\"80\":1}}],[\"且年龄在20\",{\"1\":{\"80\":1}}],[\"含\",{\"1\":{\"80\":2}}],[\"含最小\",{\"1\":{\"79\":1}}],[\"分析性能损耗\",{\"0\":{\"305\":1}}],[\"分摊压力\",{\"0\":{\"175\":1}}],[\"分别对应以下两种情况\",{\"1\":{\"193\":1}}],[\"分别是save和bgsave\",{\"1\":{\"170\":1}}],[\"分别处理关闭文件\",{\"1\":{\"162\":1}}],[\"分数必须相同\",{\"1\":{\"155\":2}}],[\"分数由低到高排序\",{\"1\":{\"155\":1}}],[\"分值\",{\"1\":{\"154\":1}}],[\"分布式锁\",{\"0\":{\"130\":1},\"1\":{\"140\":1}}],[\"分类\",{\"1\":{\"89\":1}}],[\"分页查询是数据库的方言\",{\"1\":{\"80\":1}}],[\"分组之后\",{\"1\":{\"80\":1}}],[\"分组后的过滤条件\",{\"1\":{\"80\":1}}],[\"分组字段\",{\"1\":{\"80\":1}}],[\"才代表事务成功获取到了锁\",{\"1\":{\"102\":1}}],[\"才会检查\",{\"1\":{\"190\":1}}],[\"才会加载后半部分的\",{\"1\":{\"171\":1}}],[\"才会将命令记录到\",{\"1\":{\"166\":1}}],[\"才会把\",{\"1\":{\"97\":1}}],[\"才会根据第二个字段进行排序\",{\"1\":{\"80\":1}}],[\"才有\",{\"1\":{\"68\":1}}],[\"升序\",{\"1\":{\"80\":1}}],[\"升序排序\",{\"1\":{\"27\":2}}],[\"排行榜\",{\"1\":{\"156\":1}}],[\"排序方式\",{\"1\":{\"80\":1}}],[\"排序方式2\",{\"1\":{\"80\":1}}],[\"排序方式1\",{\"1\":{\"80\":1}}],[\"排名相同\",{\"1\":{\"27\":1}}],[\"执行\",{\"1\":{\"193\":1}}],[\"执行了bqsave\",{\"1\":{\"170\":1}}],[\"执行了save命令\",{\"1\":{\"170\":1}}],[\"执行完一个写命令之后\",{\"1\":{\"169\":1}}],[\"执行写操作命令和记录日志是两个过程\",{\"1\":{\"166\":1}}],[\"执行会导致redis阻塞\",{\"1\":{\"152\":1}}],[\"执行lua脚本即可\",{\"1\":{\"131\":1}}],[\"执行管道命令时发生错误\",{\"1\":{\"129\":1}}],[\"执行管道中的命令\",{\"1\":{\"129\":1}}],[\"执行事务中队列的所有命令\",{\"1\":{\"129\":1}}],[\"执行顺序\",{\"1\":{\"80\":1}}],[\"执行时机不同\",{\"1\":{\"80\":1}}],[\"判断断连次数\",{\"1\":{\"181\":1}}],[\"判断从节点的存活性和连接状态\",{\"1\":{\"177\":1}}],[\"判断用户登录态\",{\"1\":{\"160\":1}}],[\"判断member元素是否存在于集合key中\",{\"1\":{\"151\":1}}],[\"判断某个\",{\"1\":{\"139\":1}}],[\"判断条件不同\",{\"1\":{\"80\":1}}],[\"判断err以及令牌是否有效\",{\"1\":{\"38\":1}}],[\"而误判的情况\",{\"1\":{\"179\":1}}],[\"而从服务器一般是只读状态\",{\"1\":{\"173\":1}}],[\"而当父子进程任意一方修改了该共享内存\",{\"1\":{\"169\":1}}],[\"而使用子进程\",{\"1\":{\"169\":1}}],[\"而这样就会降低性能\",{\"1\":{\"169\":1}}],[\"而这些数据只会被读取这一次\",{\"1\":{\"113\":1}}],[\"而raw编码会通过调用两次内存分配函数来分别分配两块空间来保存redisobject和sds\",{\"1\":{\"138\":1}}],[\"而非redis服务器端的功能\",{\"1\":{\"129\":1}}],[\"而是确保命令的执行顺序不会被外部破坏\",{\"1\":{\"129\":1}}],[\"而是被放入事务队列中\",{\"1\":{\"129\":1}}],[\"而是不再提供服务\",{\"1\":{\"108\":1}}],[\"而不必等待每一条命令的执行结果\",{\"1\":{\"129\":1}}],[\"而不会继续查询数据库\",{\"1\":{\"119\":1}}],[\"而不需要等待整个插入语句执行完后才释放锁\",{\"1\":{\"97\":1}}],[\"而\",{\"1\":{\"105\":1,\"138\":1}}],[\"而memcached没有持久化功能\",{\"1\":{\"105\":1}}],[\"而memcached只支持最简单的key\",{\"1\":{\"105\":1}}],[\"而且作用也有一点区别\",{\"1\":{\"177\":1}}],[\"而且能保存图片\",{\"1\":{\"138\":1}}],[\"而且记录锁是有\",{\"1\":{\"99\":1}}],[\"而且意向锁之间也不会发生冲突\",{\"1\":{\"96\":1}}],[\"而having可以\",{\"1\":{\"80\":1}}],[\"而having是分组之后对结果进行过滤\",{\"1\":{\"80\":1}}],[\"而客户端则会time\",{\"1\":{\"68\":1}}],[\"根据键值对的\",{\"1\":{\"184\":1}}],[\"根据\",{\"1\":{\"139\":1}}],[\"根据年龄进行升序排序\",{\"1\":{\"80\":2}}],[\"根据工作地址分组\",{\"1\":{\"80\":1}}],[\"根据性别分组\",{\"1\":{\"80\":2}}],[\"函数体\",{\"1\":{\"264\":1}}],[\"函数的传参\",{\"1\":{\"264\":1}}],[\"函数的时候就会发生阻塞现象\",{\"1\":{\"171\":1}}],[\"函数的时候\",{\"1\":{\"171\":1}}],[\"函数说明\",{\"1\":{\"264\":1}}],[\"函数创建子进程的时候\",{\"1\":{\"171\":1}}],[\"函数\",{\"0\":{\"264\":1},\"1\":{\"80\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"171\":2,\"264\":1}}],[\"函数使用\",{\"1\":{\"27\":1}}],[\"聚合函数\",{\"0\":{\"80\":1},\"1\":{\"80\":1}}],[\"非序列类型\",{\"1\":{\"265\":2}}],[\"非法请求的限制\",{\"1\":{\"119\":2}}],[\"非空约束\",{\"1\":{\"89\":1}}],[\"非\",{\"1\":{\"79\":1}}],[\"逻辑运算符\",{\"1\":{\"79\":1}}],[\"是如何迁移连接的\",{\"0\":{\"467\":1}}],[\"是如何做流量控制的\",{\"0\":{\"464\":1}}],[\"是如何解决\",{\"0\":{\"463\":1}}],[\"是面向字节流的协议\",{\"0\":{\"394\":1}}],[\"是面向报文的协议\",{\"0\":{\"393\":1}}],[\"是有三个特点\",{\"0\":{\"319\":1}}],[\"是根据什么来选择当前要执行的线程\",{\"0\":{\"205\":1}}],[\"是\",{\"1\":{\"193\":2}}],[\"是否可以修改\",{\"1\":{\"265\":1}}],[\"是否支持重复元素\",{\"1\":{\"265\":1}}],[\"是否支持下标索引\",{\"1\":{\"265\":1}}],[\"是否过期\",{\"1\":{\"190\":1,\"191\":1}}],[\"是否存在\",{\"1\":{\"139\":1}}],[\"是会启动后台线程\",{\"1\":{\"162\":1}}],[\"是会被阻塞的\",{\"1\":{\"101\":1}}],[\"是保存到\",{\"1\":{\"159\":1}}],[\"是安全的\",{\"1\":{\"138\":1}}],[\"是先生成锁结构\",{\"1\":{\"102\":1}}],[\"是包含间隙锁+记录锁的\",{\"1\":{\"101\":1}}],[\"是null\",{\"1\":{\"79\":1}}],[\"是一种针对网络应用程序设计的架构风格\",{\"1\":{\"71\":1}}],[\"是一个\",{\"1\":{\"176\":1}}],[\"是一个键值对\",{\"1\":{\"146\":1}}],[\"是一个或多个redis\",{\"1\":{\"127\":1}}],[\"是一个特殊的值\",{\"1\":{\"77\":1}}],[\"是一个窗口函数\",{\"1\":{\"27\":1}}],[\"是一个整数\",{\"1\":{\"20\":1,\"21\":1}}],[\"匹配任意个字符\",{\"1\":{\"79\":1}}],[\"匹配单个字符\",{\"1\":{\"79\":1}}],[\"模式持久化时\",{\"1\":{\"193\":1}}],[\"模式下\",{\"1\":{\"114\":1}}],[\"模拟任务数据\",{\"1\":{\"134\":1}}],[\"模拟另一个进程持有锁\",{\"1\":{\"125\":3}}],[\"模拟用户认证\",{\"1\":{\"40\":1}}],[\"模糊匹配\",{\"1\":{\"79\":1}}],[\"多次调用read\",{\"1\":{\"269\":1}}],[\"多级页表\",{\"0\":{\"229\":1}}],[\"多核\",{\"0\":{\"200\":1}}],[\"多线程之间会共享内存\",{\"1\":{\"169\":1}}],[\"多消费者\",{\"1\":{\"134\":1}}],[\"多个条件任意一个成立\",{\"1\":{\"79\":1}}],[\"多个条件同时成立\",{\"1\":{\"79\":1}}],[\"多个权限之间\",{\"1\":{\"73\":1}}],[\"多选一\",{\"1\":{\"79\":1}}],[\"最靠前的胜出\",{\"1\":{\"181\":1}}],[\"最右边\",{\"1\":{\"143\":1}}],[\"最后的值在最前面\",{\"1\":{\"143\":1}}],[\"最左边\",{\"1\":{\"143\":1}}],[\"最常用的方法包括使用\",{\"1\":{\"127\":1}}],[\"最好设置超时时间\",{\"1\":{\"116\":1}}],[\"最新操作的键会被移动到表头\",{\"1\":{\"113\":1}}],[\"最少使用的键值\",{\"1\":{\"110\":1}}],[\"最久未使用的键值\",{\"1\":{\"110\":1}}],[\"最小值\",{\"1\":{\"80\":2}}],[\"最大值\",{\"1\":{\"79\":1,\"80\":1}}],[\"最早的\",{\"1\":{\"27\":2}}],[\"或运算\",{\"1\":{\"159\":1}}],[\"或达到上限\",{\"1\":{\"123\":1}}],[\"或者在主从复制的时候延迟过高\",{\"1\":{\"188\":1}}],[\"或者在热点数据准备要过期前\",{\"1\":{\"118\":1}}],[\"或者锁的有效期不足以对共享数据进行保护就可以释放锁\",{\"1\":{\"131\":1}}],[\"或者\",{\"1\":{\"79\":1}}],[\"或ⅱ\",{\"1\":{\"79\":1}}],[\"或\",{\"1\":{\"79\":3,\"129\":1,\"134\":2}}],[\"功能\",{\"1\":{\"79\":2,\"80\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":1}}],[\"工作地址\",{\"1\":{\"87\":1}}],[\"工作地点\",{\"1\":{\"79\":3}}],[\"工具\",{\"0\":{\"9\":1}}],[\"别名2\",{\"1\":{\"79\":1}}],[\"别名1\",{\"1\":{\"79\":1}}],[\"基础计网\",{\"0\":{\"473\":1}}],[\"基础ip\",{\"0\":{\"336\":1}}],[\"基于\",{\"0\":{\"319\":1}}],[\"基于字节流的\",{\"1\":{\"51\":1}}],[\"基本认识\",{\"0\":{\"346\":1}}],[\"基本概念\",{\"0\":{\"223\":1}}],[\"基本思路就是让客户端和多个redis节点去申请锁\",{\"1\":{\"131\":1}}],[\"基本查询\",{\"1\":{\"79\":1}}],[\"对拥塞控制改进\",{\"0\":{\"465\":1}}],[\"对11\",{\"1\":{\"268\":1}}],[\"对元组进行切片\",{\"1\":{\"267\":1}}],[\"对列表进行切片\",{\"1\":{\"267\":1}}],[\"对str进行切片\",{\"1\":{\"267\":2}}],[\"对list进行切片\",{\"1\":{\"267\":1}}],[\"对电话姓名进行排序\",{\"1\":{\"156\":1}}],[\"对于有序集合\",{\"1\":{\"154\":1}}],[\"对象中某些频繁变化的属性可以考虑抽出来用\",{\"1\":{\"148\":1}}],[\"对象头的\",{\"1\":{\"114\":1}}],[\"对应的页表就会越大\",{\"1\":{\"171\":1}}],[\"对应的\",{\"1\":{\"139\":1}}],[\"对应的值\",{\"1\":{\"139\":1,\"194\":1}}],[\"对读取的记录加独占锁\",{\"1\":{\"98\":1}}],[\"对读取的记录加共享锁\",{\"1\":{\"98\":1}}],[\"对查询的结果按年龄升序排序\",{\"1\":{\"80\":1}}],[\"对记录进行排序\",{\"1\":{\"79\":1}}],[\"对数据完整性和正确性不那么高的场景\",{\"1\":{\"51\":1}}],[\"去除前后指定字符\",{\"1\":{\"266\":1}}],[\"去除前后空格\",{\"1\":{\"266\":1}}],[\"去除重复记录\",{\"1\":{\"79\":1}}],[\"去除重复的记录\",{\"1\":{\"79\":1}}],[\"去买票\",{\"1\":{\"262\":1,\"268\":1}}],[\"去找到这个key对应的过期时间和系统时间进行比较\",{\"1\":{\"189\":1}}],[\"去掉字符串头部和尾部的空格\",{\"1\":{\"84\":1}}],[\"去掉bearer前缀\",{\"1\":{\"38\":1}}],[\"倪浩\",{\"1\":{\"77\":1}}],[\"条件列表\",{\"1\":{\"79\":1}}],[\"条件查询\",{\"1\":{\"79\":1}}],[\"条件\",{\"1\":{\"77\":2,\"80\":1}}],[\"条记录后\",{\"1\":{\"21\":1}}],[\"条记录\",{\"1\":{\"21\":2}}],[\"给主节点上报自身当前的复制偏移量\",{\"1\":{\"177\":1}}],[\"给缓存加上一个较短的过期时间\",{\"1\":{\"122\":1}}],[\"给更新缓存的线程再加一个用途用来频繁的去检测缓存是否有效\",{\"1\":{\"116\":1}}],[\"给全部的字段添加数据\",{\"1\":{\"77\":1}}],[\"给指定字段添加数据\",{\"1\":{\"77\":1}}],[\"例表的长度\",{\"1\":{\"261\":1}}],[\"例如append\",{\"1\":{\"138\":1}}],[\"例如在每一个完整的数据之后加一个特殊字符\",{\"1\":{\"56\":1}}],[\"例子\",{\"1\":{\"77\":4,\"79\":3}}],[\"值对\",{\"1\":{\"184\":1}}],[\"值\",{\"1\":{\"180\":1}}],[\"值2\",{\"1\":{\"77\":8}}],[\"值1\",{\"1\":{\"77\":8}}],[\"撤销权限\",{\"1\":{\"73\":1}}],[\"授权时\",{\"1\":{\"73\":1}}],[\"授权模式\",{\"0\":{\"44\":1}}],[\"授予权限\",{\"1\":{\"73\":1}}],[\"创建子进程时\",{\"1\":{\"169\":1}}],[\"创建一个管道\",{\"1\":{\"129\":1}}],[\"创建表\",{\"1\":{\"90\":2}}],[\"创建数据库\",{\"1\":{\"73\":1}}],[\"创建用户能在任意主机上访问\",{\"1\":{\"73\":1}}],[\"创建用户只能在当前主机上访问\",{\"1\":{\"73\":1}}],[\"创建用户\",{\"1\":{\"73\":1}}],[\"表达现实生活中的逻辑\",{\"1\":{\"268\":1}}],[\"表明希望成为\",{\"1\":{\"180\":1}}],[\"表明有事务想在某个区间插入新记录\",{\"1\":{\"102\":1}}],[\"表级别的独占锁\",{\"1\":{\"94\":1}}],[\"表级别的共享锁\",{\"1\":{\"94\":1}}],[\"表级锁定\",{\"0\":{\"93\":1}}],[\"表的员工姓名和工作地址\",{\"1\":{\"87\":1}}],[\"表名values\",{\"1\":{\"77\":1}}],[\"表名\",{\"1\":{\"73\":2,\"77\":5,\"79\":5,\"80\":4,\"90\":4}}],[\"表\",{\"1\":{\"73\":2}}],[\"表示将宽度控制为5\",{\"1\":{\"268\":1}}],[\"表示将整数的宽度控制在5位\",{\"1\":{\"268\":1}}],[\"表示复制进度\",{\"1\":{\"174\":1}}],[\"表示事务失败\",{\"1\":{\"129\":1}}],[\"表示客户端希望下一次接受的序列号\",{\"1\":{\"63\":1}}],[\"表示客户端请求连接\",{\"1\":{\"61\":1}}],[\"表示数据在数据流中的位置\",{\"1\":{\"55\":1}}],[\"表示在跳过\",{\"1\":{\"21\":1}}],[\"表示要跳过的记录数\",{\"1\":{\"21\":1}}],[\"表示从结果集的哪一条记录开始返回数据\",{\"1\":{\"20\":1}}],[\"说明这个表中是有锁的\",{\"1\":{\"96\":1}}],[\"说明\",{\"1\":{\"73\":1,\"90\":1,\"268\":1}}],[\"说明从\",{\"1\":{\"58\":1}}],[\"权限列表\",{\"1\":{\"73\":2}}],[\"权限\",{\"1\":{\"73\":1}}],[\"密码123456\",{\"1\":{\"73\":2}}],[\"密码\",{\"1\":{\"73\":1}}],[\"为什么每次建立tcp连接\",{\"0\":{\"432\":1}}],[\"为什么每次建立tcp链接的时候\",{\"0\":{\"426\":1}}],[\"为什么tcp层还需要mss\",{\"0\":{\"428\":1}}],[\"为什么是三次握手\",{\"0\":{\"425\":1}}],[\"为什么半连接队列要设计成哈希表\",{\"0\":{\"369\":1}}],[\"为什么需要\",{\"0\":{\"350\":1}}],[\"为什么需要三次握手而不是四次\",{\"0\":{\"70\":1}}],[\"为什么\",{\"0\":{\"349\":1}}],[\"为什么断网了还能ping通127\",{\"0\":{\"334\":1}}],[\"为此增加了定期删除循环流程的时间上限\",{\"1\":{\"191\":1}}],[\"为有序集合key中元素member的分值加上increment\",{\"1\":{\"155\":1}}],[\"为哈希表key中field键的值加上增量n\",{\"1\":{\"147\":1}}],[\"为了保证定期删除不会出现循环过度\",{\"1\":{\"191\":1}}],[\"为了保证数据一致性\",{\"1\":{\"174\":1}}],[\"为了避免在网络恢复时\",{\"1\":{\"176\":1}}],[\"为了避免从服务器过多\",{\"1\":{\"175\":1}}],[\"为了避免不断轮询队列\",{\"1\":{\"134\":1}}],[\"为了解决这种数据不一致问题\",{\"1\":{\"169\":1}}],[\"为了减少对服务的影响\",{\"1\":{\"117\":1}}],[\"为结果集中的每一行分配一个排名\",{\"1\":{\"27\":1}}],[\"为结果集中的每一行分配一个唯一的序号\",{\"1\":{\"27\":1}}],[\"被设置为5d\",{\"1\":{\"268\":1}}],[\"被载入到数据库\",{\"1\":{\"193\":1}}],[\"被保存到新的\",{\"1\":{\"193\":1}}],[\"被其他客户端修改过\",{\"1\":{\"129\":1}}],[\"被\",{\"1\":{\"97\":1}}],[\"被动关闭连接\",{\"1\":{\"69\":1}}],[\"被后面相同四元组的连接错误的接收\",{\"1\":{\"69\":1}}],[\"防止在处理过程中造成数据丢失\",{\"1\":{\"144\":1}}],[\"防止历史连接中的数据\",{\"1\":{\"69\":1}}],[\"防止并发访问时的数据竞争\",{\"1\":{\"39\":1}}],[\"状态过多\",{\"0\":{\"379\":1}}],[\"状态的原因有哪些\",{\"0\":{\"353\":1,\"354\":1}}],[\"状态和操作的统一性\",{\"1\":{\"71\":1}}],[\"状态\",{\"0\":{\"350\":1,\"453\":1},\"1\":{\"68\":1,\"89\":1}}],[\"主库在\",{\"1\":{\"194\":1}}],[\"主库会模拟一个del命令\",{\"1\":{\"177\":1}}],[\"主节点会限制写操作\",{\"1\":{\"188\":1}}],[\"主节点会将从节点列表发给哨兵\",{\"1\":{\"182\":1}}],[\"主节点网络波动\",{\"1\":{\"187\":1}}],[\"主节点\",{\"1\":{\"181\":1}}],[\"主节点默认每隔\",{\"1\":{\"177\":1}}],[\"主\",{\"0\":{\"181\":1}}],[\"主观下线\",{\"1\":{\"179\":2}}],[\"主从切换完成后\",{\"1\":{\"181\":1}}],[\"主从故障转移操作包含以下四个步骤\",{\"1\":{\"181\":1}}],[\"主从节点发送的心态间隔是不一样的\",{\"1\":{\"177\":1}}],[\"主从服务器都有各自的偏移量\",{\"1\":{\"176\":1}}],[\"主从服务器会采用增量复制继续同步\",{\"1\":{\"176\":1}}],[\"主从复制\",{\"0\":{\"173\":1}}],[\"主服务器\",{\"1\":{\"193\":1}}],[\"主服务器根据自己的master\",{\"1\":{\"176\":1}}],[\"主服务器使用master\",{\"1\":{\"176\":1}}],[\"主服务器频繁生成子进程或者在大数据量的情况下发生阻塞\",{\"1\":{\"175\":1}}],[\"主服务器会将replication\",{\"1\":{\"174\":1}}],[\"主服务器会在下面三个时间段内的写操作\",{\"1\":{\"174\":1}}],[\"主服务器发送rdb文件给从服务器期间\",{\"1\":{\"174\":1}}],[\"主服务器生成rdb期间\",{\"1\":{\"174\":1}}],[\"主服务器用bgsave命令来异步生成rdb\",{\"1\":{\"174\":1}}],[\"主服务器在接收之后\",{\"1\":{\"174\":1}}],[\"主服务器上可以进行读写操作\",{\"1\":{\"173\":1}}],[\"主程在接受之后会将\",{\"1\":{\"169\":1}}],[\"主进程可以继续处理命令请求\",{\"1\":{\"169\":1}}],[\"主线程在执行\",{\"1\":{\"171\":1}}],[\"主线程会把\",{\"1\":{\"162\":1}}],[\"主线程\",{\"1\":{\"162\":1,\"171\":1}}],[\"主要体现在事务中的命令要么全部执行\",{\"1\":{\"129\":1}}],[\"主要依赖于\",{\"1\":{\"127\":1}}],[\"主要是dba\",{\"1\":{\"73\":1}}],[\"主表字段\",{\"1\":{\"90\":1}}],[\"主表名\",{\"1\":{\"90\":1}}],[\"主表列名\",{\"1\":{\"90\":2}}],[\"主表\",{\"1\":{\"90\":2}}],[\"主键\",{\"1\":{\"89\":1}}],[\"主键是一行数据的唯一标识\",{\"1\":{\"89\":1}}],[\"主键约束\",{\"1\":{\"89\":1}}],[\"主机名可以使用\",{\"1\":{\"73\":1}}],[\"主机名\",{\"1\":{\"73\":6}}],[\"主动关闭连接的\",{\"1\":{\"68\":1}}],[\"主题\",{\"1\":{\"40\":1}}],[\"等同于将序列反转了\",{\"1\":{\"267\":1}}],[\"等到全部记录完后\",{\"1\":{\"168\":1}}],[\"等待的时间是\",{\"0\":{\"349\":1}}],[\"等待一段时间后尝试获取锁\",{\"1\":{\"125\":1}}],[\"等待上层应用读取\",{\"1\":{\"57\":1}}],[\"等插入语句执行完成后\",{\"1\":{\"97\":1}}],[\"等于\",{\"1\":{\"79\":1}}],[\"等服务端不再发送数据时\",{\"1\":{\"67\":1}}],[\"服务进程时\",{\"0\":{\"376\":1}}],[\"服务熔断请求限流\",{\"1\":{\"117\":1}}],[\"服务端突然挂怎么办\",{\"0\":{\"455\":1}}],[\"服务端没有调用listen\",{\"0\":{\"366\":1}}],[\"服务端接收到报文之后进入close状态\",{\"1\":{\"68\":1}}],[\"服务端可能还有数据需要处理和发送\",{\"1\":{\"67\":1}}],[\"服务端进入close\",{\"1\":{\"66\":1}}],[\"服务端收到该报文\",{\"1\":{\"66\":1}}],[\"服务器域名与\",{\"0\":{\"484\":1}}],[\"服务器出现大量\",{\"0\":{\"353\":1,\"354\":1}}],[\"服务器主动推送资源\",{\"0\":{\"294\":1}}],[\"服务器频繁的使用全量同步的方式\",{\"1\":{\"176\":1}}],[\"服务器执行\",{\"1\":{\"174\":1}}],[\"服务器发生宕机了\",{\"1\":{\"166\":1}}],[\"服务器\",{\"0\":{\"497\":1},\"1\":{\"129\":1}}],[\"服务器处于syn\",{\"1\":{\"62\":1}}],[\"服务器处于listen\",{\"1\":{\"61\":1}}],[\"服务器也会选择一个初始序列号用于标识服务器到客户端的数据流\",{\"1\":{\"62\":1}}],[\"服务器同意建立连接\",{\"1\":{\"62\":1}}],[\"work\",{\"0\":{\"499\":1}}],[\"world\",{\"1\":{\"269\":2}}],[\"websocket是什么\",{\"0\":{\"321\":1}}],[\"weights\",{\"1\":{\"155\":1}}],[\"w\",{\"1\":{\"269\":2}}],[\"while循环\",{\"1\":{\"262\":1,\"268\":1}}],[\"while和for\",{\"0\":{\"262\":1}}],[\"while\",{\"1\":{\"261\":3,\"262\":3,\"263\":1,\"268\":3}}],[\"when\",{\"1\":{\"24\":3,\"87\":6}}],[\"where>聚合函数>having\",{\"1\":{\"80\":1}}],[\"where不能对聚合函数进行判断\",{\"1\":{\"80\":1}}],[\"where是分组之前进行过滤\",{\"1\":{\"80\":1}}],[\"where与having区别\",{\"1\":{\"80\":1}}],[\"where\",{\"1\":{\"17\":1,\"18\":1,\"19\":1,\"77\":4,\"79\":8,\"80\":7}}],[\"watch\",{\"1\":{\"129\":4}}],[\"watch来实现\",{\"1\":{\"129\":1}}],[\"wait和time\",{\"0\":{\"348\":1}}],[\"wait时间太短\",{\"1\":{\"69\":1}}],[\"wait状态的tcp接收到syn报文会怎么样\",{\"0\":{\"450\":1}}],[\"wait状态的意义\",{\"0\":{\"69\":1}}],[\"wait状态或者time\",{\"1\":{\"69\":1}}],[\"wait状态标识一个连接已经完成了关闭过程\",{\"1\":{\"69\":1}}],[\"wait状态\",{\"1\":{\"66\":1}}],[\"wait\",{\"0\":{\"348\":1,\"349\":1,\"350\":1,\"351\":1,\"352\":1,\"353\":1,\"354\":1,\"379\":1,\"453\":1},\"1\":{\"65\":1,\"66\":1,\"68\":2}}],[\"write\",{\"1\":{\"94\":1,\"96\":1,\"269\":2}}],[\"withscores\",{\"1\":{\"155\":3}}],[\"with\",{\"1\":{\"73\":2,\"92\":1,\"269\":2}}],[\"向下取整\",{\"1\":{\"85\":1}}],[\"向上取整\",{\"1\":{\"85\":1}}],[\"向客户端发送一个ack报文\",{\"1\":{\"66\":1}}],[\"向服务器发送一个fin报文\",{\"1\":{\"65\":1}}],[\"向对方发送相应的字节数\",{\"1\":{\"57\":1}}],[\"以j结尾表示复数布尔\",{\"1\":{\"268\":1}}],[\"以\",{\"1\":{\"193\":1}}],[\"以此来降低系统对于单主节点的依赖\",{\"1\":{\"184\":1}}],[\"以及传输rdb占用服务器流量\",{\"1\":{\"175\":1}}],[\"以及ack\",{\"1\":{\"63\":1}}],[\"以二进制的方式写入磁盘\",{\"1\":{\"165\":1}}],[\"以字节为单位\",{\"1\":{\"159\":1}}],[\"以内的前5个员工信息\",{\"1\":{\"80\":1}}],[\"以内的姓名为三个字的员工\",{\"1\":{\"80\":1}}],[\"以确保数据的有序性\",{\"1\":{\"55\":1}}],[\"半连接状态\",{\"1\":{\"62\":1}}],[\"标识符命名中\",{\"1\":{\"268\":1}}],[\"标识符命名规则\",{\"1\":{\"268\":1}}],[\"标识的tcp报文之后\",{\"1\":{\"63\":1}}],[\"标识的tcp报文\",{\"1\":{\"62\":1}}],[\"标记上面那个缓冲区的同步进度\",{\"1\":{\"176\":1}}],[\"标志的tcp报文到服务器\",{\"1\":{\"61\":1}}],[\"会断开连接吗\",{\"0\":{\"453\":1}}],[\"会断开与这个节点的连接\",{\"1\":{\"177\":1}}],[\"会导致端口资源耗尽而无法建立新的连接吗\",{\"0\":{\"379\":1}}],[\"会有一个cookies队列吗\",{\"0\":{\"370\":1}}],[\"会话复用\",{\"0\":{\"309\":1}}],[\"会进行小数的四舍五入\",{\"1\":{\"268\":1}}],[\"会在\",{\"1\":{\"194\":1}}],[\"会\",{\"1\":{\"193\":1}}],[\"会对\",{\"1\":{\"193\":2}}],[\"会被尽快删除\",{\"1\":{\"192\":1}}],[\"会去查询key是否过期\",{\"1\":{\"190\":1}}],[\"会发送到\",{\"1\":{\"182\":1}}],[\"会向其他哨兵发起命令\",{\"1\":{\"179\":1}}],[\"会向服务器发送一个带有ack标志的确认报文段\",{\"1\":{\"63\":1}}],[\"会把物理内存复制一份\",{\"1\":{\"171\":1}}],[\"会创建一个子进程来生成\",{\"1\":{\"170\":1}}],[\"会阻塞主线程\",{\"1\":{\"170\":1}}],[\"会启动\",{\"1\":{\"162\":1}}],[\"会存储在该key中\",{\"1\":{\"159\":1}}],[\"会使用跳表作为\",{\"1\":{\"154\":1}}],[\"会使用压缩列表作为\",{\"1\":{\"154\":1}}],[\"会使用压缩列表作为list\",{\"1\":{\"142\":1,\"146\":1}}],[\"会使用双向链表作为\",{\"1\":{\"142\":1}}],[\"会使用随机采样的方式来淘汰数据它是随机取\",{\"1\":{\"113\":1}}],[\"会返回fullresync\",{\"1\":{\"174\":1}}],[\"会返回\",{\"1\":{\"129\":1}}],[\"会清空事务队列\",{\"1\":{\"129\":1}}],[\"会将一个从节点切换为主节点\",{\"1\":{\"178\":1}}],[\"会将一部分数据给淘汰掉\",{\"1\":{\"116\":1}}],[\"会将后续的命令进入队列\",{\"1\":{\"129\":1}}],[\"会将它放到缓冲区\",{\"1\":{\"55\":1}}],[\"会很耗时\",{\"1\":{\"113\":1}}],[\"会选择淘汰最近最少使用的数据\",{\"1\":{\"113\":1}}],[\"会为被\",{\"1\":{\"97\":1}}],[\"会加一个表级别的\",{\"1\":{\"97\":1}}],[\"会造成严重的业务问题\",{\"1\":{\"95\":1}}],[\"会自动把所有哈希槽平均分布到集群节点上\",{\"1\":{\"184\":1}}],[\"会自动加上mdl写锁\",{\"1\":{\"95\":1}}],[\"会自动给这个表加上mdl读锁\",{\"1\":{\"95\":1}}],[\"会回复一个带有syn和ack\",{\"1\":{\"62\":1}}],[\"99\",{\"1\":{\"265\":4,\"268\":1}}],[\"99乘法表\",{\"1\":{\"262\":1,\"268\":1}}],[\"98\",{\"1\":{\"87\":1,\"265\":1}}],[\"90\",{\"1\":{\"87\":1}}],[\"95\",{\"1\":{\"87\":1}}],[\"9\",{\"0\":{\"59\":1,\"370\":1},\"1\":{\"85\":1,\"184\":2,\"261\":1,\"268\":4}}],[\"确定要查询的表\",{\"1\":{\"79\":1}}],[\"确认号\",{\"1\":{\"62\":1,\"63\":1}}],[\"确认了新的数据\",{\"1\":{\"58\":1}}],[\"确保所有命令在执行过程中不被其他命令打断\",{\"1\":{\"129\":1}}],[\"确保连接的稳定和可靠\",{\"1\":{\"52\":1}}],[\"确保每个类别都出现在结果集中\",{\"1\":{\"24\":1}}],[\"把传输工作给操作系统中的协议栈\",{\"0\":{\"486\":1}}],[\"把数据刷到硬盘里\",{\"1\":{\"269\":1}}],[\"把日志文件写入磁盘的时候\",{\"1\":{\"166\":1}}],[\"把从数据库中读到的年龄为\",{\"1\":{\"123\":1}}],[\"把\",{\"1\":{\"58\":1}}],[\"把密钥写进去\",{\"1\":{\"40\":2}}],[\"个偶数\",{\"1\":{\"262\":1,\"268\":1}}],[\"个节点\",{\"1\":{\"184\":1}}],[\"个后台线程\",{\"1\":{\"162\":1}}],[\"个\",{\"1\":{\"142\":1,\"146\":1,\"184\":1,\"191\":2}}],[\"个元素\",{\"1\":{\"142\":1}}],[\"个哈希值对位图数组的长度取模\",{\"1\":{\"119\":1}}],[\"个哈希值\",{\"1\":{\"119\":1}}],[\"个哈希函数分别对数据做哈希计算\",{\"1\":{\"119\":1}}],[\"个哈希函数\",{\"1\":{\"119\":1}}],[\"个操作完成标记\",{\"1\":{\"119\":1}}],[\"个值\",{\"1\":{\"113\":1}}],[\"个数据包被收到了\",{\"1\":{\"58\":1}}],[\"个人格言\",{\"0\":{\"16\":1}}],[\"个人信息\",{\"0\":{\"2\":1}}],[\"进程的上下文切换\",{\"0\":{\"259\":1}}],[\"进程的控制\",{\"0\":{\"258\":1}}],[\"进程的控制结构\",{\"0\":{\"257\":1}}],[\"进程的状态\",{\"0\":{\"256\":1}}],[\"进程\",{\"0\":{\"255\":1}}],[\"进而会降低\",{\"1\":{\"113\":1}}],[\"进行过期检查\",{\"1\":{\"193\":1}}],[\"进行检查\",{\"1\":{\"191\":1}}],[\"进行了修改\",{\"1\":{\"171\":1}}],[\"进行缓存预热\",{\"1\":{\"116\":1}}],[\"进行内存淘汰时\",{\"1\":{\"113\":1}}],[\"进行数据淘汰的策略\",{\"0\":{\"109\":1}}],[\"进行比较\",{\"1\":{\"77\":2}}],[\"进行通配\",{\"1\":{\"73\":1}}],[\"进行分区\",{\"1\":{\"27\":2}}],[\"进入快恢复算法\",{\"1\":{\"58\":1}}],[\"拥塞窗口\",{\"1\":{\"58\":1}}],[\"拥塞窗口加1\",{\"1\":{\"58\":1}}],[\"拥塞发生\",{\"0\":{\"404\":1},\"1\":{\"58\":1}}],[\"拥塞避免\",{\"0\":{\"403\":1},\"1\":{\"58\":1}}],[\"拥塞控制\",{\"0\":{\"58\":1,\"401\":1}}],[\"慢启动门限等于当前拥塞窗口\",{\"1\":{\"58\":1}}],[\"慢启动门限变成拥塞窗口\",{\"1\":{\"58\":1}}],[\"慢启动\",{\"0\":{\"402\":1},\"1\":{\"58\":1}}],[\"滑动窗口\",{\"0\":{\"57\":1,\"407\":1}}],[\"77\",{\"1\":{\"265\":3}}],[\"76\",{\"1\":{\"87\":1}}],[\"7\",{\"0\":{\"57\":1,\"368\":1,\"379\":1,\"496\":1},\"1\":{\"146\":1,\"154\":1,\"261\":1,\"268\":2}}],[\"由任意数量的字符组成\",{\"1\":{\"268\":1}}],[\"由事件处理器自动执行\",{\"1\":{\"192\":1}}],[\"由消费者逐一处理\",{\"1\":{\"134\":1}}],[\"由后端自主更新\",{\"0\":{\"124\":1}}],[\"由后台异步更新缓存\",{\"1\":{\"118\":1}}],[\"由后台自主的去更新缓存数据\",{\"1\":{\"116\":1}}],[\"由于元组不可修改\",{\"1\":{\"263\":1}}],[\"由于大\",{\"1\":{\"171\":1}}],[\"由于永不执行\",{\"1\":{\"171\":1}}],[\"由于是异步执行\",{\"1\":{\"171\":1}}],[\"由于前半部分是\",{\"1\":{\"171\":1}}],[\"由于和执行操作命令在同一个线程\",{\"1\":{\"170\":1}}],[\"由于这是两步操作\",{\"1\":{\"123\":1}}],[\"由于业务需求变更\",{\"1\":{\"84\":1}}],[\"由于需要输出null\",{\"1\":{\"19\":1}}],[\"由头部和消息体组成\",{\"1\":{\"56\":1}}],[\"固定数据长度\",{\"1\":{\"56\":1}}],[\"一问一答\",{\"0\":{\"500\":1}}],[\"一端断电和进程崩溃有什么区别\",{\"0\":{\"456\":1}}],[\"一次读取一行\",{\"1\":{\"269\":1}}],[\"一行代码\",{\"1\":{\"264\":1}}],[\"一旦完成封装就不可以被修改\",{\"1\":{\"263\":1}}],[\"一直没有被访问\",{\"1\":{\"190\":1}}],[\"一直不释放锁\",{\"1\":{\"116\":1}}],[\"一直到事务提交才会释放锁\",{\"1\":{\"95\":1}}],[\"一般推荐utf\",{\"1\":{\"269\":1}}],[\"一般对象用\",{\"1\":{\"148\":1}}],[\"一般被当作缓存来使用\",{\"1\":{\"105\":1}}],[\"一般适用于\",{\"1\":{\"92\":1}}],[\"一样也是在插入数据的时候\",{\"1\":{\"97\":1}}],[\"一致\",{\"1\":{\"90\":1}}],[\"一线城市\",{\"1\":{\"87\":3}}],[\"一个浮点数类型的占位符\",{\"1\":{\"268\":1}}],[\"一个整数类型的占位符\",{\"1\":{\"268\":1}}],[\"一个字符串类型的占位符\",{\"1\":{\"268\":2}}],[\"一个切片集群共有16384个哈希槽\",{\"1\":{\"184\":1}}],[\"一个是排序值\",{\"1\":{\"154\":1}}],[\"一个是有序集合的元素值\",{\"1\":{\"154\":1}}],[\"一个事务在插入一条记录的时候\",{\"1\":{\"102\":1}}],[\"一个sql语句可以查询到什么\",{\"0\":{\"82\":1}}],[\"一个sql语句\",{\"0\":{\"81\":1}}],[\"一个完整的数据包可能会被拆分成多个小的数据包\",{\"1\":{\"56\":1}}],[\"一些实时游戏\",{\"1\":{\"51\":1}}],[\"所储存的字符串值的长度\",{\"1\":{\"139\":1}}],[\"所有的命令会按顺序执行\",{\"1\":{\"129\":1}}],[\"所有打进来的请求都会直接到db上\",{\"1\":{\"119\":1}}],[\"所有权限\",{\"1\":{\"73\":1}}],[\"所谓字节流就是一串没有边界的二进制数据\",{\"1\":{\"56\":1}}],[\"所以可以省略不写\",{\"1\":{\"267\":1}}],[\"所以可能会出现第二个操作失败的情况\",{\"1\":{\"123\":1}}],[\"所以只有index\",{\"1\":{\"263\":1}}],[\"所以一般来说\",{\"1\":{\"193\":1}}],[\"所以一般适用于上传下载\",{\"1\":{\"51\":1}}],[\"所以过期键不会对载入\",{\"1\":{\"193\":1}}],[\"所以此策略只会使用很少的系统资源\",{\"1\":{\"190\":1}}],[\"所以大\",{\"1\":{\"171\":2}}],[\"所以如果写入rdb\",{\"1\":{\"170\":1}}],[\"所以当\",{\"1\":{\"166\":1}}],[\"所以就可以使用lua脚本\",{\"1\":{\"140\":1}}],[\"所以embsti编码的字符串对象实际上是只读的\",{\"1\":{\"138\":1}}],[\"所以不会导致缓冲区溢出的问题\",{\"1\":{\"138\":1}}],[\"所以复杂度为\",{\"1\":{\"138\":1}}],[\"所以获取长度的复杂度为\",{\"1\":{\"138\":1}}],[\"所以他是可以保证数据一致性的\",{\"1\":{\"123\":1}}],[\"所以很难出现请求a的缓存还没写入请求b就已经更新数据的情况\",{\"1\":{\"123\":1}}],[\"所以在查询的时候布隆过滤器说这个数据存在\",{\"1\":{\"119\":1}}],[\"所以导致缓存和数据库中都没有数据\",{\"1\":{\"119\":1}}],[\"所以\",{\"1\":{\"114\":1,\"138\":1,\"190\":1,\"192\":1}}],[\"所以会选择将这个数据包之后的所有数据包全部重传一遍\",{\"1\":{\"54\":1}}],[\"所以常用在对数据实时性要求较高\",{\"1\":{\"51\":1}}],[\"所以将查询设为一个子查询\",{\"1\":{\"19\":1}}],[\"粘包问题\",{\"0\":{\"56\":1}}],[\"又称d\",{\"1\":{\"54\":1}}],[\"告知对方接收了哪些数据\",{\"1\":{\"54\":1}}],[\"容易造成资源的浪费\",{\"1\":{\"54\":1}}],[\"几个\",{\"1\":{\"54\":1}}],[\"几个数据包丢失时\",{\"1\":{\"54\":1}}],[\"无分类地址cidr\",{\"0\":{\"342\":1}}],[\"无队头阻塞\",{\"0\":{\"300\":1}}],[\"无序key\",{\"1\":{\"268\":1}}],[\"无序不重复集合\",{\"1\":{\"268\":1}}],[\"无return会返回一个none值\",{\"1\":{\"264\":1}}],[\"无疑会对服务器的响应时间和吞吐量造成影响\",{\"1\":{\"192\":1}}],[\"无法修改\",{\"1\":{\"266\":1}}],[\"无法设置模拟锁\",{\"1\":{\"125\":1}}],[\"无法解决缓存污染问题\",{\"1\":{\"113\":1}}],[\"无法精准定位是哪一个\",{\"1\":{\"54\":1}}],[\"无连接\",{\"1\":{\"51\":1}}],[\"发布者\",{\"1\":{\"181\":1}}],[\"发现主节点挂掉之后\",{\"1\":{\"178\":1}}],[\"发生在三次握手的哪一步\",{\"0\":{\"364\":1}}],[\"发生冲突\",{\"1\":{\"96\":1}}],[\"发生快速重传的拥塞发生算法\",{\"1\":{\"58\":1}}],[\"发生超时重传的拥塞发生算法\",{\"1\":{\"58\":1}}],[\"发送方的滑动窗口\",{\"0\":{\"409\":1}}],[\"发送方根据接收方的窗口变化\",{\"1\":{\"57\":1}}],[\"发送方根据这一字段就可以精准定位这个丢失包\",{\"1\":{\"54\":1}}],[\"发送fin报文\",{\"1\":{\"67\":1}}],[\"发送端就可以跟据接收端和本端窗口大小\",{\"1\":{\"57\":1}}],[\"发送一堆数据包之后\",{\"1\":{\"54\":1}}],[\"发行者\",{\"1\":{\"40\":1}}],[\"重复添加等同于覆盖原有数据\",{\"1\":{\"265\":1}}],[\"重复三次收到相同的ack包\",{\"1\":{\"54\":1}}],[\"重写造成任何影响\",{\"1\":{\"193\":1}}],[\"重写时\",{\"1\":{\"193\":1}}],[\"重写阶段\",{\"1\":{\"193\":2}}],[\"重写日志时\",{\"1\":{\"171\":1}}],[\"重写缓冲区里的增量命令会以\",{\"1\":{\"171\":1}}],[\"重写缓冲区\",{\"1\":{\"169\":3}}],[\"重写\",{\"1\":{\"169\":1}}],[\"重写期间\",{\"1\":{\"169\":1}}],[\"重写过程\",{\"0\":{\"169\":1}}],[\"重启\",{\"0\":{\"376\":1},\"1\":{\"171\":1}}],[\"重启后不会丢失\",{\"1\":{\"134\":1}}],[\"重启的时候后重新加载\",{\"1\":{\"105\":1}}],[\"重要\",{\"1\":{\"131\":1}}],[\"重传丢失的数据包\",{\"1\":{\"58\":1}}],[\"重传数据包\",{\"1\":{\"54\":1}}],[\"重传这个数据包\",{\"1\":{\"54\":1}}],[\"重传机制有哪些\",{\"0\":{\"54\":1}}],[\"通知给客户端\",{\"1\":{\"181\":1}}],[\"通常使用\",{\"1\":{\"133\":1}}],[\"通常基于order\",{\"1\":{\"27\":1}}],[\"通配\",{\"1\":{\"73\":1}}],[\"通过dns获取到ip后\",{\"0\":{\"486\":1}}],[\"通过下标索引取值\",{\"1\":{\"266\":1}}],[\"通过限制删除操作执行的时长和频率\",{\"1\":{\"191\":1}}],[\"通过发布者\",{\"1\":{\"181\":1}}],[\"通过多个哨兵节点一起判断\",{\"1\":{\"179\":1}}],[\"通过\",{\"1\":{\"134\":1,\"181\":1}}],[\"通过消息队列的形式发送一条消息给后台更新缓存\",{\"1\":{\"116\":1}}],[\"通过数据库的函数\",{\"1\":{\"85\":1}}],[\"通过window字段告知对方本端的缓冲区大小\",{\"1\":{\"57\":1}}],[\"通过自定义协议\",{\"1\":{\"56\":1}}],[\"通过确认应答机制以及重传机制来保证数据传输的可靠\",{\"1\":{\"53\":1}}],[\"比例小于\",{\"1\":{\"191\":1}}],[\"比set多另一个排序分值score\",{\"1\":{\"154\":1}}],[\"比如集群中有\",{\"1\":{\"184\":1}}],[\"比如应用一次读取了大量的数据\",{\"1\":{\"113\":1}}],[\"比如\",{\"1\":{\"84\":1}}],[\"比如音视频通话\",{\"1\":{\"51\":1}}],[\"比较多的情况下\",{\"1\":{\"192\":1}}],[\"比较运算符\",{\"1\":{\"79\":1}}],[\"比较含退格的字符串\",{\"0\":{\"29\":1},\"1\":{\"29\":1}}],[\"面向报文的\",{\"1\":{\"51\":1}}],[\"面向连接\",{\"1\":{\"51\":1}}],[\"邮件发送等场景\",{\"1\":{\"51\":1}}],[\"可无序记录一堆key\",{\"1\":{\"268\":1}}],[\"可无序记录一堆不重复的python数据集合\",{\"1\":{\"268\":1}}],[\"可有序记录一堆不可变的python数据集合\",{\"1\":{\"268\":1}}],[\"可有序记录一堆数据\",{\"1\":{\"268\":1}}],[\"可通过参数repl\",{\"1\":{\"177\":1}}],[\"可由\",{\"1\":{\"142\":2,\"146\":2}}],[\"可能会占用相当一部分\",{\"1\":{\"192\":1}}],[\"可能阻塞其他操作\",{\"1\":{\"166\":1}}],[\"可能锁已被占用\",{\"1\":{\"125\":1}}],[\"可能导致数据错乱或者连接错误\",{\"1\":{\"69\":1}}],[\"可以修改\",{\"1\":{\"270\":1}}],[\"可以容纳不同类型的数据\",{\"1\":{\"270\":1}}],[\"可以容纳多个数据\",{\"1\":{\"270\":1}}],[\"可以给函数加一个说明文档\",{\"1\":{\"264\":1}}],[\"可以保证过期\",{\"1\":{\"192\":1}}],[\"可以监控到主从节点切换过程中发生的各个重要事件\",{\"1\":{\"181\":1}}],[\"可以投给自己或投给别人\",{\"1\":{\"180\":1}}],[\"可以调整repl\",{\"1\":{\"176\":1}}],[\"可以使得数据更少的丢失\",{\"1\":{\"171\":1}}],[\"可以使用cluster\",{\"1\":{\"184\":1}}],[\"可以使用redlock\",{\"1\":{\"131\":1}}],[\"可以使用\",{\"1\":{\"127\":1,\"134\":1}}],[\"可以找到首次打卡时间\",{\"1\":{\"160\":1}}],[\"可以有多个\",{\"1\":{\"159\":1}}],[\"可以确保一个用户在中奖之后就把它踢出\",{\"1\":{\"152\":1}}],[\"可以确保一个用户只能点一次\",{\"1\":{\"152\":1}}],[\"可以确保队列中的任务在\",{\"1\":{\"134\":1}}],[\"可以采用主从集群\",{\"1\":{\"152\":1}}],[\"可以从头部或尾部向\",{\"1\":{\"142\":1}}],[\"可以设置一个过期时间\",{\"1\":{\"140\":1}}],[\"可以用开计算共同关注的好友\",{\"1\":{\"152\":1}}],[\"可以用来存储对象\",{\"1\":{\"148\":1}}],[\"可以用来表示加锁失败\",{\"1\":{\"140\":1}}],[\"可以用来表示加锁成功\",{\"1\":{\"140\":1}}],[\"可以用它来实现分布式锁\",{\"1\":{\"140\":1}}],[\"可以看到embstr和raw编码都会使用sds来保存值\",{\"1\":{\"138\":1}}],[\"可以实现异步队列的高可用性\",{\"1\":{\"134\":1}}],[\"可以实现高效的异步任务处理\",{\"1\":{\"133\":1}}],[\"可以启动多个消费者实例同时消费任务\",{\"1\":{\"134\":1}}],[\"可以将函数内部的变量成为全局变量\",{\"1\":{\"264\":1}}],[\"可以将需要延迟处理的任务放入队列中\",{\"1\":{\"134\":1}}],[\"可以将内存中的数据保存到磁盘中\",{\"1\":{\"105\":1}}],[\"可以通过\",{\"1\":{\"134\":1}}],[\"可以通过multi\",{\"1\":{\"129\":1}}],[\"可以通过分数\",{\"1\":{\"127\":1}}],[\"可以针对查询的数据\",{\"1\":{\"119\":1}}],[\"可以回到恢复之前的状态了\",{\"1\":{\"58\":1}}],[\"可以提高查询效率\",{\"1\":{\"24\":1}}],[\"可靠的\",{\"1\":{\"51\":1}}],[\"如数字11\",{\"1\":{\"268\":1}}],[\"如\",{\"1\":{\"268\":4}}],[\"如何理解tcp是基于字节流的协议\",{\"0\":{\"392\":1}}],[\"如何确定一个tcp连接\",{\"0\":{\"391\":1}}],[\"如何解决syn超时\",{\"0\":{\"357\":1}}],[\"如何解决的\",{\"0\":{\"315\":1}}],[\"如何优化tcp\",{\"0\":{\"381\":1}}],[\"如何优化\",{\"0\":{\"352\":1}}],[\"如何减少http响应的数据大小\",{\"0\":{\"286\":1}}],[\"如何减少http请求次数\",{\"0\":{\"285\":1}}],[\"如何写出让\",{\"0\":{\"197\":1}}],[\"如何组成哨兵集群\",{\"0\":{\"182\":1}}],[\"如何避免syn攻击\",{\"0\":{\"356\":1}}],[\"如何避免发送http请求\",{\"0\":{\"284\":1}}],[\"如何避免\",{\"0\":{\"376\":1},\"1\":{\"168\":1}}],[\"如何设计一个登录验签服务\",{\"0\":{\"47\":1}}],[\"如果已经建立了链接\",{\"0\":{\"454\":1,\"455\":1}}],[\"如果已过期的\",{\"1\":{\"191\":1}}],[\"如果需要自行转换类型\",{\"1\":{\"262\":1,\"268\":1}}],[\"如果数据库某个过期键还没被除\",{\"1\":{\"193\":1}}],[\"如果数据过去被访问多次\",{\"1\":{\"114\":1}}],[\"如果执行的太少\",{\"1\":{\"191\":1}}],[\"如果执行的太频繁\",{\"1\":{\"191\":1}}],[\"如果本轮检查的已过期\",{\"1\":{\"191\":1}}],[\"如果一个\",{\"1\":{\"190\":1}}],[\"如果一个事务获取了\",{\"1\":{\"101\":1}}],[\"如果过期删除\",{\"1\":{\"190\":1}}],[\"如果优先级和下标都相同\",{\"1\":{\"181\":1}}],[\"如果优先级相同\",{\"1\":{\"181\":1}}],[\"如果用完后就不能参与投票了\",{\"1\":{\"180\":1}}],[\"如果主从节点在规定时间内没有回复\",{\"1\":{\"179\":1}}],[\"如果主进程修改了已经存在\",{\"1\":{\"169\":1}}],[\"如果从节点数据丢失\",{\"1\":{\"177\":1}}],[\"如果判断出从服务器要读取的数据已经不存在repl\",{\"1\":{\"176\":1}}],[\"如果判断出从服务器要读取的数据还在repl\",{\"1\":{\"176\":1}}],[\"如果判断出是恶意请求就直接返回错误\",{\"1\":{\"119\":1}}],[\"如果创建完子进程后\",{\"1\":{\"171\":1}}],[\"如果页表很大\",{\"1\":{\"171\":1}}],[\"如果写入是一个大\",{\"1\":{\"171\":1}}],[\"如果开启混合持久化\",{\"1\":{\"171\":1}}],[\"如果当前的命令语法有问题\",{\"1\":{\"166\":1}}],[\"如果不在\",{\"1\":{\"189\":1}}],[\"如果不在就不需要再去访问数据库\",{\"1\":{\"119\":1}}],[\"如果不满足上面的情况\",{\"1\":{\"146\":1}}],[\"如果timeout=0则一直阻塞\",{\"1\":{\"143\":2}}],[\"如果列表的元素不满足上面的条件\",{\"1\":{\"142\":1}}],[\"如果列表的元素个数小于\",{\"1\":{\"142\":1,\"146\":1}}],[\"如果想要解除锁\",{\"1\":{\"140\":1}}],[\"如果字符串的长度增加需要重新分配内存时\",{\"1\":{\"138\":1}}],[\"如果空间不够会自动扩容\",{\"1\":{\"138\":1}}],[\"如果和超过半数以上的节点申请到锁\",{\"1\":{\"131\":1}}],[\"如果在\",{\"1\":{\"129\":1,\"189\":1}}],[\"如果在执行事务之前\",{\"1\":{\"129\":1}}],[\"如果\",{\"1\":{\"129\":1,\"140\":2,\"193\":2}}],[\"如果中有命令出现错误\",{\"1\":{\"129\":1}}],[\"如果任务未到期\",{\"1\":{\"127\":1}}],[\"如果他说不存在\",{\"1\":{\"119\":1}}],[\"如果此时有大量请求访问\",{\"1\":{\"116\":1}}],[\"如果锁状态是等待状态\",{\"1\":{\"102\":1}}],[\"如果有客户端访问从库时\",{\"1\":{\"194\":1}}],[\"如果有两个候选者\",{\"1\":{\"180\":1}}],[\"如果有两个请求中一个请求执行数据的更新\",{\"1\":{\"123\":1}}],[\"如果有一半以上的节点去ping一个节点没有pong回应\",{\"1\":{\"177\":1}}],[\"如果有序集合的元素不满足上面的条件\",{\"1\":{\"154\":1}}],[\"如果有序集合的元素个数小于\",{\"1\":{\"154\":1}}],[\"如果有大量数据被访问\",{\"1\":{\"113\":1}}],[\"如果有的话\",{\"1\":{\"102\":1}}],[\"如果有则设置子表中该外键值为null\",{\"1\":{\"90\":1}}],[\"如果有则不允许删除\",{\"1\":{\"90\":2}}],[\"如果有\",{\"1\":{\"90\":1}}],[\"如果有多表查询\",{\"1\":{\"79\":1}}],[\"如果未指定该字段的值\",{\"1\":{\"89\":1}}],[\"如果expr的值等于val1\",{\"1\":{\"87\":1}}],[\"如果val1为true\",{\"1\":{\"87\":1}}],[\"如果value1不为空\",{\"1\":{\"87\":1}}],[\"如果value为true\",{\"1\":{\"87\":1}}],[\"如果查询的是第一页数据\",{\"1\":{\"80\":1}}],[\"如果是多字段排序\",{\"1\":{\"80\":1}}],[\"如果年龄相同按入职时间降序排序\",{\"1\":{\"80\":1}}],[\"如果年龄相同\",{\"1\":{\"80\":1}}],[\"如果收到新数据的\",{\"1\":{\"58\":1}}],[\"如果再收到重复的\",{\"1\":{\"58\":1}}],[\"如果要实现不同域名下的cookie正常使用\",{\"0\":{\"46\":1}}],[\"如果桶中令牌数大于容量\",{\"1\":{\"39\":1}}],[\"如果没有time\",{\"1\":{\"69\":1}}],[\"如果没有前面的行\",{\"1\":{\"27\":1}}],[\"如果没有后续行\",{\"1\":{\"27\":1}}],[\"如果表中的行数少于2行\",{\"1\":{\"19\":1}}],[\"4+3j\",{\"1\":{\"268\":1}}],[\"4结束\",{\"1\":{\"267\":1}}],[\"43\",{\"1\":{\"90\":1}}],[\"48\",{\"1\":{\"90\":1}}],[\"45\",{\"1\":{\"80\":1,\"261\":1}}],[\"4\",{\"0\":{\"47\":1,\"54\":1,\"68\":1,\"149\":1,\"292\":1,\"317\":1,\"365\":1,\"376\":1,\"422\":1,\"487\":1,\"492\":1},\"1\":{\"54\":1,\"56\":1,\"58\":1,\"73\":1,\"77\":1,\"80\":1,\"85\":1,\"90\":1,\"110\":1,\"111\":1,\"113\":1,\"162\":1,\"165\":1,\"171\":1,\"191\":1,\"261\":5,\"263\":3,\"267\":5,\"268\":6,\"270\":6}}],[\"404\",{\"1\":{\"498\":1}}],[\"40岁\",{\"1\":{\"80\":2}}],[\"40\",{\"1\":{\"79\":2,\"142\":1}}],[\"401\",{\"1\":{\"40\":1}}],[\"400\",{\"1\":{\"40\":1}}],[\"删除元素\",{\"1\":{\"265\":1}}],[\"删除在例表中第一个匹配的值\",{\"1\":{\"261\":1}}],[\"删除list中元素\",{\"1\":{\"261\":1}}],[\"删除过期\",{\"1\":{\"192\":1}}],[\"删除哈希表key中的field键值\",{\"1\":{\"147\":1}}],[\"删除某个\",{\"1\":{\"139\":1}}],[\"删除到期任务成功\",{\"1\":{\"127\":1}}],[\"删除任务\",{\"1\":{\"127\":1}}],[\"删除缓存\",{\"1\":{\"123\":1}}],[\"删除外键\",{\"1\":{\"90\":2}}],[\"删除数据库所有对象\",{\"1\":{\"162\":1}}],[\"删除数据库\",{\"1\":{\"73\":1}}],[\"删除数据\",{\"1\":{\"73\":1,\"77\":1}}],[\"删除用户\",{\"1\":{\"73\":2}}],[\"删除\",{\"1\":{\"41\":1,\"90\":1}}],[\"从3开始\",{\"1\":{\"267\":1}}],[\"从头开始\",{\"1\":{\"267\":4}}],[\"从1开始\",{\"1\":{\"267\":1}}],[\"从嵌套列表中选取数据\",{\"1\":{\"261\":1}}],[\"从库通过执行这条\",{\"1\":{\"194\":1}}],[\"从库的过期键处理依靠主服务器控制\",{\"1\":{\"194\":1}}],[\"从库对过期的处理是被动的\",{\"1\":{\"194\":1}}],[\"从库不会进行过期扫描\",{\"1\":{\"194\":1}}],[\"从库也可以有从库\",{\"1\":{\"175\":1}}],[\"从内存状态持久化成\",{\"1\":{\"193\":1}}],[\"从过期字典中随机抽取\",{\"1\":{\"191\":1}}],[\"从数据库中取出一定数量的\",{\"1\":{\"191\":1}}],[\"从节点\",{\"1\":{\"181\":2}}],[\"从节点每隔1秒发送replconf\",{\"1\":{\"177\":1}}],[\"从中找到差异的数据\",{\"1\":{\"176\":1}}],[\"从从库\",{\"1\":{\"175\":1}}],[\"从服务在接收之后会清空当前数据\",{\"1\":{\"174\":1}}],[\"从服务器的数据会被清空\",{\"1\":{\"193\":1}}],[\"从服务器\",{\"1\":{\"193\":1}}],[\"从服务器会通过\",{\"1\":{\"176\":1}}],[\"从服务器使用slave\",{\"1\":{\"176\":1}}],[\"从服务器执行命令完成数据一致\",{\"1\":{\"174\":1}}],[\"从服务器加载rdb文件期间\",{\"1\":{\"174\":1}}],[\"从服务器接收后会记录下来\",{\"1\":{\"174\":1}}],[\"从服务器向主服务器发送psync命令\",{\"1\":{\"174\":1}}],[\"从集合key中随机选出count个元素\",{\"1\":{\"151\":2}}],[\"从集合key中删除元素\",{\"1\":{\"151\":1}}],[\"从key列表表尾弹出一个元素\",{\"1\":{\"143\":1}}],[\"从key列表表头弹出一个元素\",{\"1\":{\"143\":1}}],[\"从0开始\",{\"1\":{\"143\":1}}],[\"从队列中弹出任务时发生错误\",{\"1\":{\"134\":2}}],[\"从队列中弹出任务\",{\"1\":{\"134\":1}}],[\"从队列中弹出任务或消息并处理\",{\"1\":{\"133\":1}}],[\"从右侧弹出\",{\"1\":{\"133\":1}}],[\"从左侧插入\",{\"1\":{\"133\":1}}],[\"从处理队列中移除任务\",{\"1\":{\"127\":1}}],[\"从延迟队列中阻塞地获取任务\",{\"1\":{\"127\":1}}],[\"从而提高redis服务的读写性能\",{\"1\":{\"184\":1}}],[\"从而建立起哨兵集群\",{\"1\":{\"182\":1}}],[\"从而使得主服务器采用增量同步的方式\",{\"1\":{\"176\":1}}],[\"从而避免阻塞主进程\",{\"1\":{\"169\":1}}],[\"从而显著提高通信效率\",{\"1\":{\"129\":1}}],[\"从而造成一系列服务崩溃\",{\"1\":{\"116\":1}}],[\"从而淘汰最久未被使用的\",{\"1\":{\"114\":1}}],[\"从而保证插入数据时\",{\"1\":{\"97\":1}}],[\"从而保证数据的一致性和完整性\",{\"1\":{\"90\":1}}],[\"从指定的日期或时间值中减去指定的时间间隔\",{\"1\":{\"86\":2}}],[\"从\",{\"1\":{\"41\":1}}],[\"35\",{\"1\":{\"268\":2}}],[\"3=\",{\"1\":{\"268\":1}}],[\"33\",{\"1\":{\"90\":1,\"265\":1}}],[\"30\",{\"1\":{\"77\":2,\"268\":1}}],[\"3\",{\"0\":{\"46\":1,\"53\":1,\"63\":1,\"67\":1,\"145\":1,\"231\":1,\"286\":1,\"289\":1,\"298\":1,\"302\":1,\"303\":1,\"316\":1,\"364\":1,\"421\":1,\"486\":1,\"490\":1},\"1\":{\"54\":1,\"56\":1,\"58\":4,\"73\":2,\"77\":1,\"79\":1,\"80\":2,\"85\":1,\"87\":1,\"90\":2,\"119\":1,\"142\":1,\"260\":2,\"261\":7,\"263\":4,\"267\":4,\"268\":4,\"270\":6}}],[\"3600\",{\"1\":{\"40\":2}}],[\"345不限制\",{\"1\":{\"268\":1}}],[\"345宽度限制7\",{\"1\":{\"268\":1}}],[\"345\",{\"1\":{\"268\":1}}],[\"345设置了\",{\"1\":{\"268\":1}}],[\"34\",{\"0\":{\"26\":1},\"1\":{\"26\":1,\"85\":1}}],[\"设置打开文件的模式\",{\"1\":{\"269\":1}}],[\"设置的宽度小于数字自身\",{\"1\":{\"268\":1}}],[\"设置默认值的时候\",{\"1\":{\"264\":1}}],[\"设置了一个\",{\"1\":{\"169\":1}}],[\"设置值\",{\"1\":{\"159\":1}}],[\"设置\",{\"1\":{\"139\":4}}],[\"设置一个定时器\",{\"1\":{\"124\":1}}],[\"设置别名\",{\"1\":{\"79\":1}}],[\"设置为第一步中的\",{\"1\":{\"58\":1}}],[\"设置发行时间\",{\"1\":{\"40\":1}}],[\"设置token生效开始时间\",{\"1\":{\"40\":1}}],[\"设置过期时间\",{\"1\":{\"40\":1}}],[\"`score`\",{\"1\":{\"87\":1}}],[\"`salary`\",{\"1\":{\"19\":1}}],[\"`chinese`\",{\"1\":{\"87\":1}}],[\"`math`\",{\"1\":{\"87\":2}}],[\"`address`\",{\"1\":{\"87\":1}}],[\"`age`<=35\",{\"1\":{\"80\":1}}],[\"`age`<=40\",{\"1\":{\"80\":2}}],[\"`age`>=20\",{\"1\":{\"80\":2}}],[\"`age`=\",{\"1\":{\"79\":3}}],[\"`age`\",{\"1\":{\"77\":2,\"79\":4,\"80\":12}}],[\"`workon`\",{\"1\":{\"84\":2}}],[\"`workadress`\",{\"1\":{\"79\":3,\"80\":3}}],[\"`english`\",{\"1\":{\"87\":1}}],[\"`entydate`\",{\"1\":{\"80\":1}}],[\"`entrydate`\",{\"1\":{\"80\":2,\"86\":1}}],[\"`emp`where\",{\"1\":{\"80\":1}}],[\"`emp`\",{\"1\":{\"79\":9,\"80\":17,\"84\":1,\"86\":1}}],[\"`gender`\",{\"1\":{\"80\":7}}],[\"`西安`\",{\"1\":{\"80\":1}}],[\"`id`\",{\"1\":{\"80\":1}}],[\"`idcard`\",{\"1\":{\"79\":1}}],[\"`name`\",{\"1\":{\"77\":3,\"79\":1,\"80\":2,\"86\":1,\"87\":2}}],[\"`flipped\",{\"1\":{\"77\":5}}],[\"`user`\",{\"1\":{\"73\":1}}],[\"`\",{\"1\":{\"40\":3,\"131\":1,\"260\":12}}],[\"`json\",{\"1\":{\"40\":3,\"260\":8}}],[\"则停止继续删除过期\",{\"1\":{\"191\":1}}],[\"则继续重复步\",{\"1\":{\"191\":1}}],[\"则每个节点上槽的个数为\",{\"1\":{\"184\":1}}],[\"则查看复制的下标\",{\"1\":{\"181\":1}}],[\"则会显示插入失败\",{\"1\":{\"140\":1}}],[\"则显示插入成功\",{\"1\":{\"140\":1}}],[\"则也删除\",{\"1\":{\"90\":1}}],[\"则采用默认值\",{\"1\":{\"89\":1}}],[\"则返回t\",{\"1\":{\"87\":1}}],[\"则返回null\",{\"1\":{\"27\":2}}],[\"则将令牌数设置为容量\",{\"1\":{\"39\":1}}],[\"+1=\",{\"1\":{\"268\":1}}],[\"+\",{\"1\":{\"41\":1,\"58\":1,\"144\":1,\"148\":1,\"260\":2,\"268\":2}}],[\"+=\",{\"1\":{\"39\":1,\"261\":1,\"264\":1,\"268\":2}}],[\"+token\",{\"1\":{\"38\":1}}],[\"互斥锁方案\",{\"1\":{\"118\":1}}],[\"互斥锁\",{\"1\":{\"39\":1}}],[\"令牌填充的间隔时间\",{\"1\":{\"39\":1}}],[\"令牌桶的容量\",{\"1\":{\"39\":1}}],[\"桶中当前的令牌数\",{\"1\":{\"39\":1}}],[\"中文\",{\"1\":{\"268\":1}}],[\"中央处理器\",{\"0\":{\"239\":1}}],[\"中断\",{\"0\":{\"218\":1}}],[\"中的键值对进行检查\",{\"1\":{\"193\":1}}],[\"中的过期键不会对生成新\",{\"1\":{\"193\":1}}],[\"中储存的数字值减1\",{\"1\":{\"139\":1}}],[\"中储存的数字值增\",{\"1\":{\"139\":1}}],[\"中\",{\"1\":{\"134\":1,\"146\":1,\"154\":1,\"193\":2}}],[\"中使用\",{\"1\":{\"133\":1}}],[\"中间睡几秒是为了\",{\"1\":{\"123\":1}}],[\"中删除令牌\",{\"1\":{\"41\":1}}],[\"中存在\",{\"1\":{\"38\":1}}],[\"中选择列\",{\"1\":{\"23\":1,\"24\":1}}],[\"停止当前中间件链的执行\",{\"1\":{\"38\":1}}],[\"j+=1\",{\"1\":{\"262\":1,\"268\":1}}],[\"j\",{\"1\":{\"262\":5,\"268\":5}}],[\"j<=i\",{\"1\":{\"262\":1,\"268\":1}}],[\"j=1\",{\"1\":{\"262\":1,\"268\":1}}],[\"job\",{\"1\":{\"90\":2,\"127\":2}}],[\"join\",{\"1\":{\"79\":1}}],[\"jack\",{\"1\":{\"87\":1}}],[\"json\",{\"1\":{\"38\":7,\"40\":4,\"41\":4,\"148\":1,\"260\":5}}],[\"jwtbucket\",{\"0\":{\"39\":1}}],[\"jwtauthmiddleware\",{\"1\":{\"37\":1,\"38\":1}}],[\"jwt\",{\"0\":{\"36\":1},\"1\":{\"38\":2,\"40\":7}}],[\"hsdhaui\",{\"1\":{\"264\":1}}],[\"hset\",{\"1\":{\"147\":1}}],[\"hincrby\",{\"1\":{\"147\":1}}],[\"high\",{\"1\":{\"24\":1}}],[\"hlen\",{\"1\":{\"147\":1}}],[\"hdel\",{\"1\":{\"147\":1}}],[\"hmget\",{\"1\":{\"147\":1}}],[\"hmset\",{\"1\":{\"147\":1}}],[\"hgetall\",{\"1\":{\"147\":1}}],[\"hget\",{\"1\":{\"147\":1}}],[\"hot\",{\"1\":{\"118\":1}}],[\"hour\",{\"1\":{\"40\":1}}],[\"hao\",{\"1\":{\"266\":1}}],[\"hash\",{\"0\":{\"145\":1},\"1\":{\"105\":1,\"146\":2,\"148\":1,\"184\":1}}],[\"having\",{\"1\":{\"79\":1,\"80\":2}}],[\"handler\",{\"0\":{\"41\":1}}],[\"handlerfunc\",{\"1\":{\"38\":3}}],[\"hello频道\",{\"1\":{\"182\":1}}],[\"hello\",{\"1\":{\"41\":1,\"264\":2,\"269\":2}}],[\"header\",{\"0\":{\"461\":1,\"462\":1},\"1\":{\"38\":2}}],[\"h\",{\"1\":{\"38\":7,\"40\":4,\"41\":4}}],[\"http协议是基于tcp协议传输的\",{\"0\":{\"487\":1}}],[\"http和rpc的区别\",{\"0\":{\"320\":1}}],[\"http和https\",{\"0\":{\"312\":1}}],[\"http和https的区别\",{\"0\":{\"311\":1,\"313\":1}}],[\"https的应用数据时如保证完整性的\",{\"0\":{\"317\":1}}],[\"https是如何建立连接的\",{\"0\":{\"316\":1}}],[\"https解决了http的那些问题\",{\"0\":{\"314\":1}}],[\"https如何优化\",{\"0\":{\"304\":1}}],[\"http3协议\",{\"0\":{\"303\":1}}],[\"http2的问题\",{\"0\":{\"295\":1}}],[\"http的性能问题\",{\"0\":{\"287\":1}}],[\"http的更迭\",{\"0\":{\"283\":1}}],[\"http特性\",{\"0\":{\"282\":1}}],[\"http缓存技术\",{\"0\":{\"279\":1}}],[\"http常见字段有哪些\",{\"0\":{\"275\":1}}],[\"http常见的状态码\",{\"0\":{\"274\":1}}],[\"http是什么\",{\"0\":{\"273\":1}}],[\"http基本概念\",{\"0\":{\"272\":1}}],[\"http\",{\"0\":{\"271\":1,\"506\":1},\"1\":{\"38\":7,\"40\":1,\"41\":3,\"71\":1}}],[\"8bit\",{\"1\":{\"114\":1}}],[\"8400\",{\"1\":{\"90\":1}}],[\"88\",{\"1\":{\"87\":1,\"265\":3}}],[\"884\",{\"0\":{\"29\":1},\"1\":{\"29\":1}}],[\"85\",{\"1\":{\"87\":1}}],[\"8\",{\"0\":{\"58\":1,\"369\":1,\"497\":1},\"1\":{\"89\":1,\"125\":1,\"131\":1,\"261\":1,\"269\":5}}],[\"8080\",{\"1\":{\"37\":1}}],[\"udp\",{\"0\":{\"393\":1}}],[\"udp和tcp的区别和应用场景\",{\"0\":{\"359\":1}}],[\"udp的特点是\",{\"1\":{\"51\":1}}],[\"utf\",{\"1\":{\"269\":4}}],[\"u2\",{\"1\":{\"260\":3}}],[\"u1\",{\"1\":{\"260\":3}}],[\"uint64\",{\"1\":{\"260\":1}}],[\"uint\",{\"1\":{\"260\":3}}],[\"uuid\",{\"1\":{\"131\":2}}],[\"up\",{\"1\":{\"268\":2}}],[\"upper\",{\"1\":{\"84\":1}}],[\"update\",{\"1\":{\"73\":1,\"77\":2,\"84\":1,\"90\":2,\"96\":1,\"98\":1,\"123\":1,\"270\":1}}],[\"unmarshal\",{\"1\":{\"260\":2}}],[\"unix\",{\"1\":{\"127\":3}}],[\"uniquevalue\",{\"1\":{\"131\":2}}],[\"unique\",{\"1\":{\"89\":1,\"140\":1}}],[\"unioue\",{\"1\":{\"89\":1}}],[\"union\",{\"0\":{\"23\":1,\"24\":1},\"1\":{\"23\":3,\"24\":7,\"270\":1}}],[\"unit\",{\"1\":{\"86\":2}}],[\"unauthorized\",{\"1\":{\"40\":1}}],[\"unlocked\",{\"1\":{\"131\":2}}],[\"unlock\",{\"1\":{\"39\":1,\"92\":1,\"94\":1}}],[\"useinfo\",{\"1\":{\"260\":5}}],[\"used翻译为最近最不常用的\",{\"1\":{\"114\":1}}],[\"used翻译为最近最少使用\",{\"1\":{\"113\":1}}],[\"userinfo\",{\"1\":{\"260\":3}}],[\"user1\",{\"1\":{\"260\":3}}],[\"user1`set\",{\"1\":{\"77\":1}}],[\"user1`values\",{\"1\":{\"77\":1}}],[\"user1`\",{\"1\":{\"77\":3}}],[\"user\",{\"1\":{\"73\":7,\"89\":1,\"260\":5,\"264\":12}}],[\"username\",{\"1\":{\"38\":2,\"40\":10,\"41\":3}}],[\"use\",{\"0\":{\"376\":1},\"1\":{\"37\":3,\"73\":1}}],[\"跨域资源共享\",{\"0\":{\"32\":1}}],[\"不允许重复数据存在\",{\"1\":{\"270\":1}}],[\"不传参表示默认读取全部\",{\"1\":{\"269\":1}}],[\"不传入参数\",{\"1\":{\"266\":1}}],[\"不生效\",{\"1\":{\"268\":1}}],[\"不可使用关键字\",{\"1\":{\"268\":1}}],[\"不可以写多行数据\",{\"1\":{\"264\":1}}],[\"不可靠的\",{\"1\":{\"51\":1}}],[\"不接受的话就是一个临时函数\",{\"1\":{\"264\":1}}],[\"不论键是否过期都会被载入到数据库\",{\"1\":{\"193\":1}}],[\"不友好\",{\"1\":{\"191\":1,\"192\":1}}],[\"不主动删除过期键\",{\"1\":{\"190\":1}}],[\"不仅会将写命令发送给从服务器\",{\"1\":{\"176\":1}}],[\"不过这个共享的内存只能以只读的方式\",{\"1\":{\"169\":1}}],[\"不满足上面就是用哈希表\",{\"1\":{\"150\":1}}],[\"不满足where条件\",{\"1\":{\"80\":1}}],[\"不存在就创建\",{\"1\":{\"269\":2}}],[\"不存在就插入\",{\"1\":{\"139\":1}}],[\"不存在\",{\"1\":{\"140\":1}}],[\"不光能存放文本数据\",{\"1\":{\"138\":1}}],[\"不会包含num2\",{\"1\":{\"262\":1,\"268\":1}}],[\"不会\",{\"1\":{\"193\":2}}],[\"不会影响主线程\",{\"1\":{\"171\":1}}],[\"不会影响业务\",{\"1\":{\"122\":1}}],[\"不会阻塞当前写操作命令的执行\",{\"1\":{\"166\":1}}],[\"不会进行回滚操作\",{\"1\":{\"129\":1}}],[\"不会和行级的共享锁和独占锁发生冲突\",{\"1\":{\"96\":1}}],[\"不给热点数据设置过期时间\",{\"1\":{\"118\":1}}],[\"不去访问数据库\",{\"1\":{\"117\":1}}],[\"不然在完全读取之后\",{\"1\":{\"269\":1}}],[\"不然在恢复数据的时候会很慢\",{\"1\":{\"167\":1}}],[\"不然系统会默认你写的是string类型\",{\"1\":{\"263\":1}}],[\"不然第一个请求拿到了锁\",{\"1\":{\"116\":1}}],[\"不然就加入栈\",{\"1\":{\"29\":1}}],[\"不用在每次数据访问时都移动链表项\",{\"1\":{\"113\":1}}],[\"不用为所有的数据维护一个大链表\",{\"1\":{\"113\":1}}],[\"不淘汰任何数据\",{\"1\":{\"108\":1}}],[\"不进行数据淘汰的策略\",{\"0\":{\"108\":1}}],[\"不支持下标索引\",{\"1\":{\"270\":2}}],[\"不支持消费组的形式\",{\"1\":{\"144\":1}}],[\"不支持\",{\"1\":{\"105\":1,\"265\":3}}],[\"不重复的\",{\"1\":{\"89\":1}}],[\"不及格\",{\"1\":{\"87\":1}}],[\"不同的数据库有不同的实现\",{\"1\":{\"80\":1}}],[\"不参与分组\",{\"1\":{\"80\":1}}],[\"不是整数\",{\"1\":{\"129\":1}}],[\"不是\",{\"1\":{\"79\":1}}],[\"不等\",{\"1\":{\"79\":1}}],[\"不返回ack包\",{\"1\":{\"54\":1}}],[\"不能使用普通的等号\",{\"1\":{\"77\":1}}],[\"不能是函数参数\",{\"1\":{\"19\":1}}],[\"不能直接将参数n递给\",{\"1\":{\"19\":1}}],[\"当此过期键被删除后\",{\"1\":{\"193\":1}}],[\"当时间到达时\",{\"1\":{\"192\":1}}],[\"当主节点发现从节点挂掉大半\",{\"1\":{\"188\":1}}],[\"当主节点重新连接时\",{\"1\":{\"187\":1}}],[\"当主服务器在repl\",{\"1\":{\"176\":1}}],[\"当redis的缓存数据量大到一台服务器无法缓存时\",{\"1\":{\"184\":1}}],[\"当redis内存满了\",{\"0\":{\"107\":1}}],[\"当这个旧主节点重新上线时\",{\"1\":{\"181\":1}}],[\"当从slave变为master转移完毕\",{\"1\":{\"181\":1}}],[\"当赞同数达到阈值之后\",{\"1\":{\"179\":1}}],[\"当哨兵判定主节点\",{\"1\":{\"179\":1}}],[\"当发生写操作时自动将写操作同步到从服务器\",{\"1\":{\"173\":1}}],[\"当发现队列有任务后\",{\"1\":{\"162\":1}}],[\"当开启了混合持久化时\",{\"1\":{\"171\":1}}],[\"当子进程结束会向主进程发送一个信号\",{\"1\":{\"169\":1}}],[\"当队列有任务后\",{\"1\":{\"162\":2}}],[\"当你执行\",{\"1\":{\"129\":1}}],[\"当使用everysec策略的时候\",{\"1\":{\"171\":1}}],[\"当使用\",{\"1\":{\"129\":1,\"171\":2}}],[\"当执行\",{\"1\":{\"129\":1}}],[\"当前股价\",{\"1\":{\"268\":1}}],[\"当前进程尝试获取锁\",{\"1\":{\"125\":2}}],[\"当前时间和上一次填充的时间差\",{\"1\":{\"39\":1}}],[\"当数据库有更新操作的时候\",{\"1\":{\"124\":1}}],[\"当数据被读取\",{\"1\":{\"57\":1}}],[\"当操作失败就重式直到完成\",{\"1\":{\"123\":1}}],[\"当我们查询一个key的时候\",{\"1\":{\"189\":1}}],[\"当我们对key设置过期时间\",{\"1\":{\"189\":1}}],[\"当我们对embstr编码的字符串对象执行任何修改命令\",{\"1\":{\"138\":1}}],[\"当我们线上业务发现缓存穿透的现象时\",{\"1\":{\"119\":1}}],[\"当我们进行结构操作时\",{\"1\":{\"95\":1}}],[\"当有大量恶意请求访问不存在的数据的时候\",{\"1\":{\"119\":1}}],[\"当有数据被访问时\",{\"1\":{\"113\":1}}],[\"当用户访问的数据\",{\"1\":{\"119\":1}}],[\"当业务线程发现缓存失效后\",{\"1\":{\"116\":1}}],[\"当缓存失效是就立马去数据库中读取数据更新到缓存\",{\"1\":{\"116\":1}}],[\"当缓存构建之后\",{\"1\":{\"116\":1}}],[\"当大量缓存数据在同一时间过期失效\",{\"1\":{\"116\":1}}],[\"当需要内存淘汰时\",{\"1\":{\"113\":1}}],[\"当一个数据被再次访问时\",{\"1\":{\"114\":1}}],[\"当一个事务对一条记录加了\",{\"1\":{\"99\":2}}],[\"当一个被插上意向锁\",{\"1\":{\"96\":1}}],[\"当在父表中删除对应记录时\",{\"1\":{\"90\":1}}],[\"当在父表中删除\",{\"1\":{\"90\":3}}],[\"当第一个字段值相同时\",{\"1\":{\"80\":1}}],[\"当拥塞窗口超过慢启动门限\",{\"1\":{\"58\":1}}],[\"当传输层使用tcp协议时\",{\"1\":{\"55\":1}}],[\"当\",{\"1\":{\"29\":1,\"113\":1,\"159\":1,\"162\":1,\"169\":1,\"193\":1,\"194\":1}}],[\"利用栈的思想\",{\"1\":{\"29\":1}}],[\"顶出栈顶元素\",{\"1\":{\"29\":1}}],[\"找到窗口中的最大值\",{\"1\":{\"27\":1}}],[\"找到窗口中的最小值\",{\"1\":{\"27\":1}}],[\"它所占用的内存就不会释放\",{\"1\":{\"190\":1}}],[\"它会同时将这个写命令写入到\",{\"1\":{\"169\":1}}],[\"它会进行额外的步骤来消除重复的行\",{\"1\":{\"23\":1}}],[\"它通常基于\",{\"1\":{\"133\":1}}],[\"它是基于多个redis节点的分布式锁\",{\"1\":{\"131\":1}}],[\"它们按顺序执行\",{\"1\":{\"129\":1}}],[\"它更新数据库中的年龄为\",{\"1\":{\"123\":1}}],[\"它的实现方式是在\",{\"1\":{\"113\":1}}],[\"它表示当运行内存超过最大设置内存时\",{\"1\":{\"108\":1}}],[\"它基于\",{\"1\":{\"71\":1}}],[\"它发送数据的能力会呈指数形式增长\",{\"1\":{\"58\":1}}],[\"它返回在每个分区内按指定顺序的第一个值\",{\"1\":{\"27\":1}}],[\"后台子进程重写\",{\"1\":{\"171\":1}}],[\"后台子进程\",{\"1\":{\"169\":1}}],[\"后台线程会\",{\"1\":{\"162\":1}}],[\"后台线程会调用\",{\"1\":{\"162\":2}}],[\"后面采用多线程的原因\",{\"1\":{\"163\":1}}],[\"后面在缓存失效的情况下请求直接打到db上\",{\"1\":{\"119\":1}}],[\"后续主服务器通过这个连接实现命令传播\",{\"1\":{\"174\":1}}],[\"后续在收到消息的时候\",{\"1\":{\"144\":1}}],[\"后续的排名会跳过\",{\"1\":{\"27\":1}}],[\"后新增的内存淘汰策略\",{\"1\":{\"110\":1,\"111\":1}}],[\"后\",{\"1\":{\"58\":1}}],[\"后端技术\",{\"0\":{\"7\":1}}],[\"的对应关系\",{\"0\":{\"484\":1}}],[\"的对象结构体中添加一个额外的字段\",{\"1\":{\"113\":1}}],[\"的工具\",{\"0\":{\"436\":1,\"437\":1}}],[\"的报错信息\",{\"0\":{\"376\":1}}],[\"的意义\",{\"0\":{\"363\":1}}],[\"的意思是确认有\",{\"1\":{\"58\":1}}],[\"的缓存命中率\",{\"0\":{\"200\":1}}],[\"的时候\",{\"1\":{\"193\":1}}],[\"的删除操作\",{\"1\":{\"192\":1}}],[\"的过期时间时\",{\"1\":{\"192\":1}}],[\"的影响\",{\"1\":{\"191\":1}}],[\"的数量\",{\"1\":{\"191\":3}}],[\"的数据写入\",{\"0\":{\"211\":1}}],[\"的数据写入到缓存中\",{\"1\":{\"123\":1}}],[\"的数据后\",{\"1\":{\"176\":1}}],[\"的数据持久化机制\",{\"1\":{\"134\":1}}],[\"的定期删除的流程\",{\"1\":{\"191\":1}}],[\"的策略\",{\"1\":{\"189\":1}}],[\"的发布者\",{\"1\":{\"182\":1}}],[\"的内容后\",{\"1\":{\"171\":1}}],[\"的内容追加到aof文件中\",{\"1\":{\"169\":1}}],[\"的优点\",{\"1\":{\"165\":1}}],[\"的位置\",{\"1\":{\"159\":1}}],[\"的位图数组\",{\"1\":{\"119\":1}}],[\"的个数\",{\"1\":{\"159\":1}}],[\"的形式如\",{\"1\":{\"146\":1}}],[\"的所有\",{\"1\":{\"138\":1}}],[\"的主从复制和哨兵机制\",{\"1\":{\"134\":1}}],[\"的回滚机制\",{\"1\":{\"129\":1}}],[\"的访问频次\",{\"1\":{\"114\":1}}],[\"的访问时间长\",{\"1\":{\"114\":1}}],[\"的访问时间戳\",{\"1\":{\"114\":2}}],[\"的\",{\"1\":{\"114\":1,\"133\":1,\"138\":1}}],[\"的lru\",{\"1\":{\"114\":1}}],[\"的配置文件中可以找到\",{\"1\":{\"107\":1}}],[\"的运行内存达到了某个阀值\",{\"1\":{\"107\":1}}],[\"的一方\",{\"1\":{\"69\":1}}],[\"的值时发生错误\",{\"1\":{\"129\":2}}],[\"的值\",{\"1\":{\"58\":1,\"129\":2}}],[\"的行会得到相同的排名\",{\"1\":{\"27\":1}}],[\"的查询效率\",{\"1\":{\"26\":1}}],[\"即真和假\",{\"1\":{\"268\":1}}],[\"即元组中元素也可以是元组\",{\"1\":{\"263\":1}}],[\"即当队列中没有任务时\",{\"1\":{\"134\":1}}],[\"即两个事务可以同时持有包含共同间隙范围的间隙锁\",{\"1\":{\"100\":1}}],[\"即桶中可以持有的最大令牌数\",{\"1\":{\"39\":1}}],[\"即使存在并列排名\",{\"1\":{\"27\":1}}],[\"即并列\",{\"1\":{\"27\":1}}],[\"即只有1行或者为空\",{\"1\":{\"19\":1}}],[\"计网部分\",{\"1\":{\"50\":1}}],[\"计算机网络基础\",{\"0\":{\"510\":1}}],[\"计算机网络\",{\"0\":{\"507\":1}}],[\"计算机操作系统\",{\"0\":{\"503\":1}}],[\"计算机是怎么存小数的\",{\"0\":{\"253\":1}}],[\"计算机保存数据的形式\",{\"0\":{\"250\":1}}],[\"计算的结果\",{\"1\":{\"159\":1}}],[\"计算两个之间的交集\",{\"1\":{\"152\":1}}],[\"计算复杂度较高\",{\"1\":{\"152\":1}}],[\"计算可以填充的令牌数\",{\"1\":{\"39\":1}}],[\"计算窗口内值的样本方差\",{\"1\":{\"27\":1}}],[\"计算窗口内值的样本标准差\",{\"1\":{\"27\":1}}],[\"计算窗口内值的总体方差\",{\"1\":{\"27\":1}}],[\"计算窗口内值的总体标准差\",{\"1\":{\"27\":1}}],[\"计算窗口中的平均值\",{\"1\":{\"27\":1}}],[\"计算窗口中的总和\",{\"1\":{\"27\":1}}],[\"计算当前行和前六行的数据的amount的总和\",{\"1\":{\"27\":1}}],[\"计数前六行和当前行的数据\",{\"1\":{\"27\":1}}],[\"64\",{\"1\":{\"127\":1,\"142\":1,\"146\":1,\"154\":1}}],[\"6600\",{\"1\":{\"90\":1}}],[\"66\",{\"1\":{\"87\":1,\"90\":1,\"265\":2}}],[\"67\",{\"1\":{\"87\":1}}],[\"60\",{\"1\":{\"80\":1,\"86\":1,\"87\":1,\"139\":5}}],[\"6379\",{\"1\":{\"41\":1,\"125\":1,\"127\":1,\"131\":1,\"134\":3,\"175\":1}}],[\"6\",{\"0\":{\"56\":1,\"157\":1,\"294\":1,\"367\":1,\"495\":1},\"1\":{\"27\":3,\"85\":1,\"125\":1,\"131\":1,\"162\":1,\"261\":2,\"263\":1,\"267\":4,\"270\":6}}],[\"将小数点精度设置为2\",{\"1\":{\"268\":1}}],[\"将它设置为新主节点的从节点\",{\"1\":{\"181\":1}}],[\"将新主节点的ip地址和信息\",{\"1\":{\"181\":1}}],[\"将某一时刻的内存数据\",{\"1\":{\"165\":1,\"170\":1}}],[\"将文件关闭\",{\"1\":{\"162\":1}}],[\"将差集结果存入新集合destination中\",{\"1\":{\"151\":1}}],[\"将并集结果存入新集合destination中\",{\"1\":{\"151\":1}}],[\"将交集结果存入新集合destination中\",{\"1\":{\"151\":1}}],[\"将读取的list进行备份\",{\"1\":{\"144\":1}}],[\"将id与已经处理的进行比较\",{\"1\":{\"144\":1}}],[\"将一个或多个值value插入到key列表的表尾\",{\"1\":{\"143\":1}}],[\"将一个或多个值value插入到key列表的表头\",{\"1\":{\"143\":1}}],[\"将key中存储的数字值减\",{\"1\":{\"139\":1}}],[\"将key中存储的数字值加\",{\"1\":{\"139\":1}}],[\"将\",{\"1\":{\"139\":2,\"162\":1,\"192\":1}}],[\"将任务放入队列时发生错误\",{\"1\":{\"134\":1}}],[\"将任务放入队列\",{\"1\":{\"134\":1}}],[\"将任务或消息推送到队列中\",{\"1\":{\"133\":1}}],[\"将其放回延迟队列\",{\"1\":{\"127\":1}}],[\"将缓存的数据更新为\",{\"1\":{\"122\":1}}],[\"将缓存设置为永不过期\",{\"1\":{\"116\":1}}],[\"将数据库的数据更新为\",{\"1\":{\"122\":1}}],[\"将每个哈希值在位图数组的对应位置的值设置为\",{\"1\":{\"119\":1}}],[\"将每个包的长度固定\",{\"1\":{\"56\":1}}],[\"将第一步得到的\",{\"1\":{\"119\":1}}],[\"将锁的状态设置为等待状态\",{\"1\":{\"102\":1}}],[\"将字符串str全部转为大写\",{\"1\":{\"84\":1}}],[\"将字符串str全部转为小写\",{\"1\":{\"84\":1}}],[\"将s1\",{\"1\":{\"84\":1}}],[\"将记录进行分组\",{\"1\":{\"79\":1}}],[\"将拥塞窗口减半\",{\"1\":{\"58\":1}}],[\"将接收到数据的信息放到ack包的这个字段\",{\"1\":{\"54\":1}}],[\"将令牌添加到请求头中\",{\"1\":{\"38\":1}}],[\"将结果集分为n个大致相等的组\",{\"1\":{\"27\":1}}],[\"将返回每个分区内第一个\",{\"1\":{\"27\":2}}],[\"将空值的情况返回一个null值\",{\"1\":{\"19\":1}}],[\"每日增长系数\",{\"1\":{\"268\":1}}],[\"每隔一段时间\",{\"1\":{\"191\":1}}],[\"每次访问的时候\",{\"1\":{\"190\":1}}],[\"每执行一条写操作命令\",{\"1\":{\"165\":1}}],[\"每一个消息都一个全局id\",{\"1\":{\"144\":1}}],[\"每个模数代表一个相应编号的哈希槽\",{\"1\":{\"184\":1}}],[\"每个哨兵只有一次投票机会\",{\"1\":{\"180\":1}}],[\"每个redis服务器在启动的时候都会产生一个随机id来标识自己\",{\"1\":{\"174\":1}}],[\"每个存储元素相当于有两个值组成的\",{\"1\":{\"154\":1}}],[\"每个结构体包含score和member两个字段\",{\"1\":{\"127\":1}}],[\"每个不同的\",{\"1\":{\"27\":2}}],[\"每页显示记录数\",{\"1\":{\"80\":1}}],[\"每页展示十条数据\",{\"1\":{\"80\":2}}],[\"每当收到一个\",{\"1\":{\"58\":1}}],[\"每收到1次ack\",{\"1\":{\"58\":1}}],[\"每段数据都会被标记上一个序列号\",{\"1\":{\"55\":1}}],[\"每位教师所教授的科目种类的数量\",{\"0\":{\"25\":1},\"1\":{\"25\":1}}],[\"v8\",{\"1\":{\"125\":1,\"127\":2,\"131\":1,\"134\":3}}],[\"volatile\",{\"1\":{\"110\":4}}],[\"val1\",{\"1\":{\"87\":2}}],[\"valid\",{\"1\":{\"38\":1}}],[\"value型的python数据集合\",{\"1\":{\"268\":1}}],[\"value集合\",{\"1\":{\"268\":1}}],[\"value6\",{\"1\":{\"266\":1}}],[\"value6=my\",{\"1\":{\"266\":1}}],[\"value5\",{\"1\":{\"266\":1}}],[\"value5=my\",{\"1\":{\"266\":1}}],[\"value4\",{\"1\":{\"266\":1}}],[\"value4=my\",{\"1\":{\"266\":1}}],[\"valuel\",{\"1\":{\"159\":1}}],[\"value是数量\",{\"1\":{\"148\":1}}],[\"valuen\",{\"1\":{\"146\":1}}],[\"value=my\",{\"1\":{\"265\":2,\"266\":2,\"270\":1}}],[\"value=\",{\"1\":{\"146\":1}}],[\"value3=my\",{\"1\":{\"266\":1}}],[\"value3\",{\"1\":{\"129\":1,\"266\":1}}],[\"value数据类型\",{\"1\":{\"105\":1}}],[\"value2=\",{\"1\":{\"266\":1}}],[\"value2=my\",{\"1\":{\"266\":1}}],[\"value2\",{\"1\":{\"87\":1,\"129\":6,\"139\":2,\"266\":2}}],[\"value1\",{\"1\":{\"87\":1,\"129\":6,\"139\":2,\"146\":1}}],[\"values\",{\"1\":{\"77\":3,\"87\":1,\"90\":2}}],[\"value\",{\"1\":{\"27\":6,\"77\":2,\"86\":2,\"87\":1,\"129\":1,\"131\":1,\"138\":1,\"139\":9,\"140\":1,\"142\":1,\"143\":4,\"146\":3,\"147\":3,\"148\":1,\"159\":1,\"169\":1,\"265\":5,\"266\":2,\"270\":1}}],[\"varchar\",{\"1\":{\"87\":1,\"89\":1,\"90\":3}}],[\"var\",{\"1\":{\"27\":2,\"29\":1,\"38\":1,\"40\":2,\"41\":1,\"125\":1,\"127\":1,\"131\":1,\"260\":5}}],[\"vip>3\",{\"1\":{\"262\":1,\"268\":1}}],[\"vip=int\",{\"1\":{\"262\":1,\"268\":1}}],[\"visited\",{\"1\":{\"27\":3}}],[\"viewer\",{\"1\":{\"17\":1}}],[\"views\",{\"1\":{\"17\":1}}],[\"易懂\",{\"1\":{\"27\":1}}],[\"易于理解但是不够快\",{\"1\":{\"26\":1}}],[\"简单分页\",{\"0\":{\"228\":1}}],[\"简单的动态字符串\",{\"1\":{\"138\":1}}],[\"简短\",{\"1\":{\"27\":1}}],[\"简介\",{\"0\":{\"3\":1}}],[\"python基础\",{\"0\":{\"505\":1}}],[\"python中使用最频繁的数据类型\",{\"1\":{\"268\":1}}],[\"python的数据类型\",{\"0\":{\"268\":1}}],[\"python\",{\"1\":{\"266\":1}}],[\"plus\",{\"1\":{\"260\":3}}],[\"player\",{\"1\":{\"27\":11}}],[\"period控制发送频率\",{\"1\":{\"177\":1}}],[\"percent\",{\"1\":{\"27\":1}}],[\"ping的工作原理\",{\"0\":{\"327\":1,\"328\":1}}],[\"ping\",{\"1\":{\"177\":1}}],[\"pipe\",{\"1\":{\"129\":6}}],[\"pipeline\",{\"1\":{\"129\":2}}],[\"psync\",{\"1\":{\"176\":1}}],[\"px\",{\"1\":{\"140\":1}}],[\"pong心态检测\",{\"1\":{\"177\":1}}],[\"post\",{\"1\":{\"37\":1}}],[\"pop\",{\"1\":{\"27\":2,\"261\":1,\"265\":1,\"270\":1}}],[\"price=stock\",{\"1\":{\"268\":1}}],[\"price=100\",{\"1\":{\"268\":1}}],[\"price\",{\"1\":{\"268\":5}}],[\"print\",{\"1\":{\"261\":21,\"262\":17,\"263\":3,\"264\":10,\"265\":11,\"266\":8,\"267\":6,\"268\":51,\"269\":2,\"270\":8}}],[\"println\",{\"1\":{\"29\":1,\"38\":1,\"125\":18,\"127\":8,\"129\":5,\"131\":8,\"134\":7,\"260\":6}}],[\"primary\",{\"1\":{\"89\":2,\"90\":2}}],[\"privileges\",{\"1\":{\"73\":1}}],[\"producer\",{\"1\":{\"133\":1,\"134\":1}}],[\"processing\",{\"1\":{\"127\":2}}],[\"processstring\",{\"1\":{\"29\":3}}],[\"provided\",{\"1\":{\"38\":1,\"41\":1}}],[\"protectedhandler\",{\"1\":{\"37\":1,\"41\":1}}],[\"protected\",{\"1\":{\"37\":1}}],[\"preceding\",{\"1\":{\"27\":2}}],[\"packet\",{\"0\":{\"461\":1}}],[\"package\",{\"1\":{\"125\":1,\"127\":2,\"129\":1,\"131\":1,\"134\":3,\"260\":1}}],[\"pad\",{\"1\":{\"84\":2}}],[\"password\",{\"1\":{\"40\":3,\"73\":2,\"125\":1,\"127\":1,\"131\":1}}],[\"past\",{\"1\":{\"27\":1}}],[\"param\",{\"1\":{\"264\":1}}],[\"parsefloat\",{\"1\":{\"127\":1}}],[\"parsewithclaims\",{\"1\":{\"38\":1}}],[\"parts\",{\"1\":{\"127\":3}}],[\"partition\",{\"1\":{\"27\":4}}],[\"panic\",{\"1\":{\"37\":1,\"260\":2}}],[\"patients\",{\"1\":{\"18\":1}}],[\"patient\",{\"1\":{\"18\":2}}],[\"5d\",{\"1\":{\"268\":2}}],[\"5个\",{\"1\":{\"191\":1}}],[\"512\",{\"1\":{\"142\":1,\"146\":1}}],[\"51\",{\"1\":{\"139\":1}}],[\"50\",{\"1\":{\"90\":2}}],[\"500\",{\"1\":{\"40\":1,\"264\":1}}],[\"50000\",{\"1\":{\"24\":2}}],[\"56\",{\"1\":{\"87\":1}}],[\"5\",{\"0\":{\"55\":1,\"153\":1,\"293\":1,\"366\":1,\"493\":1,\"494\":1},\"1\":{\"80\":2,\"84\":1,\"90\":2,\"113\":1,\"125\":1,\"131\":1,\"261\":4,\"263\":3,\"267\":4,\"268\":1,\"270\":7}}],[\"586\",{\"0\":{\"28\":1},\"1\":{\"28\":1}}],[\"551\",{\"0\":{\"27\":1},\"1\":{\"27\":1}}],[\"返回除法的余数b\",{\"1\":{\"268\":1}}],[\"返回商的整数部分9\",{\"1\":{\"268\":1}}],[\"返回指定key中第一次出现指定value\",{\"1\":{\"159\":1}}],[\"返回指定成员区间内的成员\",{\"1\":{\"155\":2}}],[\"返回值\",{\"1\":{\"159\":1}}],[\"返回有序集合中指定分数区间内的成员\",{\"1\":{\"155\":1}}],[\"返回有序集合key中元素个数\",{\"1\":{\"155\":1}}],[\"返回有序集合key中元素member的分值\",{\"1\":{\"155\":1}}],[\"返回哈希表key中所有的键值\",{\"1\":{\"147\":1}}],[\"返回哈希表key中field的数量\",{\"1\":{\"147\":1}}],[\"返回列表key中指定区间内的元素\",{\"1\":{\"143\":1}}],[\"返回\",{\"1\":{\"139\":1}}],[\"返回错误\",{\"1\":{\"123\":1}}],[\"返回给应用\",{\"1\":{\"119\":1}}],[\"返回res1\",{\"1\":{\"87\":2}}],[\"返回value1\",{\"1\":{\"87\":1}}],[\"返回起始时间date1和\",{\"1\":{\"86\":1}}],[\"返回一个日期\",{\"1\":{\"86\":1}}],[\"返回当前时间\",{\"1\":{\"86\":1}}],[\"返回当前日期和时间\",{\"1\":{\"86\":1}}],[\"返回当前日期\",{\"1\":{\"86\":1}}],[\"返回当前行及其之前所有行的累积分布\",{\"1\":{\"27\":1}}],[\"返回当前行之前第n行的数据\",{\"1\":{\"27\":1}}],[\"返回当前行之后第n行的数据\",{\"1\":{\"27\":1}}],[\"返回0~1内的随机数\",{\"1\":{\"85\":1}}],[\"返回x\",{\"1\":{\"85\":1}}],[\"返回从字符串str从start位置起的len个长度的字符串\",{\"1\":{\"84\":1}}],[\"返回限定的记录数\",{\"1\":{\"79\":1}}],[\"返回窗口中每行的百分比排名\",{\"1\":{\"27\":1}}],[\"返回窗口定义中指定的排序后最后一行的数据\",{\"1\":{\"27\":1}}],[\"返回每行所属的组号\",{\"1\":{\"27\":1}}],[\"返回第一个大于等于target的索引\",{\"1\":{\"26\":1}}],[\"返回接下来的1行数据\",{\"1\":{\"20\":1}}],[\"够快\",{\"1\":{\"26\":1}}],[\"00有什么区别\",{\"0\":{\"335\":1}}],[\"003032\",{\"1\":{\"268\":1}}],[\"0~16383\",{\"1\":{\"184\":1}}],[\"0之后redis采用多线程\",{\"1\":{\"163\":1}}],[\"0之后\",{\"1\":{\"108\":1}}],[\"07\",{\"1\":{\"90\":1}}],[\"08\",{\"1\":{\"90\":1}}],[\"03\",{\"1\":{\"90\":1}}],[\"05\",{\"1\":{\"90\":2}}],[\"01234567\",{\"1\":{\"267\":2}}],[\"01\",{\"1\":{\"86\":1,\"90\":2}}],[\"09\",{\"1\":{\"86\":1,\"90\":1}}],[\"021001\",{\"1\":{\"40\":1,\"125\":1,\"131\":1}}],[\"0\",{\"0\":{\"43\":1,\"44\":1,\"331\":2,\"332\":2,\"334\":2,\"335\":3},\"1\":{\"26\":2,\"29\":1,\"39\":1,\"80\":1,\"84\":1,\"85\":3,\"89\":2,\"110\":2,\"111\":1,\"113\":1,\"119\":1,\"127\":3,\"129\":2,\"131\":1,\"134\":4,\"138\":3,\"139\":1,\"146\":1,\"154\":1,\"159\":2,\"162\":1,\"165\":1,\"171\":1,\"260\":5,\"261\":5,\"263\":1,\"264\":1,\"267\":4,\"268\":3}}],[\"记录元素第一次出现的位置\",{\"1\":{\"26\":1}}],[\"rst\",{\"0\":{\"453\":1}}],[\"rbd\",{\"1\":{\"165\":1}}],[\"rpush\",{\"1\":{\"143\":1}}],[\"rpop\",{\"1\":{\"127\":1,\"133\":1,\"134\":3,\"143\":1,\"144\":1}}],[\"rpad\",{\"1\":{\"84\":1}}],[\"rose\",{\"1\":{\"87\":1}}],[\"round\",{\"1\":{\"85\":4}}],[\"row编码是用来存储长字符串的\",{\"1\":{\"138\":1}}],[\"row\",{\"1\":{\"27\":4}}],[\"rows\",{\"1\":{\"27\":2}}],[\"rcvd\",{\"1\":{\"62\":1}}],[\"rdb文件有两个阶段\",{\"1\":{\"193\":1}}],[\"rdb持久化大key的影响\",{\"1\":{\"171\":1}}],[\"rdb\",{\"0\":{\"170\":1},\"1\":{\"38\":1,\"40\":1,\"41\":4,\"125\":5,\"127\":10,\"129\":1,\"131\":5,\"134\":7,\"165\":1,\"170\":1,\"171\":5,\"193\":10}}],[\"runid\",{\"1\":{\"174\":1}}],[\"run\",{\"1\":{\"37\":1}}],[\"rune\",{\"1\":{\"29\":1}}],[\"raw\",{\"1\":{\"138\":1}}],[\"raw和\",{\"1\":{\"138\":1}}],[\"rate\",{\"1\":{\"38\":1}}],[\"ratelimitermiddleware\",{\"1\":{\"37\":1,\"38\":1}}],[\"randint\",{\"1\":{\"262\":1,\"268\":1}}],[\"random\",{\"1\":{\"110\":1,\"111\":1}}],[\"rand\",{\"1\":{\"85\":4}}],[\"range\",{\"1\":{\"29\":1,\"127\":1,\"262\":5,\"268\":5}}],[\"rank\",{\"1\":{\"27\":3}}],[\"r\",{\"1\":{\"37\":4,\"269\":3}}],[\"rn\",{\"1\":{\"27\":1}}],[\"right=len\",{\"1\":{\"26\":1}}],[\"right=mid\",{\"1\":{\"26\":4}}],[\"right\",{\"1\":{\"26\":4}}],[\"ringht\",{\"1\":{\"26\":1}}],[\"renerse=true\",{\"1\":{\"265\":1}}],[\"remove\",{\"1\":{\"261\":1,\"270\":1}}],[\"removejwt\",{\"1\":{\"41\":1}}],[\"replace\",{\"1\":{\"266\":1}}],[\"replication\",{\"1\":{\"176\":1}}],[\"replicaof\",{\"1\":{\"174\":1,\"175\":1}}],[\"repl\",{\"1\":{\"176\":6}}],[\"releaselock\",{\"1\":{\"125\":3,\"131\":2}}],[\"recently\",{\"1\":{\"113\":1}}],[\"record\",{\"0\":{\"99\":1},\"1\":{\"99\":1}}],[\"readline\",{\"1\":{\"269\":1}}],[\"readlines\",{\"1\":{\"269\":1}}],[\"read\",{\"1\":{\"92\":1,\"94\":1,\"96\":1,\"269\":3}}],[\"references\",{\"1\":{\"90\":5}}],[\"refill\",{\"1\":{\"38\":1}}],[\"revoke\",{\"1\":{\"73\":1}}],[\"revoked\",{\"1\":{\"41\":1}}],[\"revoketoken\",{\"1\":{\"41\":1}}],[\"req\",{\"1\":{\"40\":5}}],[\"request\",{\"1\":{\"38\":1,\"40\":1}}],[\"registeredclaims\",{\"1\":{\"40\":3}}],[\"redis就将这个key和我们设置的过期时间保存到过期字典\",{\"1\":{\"189\":1}}],[\"redis过期删除\",{\"0\":{\"189\":1}}],[\"redis持久化\",{\"0\":{\"165\":1}}],[\"redis采用\",{\"1\":{\"189\":1}}],[\"redis采用单线程的原因\",{\"1\":{\"163\":1}}],[\"redis采用i\",{\"1\":{\"163\":1}}],[\"redis单线程模型避免多线程之间的竞争\",{\"1\":{\"163\":1}}],[\"redis单线程还这么快\",{\"0\":{\"163\":1}}],[\"redis没有为embstr编码的字符串对象编写任何相应的修改程序\",{\"1\":{\"138\":1}}],[\"redis常用的数据类型\",{\"0\":{\"135\":1}}],[\"redis不回去对执行成功的命令进行回滚\",{\"1\":{\"129\":1}}],[\"redis提供事务支持\",{\"1\":{\"129\":1}}],[\"redis中并没有提供回滚机制\",{\"1\":{\"129\":1}}],[\"redis是基于内存的\",{\"1\":{\"163\":1}}],[\"redis是单线程的吗\",{\"0\":{\"162\":1}}],[\"redis是\",{\"0\":{\"161\":1}}],[\"redis是否支持回滚操作\",{\"0\":{\"129\":1}}],[\"redis是如何实现lfu算法的\",{\"1\":{\"114\":1}}],[\"redis是如何实现lru算法的\",{\"1\":{\"113\":1}}],[\"redis的切片集群模式\",{\"0\":{\"183\":1}}],[\"redis的主从复制\",{\"0\":{\"172\":1}}],[\"redis的性能瓶颈也会出现在网络i\",{\"1\":{\"163\":1}}],[\"redis的事务\",{\"0\":{\"128\":1}}],[\"redis的内存淘汰\",{\"0\":{\"106\":1}}],[\"redis关闭成功\",{\"1\":{\"125\":1,\"127\":1,\"131\":1}}],[\"redis连接成功\",{\"1\":{\"125\":1,\"127\":1,\"131\":1}}],[\"redis服务宕机造成缓存雪崩\",{\"0\":{\"117\":1}}],[\"redis对象头的\",{\"1\":{\"114\":1}}],[\"redis可以根据对象头中的\",{\"1\":{\"114\":1}}],[\"redis3\",{\"1\":{\"108\":1,\"110\":1}}],[\"redis支持管道\",{\"1\":{\"129\":1}}],[\"redis支持数据的持久化\",{\"1\":{\"105\":1}}],[\"redis支持的数据类型丰富\",{\"1\":{\"105\":1}}],[\"redis和memcached的区别\",{\"0\":{\"105\":1}}],[\"redis最主动的特点就是高性能\",{\"1\":{\"104\":1}}],[\"redis\",{\"0\":{\"104\":1,\"134\":1,\"502\":1},\"1\":{\"38\":2,\"40\":1,\"41\":4,\"105\":2,\"107\":2,\"110\":1,\"111\":1,\"113\":6,\"114\":1,\"123\":2,\"125\":5,\"127\":14,\"129\":4,\"131\":7,\"133\":3,\"134\":19,\"138\":1,\"142\":3,\"146\":2,\"154\":3,\"162\":6,\"165\":1,\"166\":3,\"169\":2,\"170\":1,\"171\":5,\"177\":3,\"182\":1,\"184\":4,\"191\":2,\"193\":6,\"194\":1}}],[\"response\",{\"1\":{\"260\":5}}],[\"restrict\",{\"1\":{\"90\":1}}],[\"restrict一致\",{\"1\":{\"90\":1}}],[\"restful\",{\"1\":{\"71\":1}}],[\"res1\",{\"1\":{\"87\":2}}],[\"result6\",{\"1\":{\"267\":2}}],[\"result5\",{\"1\":{\"267\":2}}],[\"result4\",{\"1\":{\"267\":2}}],[\"result3\",{\"1\":{\"267\":2}}],[\"result2\",{\"1\":{\"267\":2}}],[\"result1\",{\"1\":{\"267\":2}}],[\"result=compute\",{\"1\":{\"264\":1}}],[\"result\",{\"1\":{\"38\":1,\"125\":4,\"127\":2,\"129\":2,\"131\":6,\"134\":2,\"159\":2,\"264\":2}}],[\"resource\",{\"0\":{\"32\":1}}],[\"res\",{\"1\":{\"26\":6}}],[\"return\",{\"1\":{\"19\":1,\"26\":5,\"29\":2,\"37\":1,\"38\":11,\"39\":3,\"40\":6,\"41\":2,\"125\":9,\"127\":2,\"129\":3,\"131\":9,\"260\":1,\"264\":3}}],[\"returns\",{\"1\":{\"19\":1}}],[\"然后会\",{\"0\":{\"482\":1}}],[\"然后会有redis的缓存淘汰机制\",{\"1\":{\"116\":1}}],[\"然后生产http请求消息\",{\"0\":{\"482\":1}}],[\"然后等待下一轮再检查\",{\"1\":{\"191\":1}}],[\"然后复制新主节点的数据\",{\"1\":{\"187\":1}}],[\"然后就是将槽映射到redis上\",{\"1\":{\"184\":1}}],[\"然后哨兵就可以和从节点链接了\",{\"1\":{\"182\":1}}],[\"然后哨兵就需要重新选择主节点\",{\"1\":{\"179\":1}}],[\"然后一秒一次info观察角色信息\",{\"1\":{\"181\":1}}],[\"然后来决定对从服务器执行哪种同步操作\",{\"1\":{\"176\":1}}],[\"然后可以将复制交给这个有从库的从库\",{\"1\":{\"175\":1}}],[\"然后载入rdb文件\",{\"1\":{\"174\":1}}],[\"然后发送给从服务器\",{\"1\":{\"174\":1}}],[\"然后发送方就可以根据接收端和本端窗口大小继续发送数据\",{\"1\":{\"57\":1}}],[\"然后执行\",{\"1\":{\"173\":1}}],[\"然后主线程处理的操作命令会被记录在重写缓冲区里\",{\"1\":{\"171\":1}}],[\"然后将每一个键值对用一条命令记录到新的\",{\"1\":{\"168\":1}}],[\"然后将数据库中未修改的数据更新到缓存中\",{\"1\":{\"123\":1}}],[\"然后将数据发给所有的请求\",{\"1\":{\"116\":1}}],[\"然后再执行修改命令\",{\"1\":{\"138\":1}}],[\"然后第一个请求去修改数据库中的数据\",{\"1\":{\"123\":1}}],[\"然后在更新数据库前\",{\"1\":{\"122\":1}}],[\"然后在更新缓存前\",{\"1\":{\"122\":1}}],[\"然后\",{\"1\":{\"122\":2}}],[\"然后后台可以在更新前检查一下缓存状态\",{\"1\":{\"116\":1}}],[\"然后这个请求发生了某种意外而一直阻塞\",{\"1\":{\"116\":1}}],[\"然后淘汰最久没有使用的那个\",{\"1\":{\"113\":1}}],[\"然后设置锁的状态\",{\"1\":{\"102\":1}}],[\"然后给该字段赋值一个自增的值\",{\"1\":{\"97\":1}}],[\"然后为被\",{\"1\":{\"97\":1}}],[\"然后对读取的记录加独占锁\",{\"1\":{\"96\":1}}],[\"然后对读取的记录加共享锁\",{\"1\":{\"96\":1}}],[\"然后去查询第二次的位置\",{\"1\":{\"26\":1}}],[\"然后返回接下来的\",{\"1\":{\"21\":1}}],[\"具体要先查询第一次出现的位置\",{\"1\":{\"26\":1}}],[\"允许重复的行\",{\"1\":{\"24\":1}}],[\">=60\",{\"1\":{\"87\":1}}],[\">=85\",{\"1\":{\"87\":1}}],[\">=\",{\"1\":{\"39\":1,\"79\":1,\"87\":2,\"127\":1}}],[\">=target\",{\"1\":{\"26\":1}}],[\">target\",{\"1\":{\"26\":2}}],[\">\",{\"1\":{\"24\":1,\"29\":1,\"39\":2,\"79\":2,\"80\":1,\"87\":2,\"89\":1,\"139\":17,\"268\":4}}],[\"tuple进行切片\",{\"1\":{\"267\":1}}],[\"tuple\",{\"1\":{\"265\":2,\"267\":5,\"268\":1}}],[\"tupel\",{\"1\":{\"263\":1}}],[\"t2\",{\"1\":{\"263\":3}}],[\"t1\",{\"1\":{\"263\":3}}],[\"tlb\",{\"0\":{\"230\":1}}],[\"title\",{\"1\":{\"266\":1}}],[\"ticker\",{\"1\":{\"127\":2}}],[\"timeout\",{\"1\":{\"143\":2}}],[\"timestamp\",{\"1\":{\"127\":2}}],[\"time\",{\"0\":{\"69\":1,\"349\":1,\"350\":1,\"351\":1,\"352\":1,\"353\":1,\"379\":1,\"453\":1},\"1\":{\"38\":1,\"39\":6,\"40\":5,\"68\":1,\"69\":1,\"123\":1,\"125\":6,\"127\":8,\"131\":4,\"134\":2}}],[\"ttl\",{\"1\":{\"110\":1,\"139\":1}}],[\"tcp四次挥手可以变成三次吗\",{\"0\":{\"446\":1}}],[\"tcp四次挥手性能的提升\",{\"0\":{\"383\":1}}],[\"tcp断开连接\",{\"0\":{\"440\":1}}],[\"tcpkill\",{\"0\":{\"437\":1}}],[\"tcp连接\",{\"0\":{\"456\":1}}],[\"tcp连接的断开\",{\"0\":{\"439\":1}}],[\"tcp连接的建立\",{\"0\":{\"423\":1,\"424\":1}}],[\"tcp连接会消失吗\",{\"0\":{\"397\":1}}],[\"tcp半连接队列和全连接队列\",{\"0\":{\"395\":1}}],[\"tcp工作在那一层\",{\"0\":{\"388\":1}}],[\"tcp基本认识\",{\"0\":{\"386\":1}}],[\"tcp传输数据的性能提升\",{\"0\":{\"384\":1}}],[\"tcp三次握手的性能提升\",{\"0\":{\"382\":1}}],[\"tcp和ping数据的区别\",{\"0\":{\"333\":1}}],[\"tcp和udp可以同时绑定相同的端口吗\",{\"0\":{\"372\":1,\"373\":1}}],[\"tcp和udp是传输层常见的两种传输协议\",{\"1\":{\"51\":1}}],[\"tcp和udp的区别\",{\"0\":{\"51\":1,\"358\":1,\"360\":1}}],[\"tcp\",{\"0\":{\"319\":1,\"376\":1,\"379\":1,\"394\":1,\"433\":1,\"463\":1,\"509\":1}}],[\"tcp与tls的握手延迟\",{\"0\":{\"297\":1}}],[\"tcp的四次挥手\",{\"0\":{\"441\":1}}],[\"tcp的重传机制\",{\"0\":{\"417\":1,\"418\":1}}],[\"tcp的流量控制\",{\"0\":{\"406\":1}}],[\"tcp的拥塞控制\",{\"0\":{\"400\":1}}],[\"tcp的头格式\",{\"0\":{\"387\":1}}],[\"tcp的基本认识\",{\"0\":{\"385\":1}}],[\"tcp的优化\",{\"0\":{\"380\":1}}],[\"tcp的socket编程\",{\"0\":{\"361\":1}}],[\"tcp的三次握手和四次挥手\",{\"0\":{\"59\":1}}],[\"tcp的特点是\",{\"1\":{\"51\":1}}],[\"tcp时一个面向字节流的协议\",{\"1\":{\"56\":1}}],[\"tcp是如何保证有序的\",{\"0\":{\"55\":1}}],[\"tcp是如何保证可靠的\",{\"0\":{\"53\":1}}],[\"tcp是如何做链接管理的\",{\"0\":{\"52\":1}}],[\"tcp在连接时使用三次握手\",{\"1\":{\"52\":1}}],[\"test\",{\"1\":{\"40\":1,\"264\":6}}],[\"teacher\",{\"1\":{\"25\":3}}],[\"tb\",{\"1\":{\"39\":14}}],[\"type\",{\"1\":{\"39\":1,\"40\":2,\"86\":1,\"260\":6,\"261\":1,\"264\":3,\"265\":1,\"268\":9}}],[\"traceroute\",{\"0\":{\"330\":1}}],[\"trim\",{\"1\":{\"84\":1}}],[\"trimprefix\",{\"1\":{\"38\":1}}],[\"true本质上是一个数字记作1\",{\"1\":{\"268\":1}}],[\"true表示真\",{\"1\":{\"268\":1}}],[\"true降序\",{\"1\":{\"265\":1}}],[\"true\",{\"1\":{\"29\":1,\"39\":1,\"40\":1,\"41\":1,\"87\":1,\"261\":1}}],[\"tom\",{\"1\":{\"87\":1,\"260\":4}}],[\"tool\",{\"0\":{\"49\":1}}],[\"to\",{\"1\":{\"40\":1,\"73\":1}}],[\"token\",{\"1\":{\"38\":12,\"40\":6,\"41\":4}}],[\"tokenstring\",{\"1\":{\"38\":3,\"40\":3,\"41\":2}}],[\"tokens\",{\"1\":{\"38\":1,\"39\":7}}],[\"tokenbucket\",{\"1\":{\"38\":2,\"39\":4}}],[\"todo\",{\"1\":{\"27\":1}}],[\"t\",{\"1\":{\"29\":2,\"87\":1,\"260\":11,\"262\":2,\"263\":1,\"268\":2}}],[\"tall<120\",{\"1\":{\"262\":1,\"268\":1}}],[\"tall=int\",{\"1\":{\"262\":1,\"268\":1}}],[\"task\",{\"1\":{\"127\":7,\"134\":10}}],[\"tasks\",{\"1\":{\"127\":2}}],[\"task1\",{\"1\":{\"127\":1,\"134\":1}}],[\"take\",{\"1\":{\"38\":1,\"39\":1}}],[\"target+1\",{\"1\":{\"26\":1}}],[\"target\",{\"1\":{\"26\":4}}],[\"tables\",{\"1\":{\"92\":2,\"94\":3,\"96\":2}}],[\"table\",{\"1\":{\"87\":1,\"89\":1,\"90\":9,\"94\":2}}],[\"table2\",{\"1\":{\"23\":2,\"24\":2}}],[\"table1\",{\"1\":{\"23\":2,\"24\":2}}],[\"then\",{\"1\":{\"24\":3,\"87\":6,\"131\":1}}],[\"但元组中的list可以修改\",{\"1\":{\"263\":1}}],[\"但由于主从服务器在进行数据同步时\",{\"1\":{\"193\":1}}],[\"但不同之处在于embstr会通过一次内存分配函数来分配一块连续的内存空间来保存redisobject和sds\",{\"1\":{\"138\":1}}],[\"但不包括重复的行\",{\"1\":{\"23\":1}}],[\"但这只是理论上的\",{\"1\":{\"123\":1}}],[\"但这也会带来性能问题\",{\"1\":{\"122\":1}}],[\"但是字典\",{\"1\":{\"265\":1}}],[\"但是只有候选者才能把票投给自己\",{\"1\":{\"180\":1}}],[\"但是内核会把父进程的页表复制一份给子进程\",{\"1\":{\"171\":1}}],[\"但是在这个过程中客户端和主节点是联通的还在通信\",{\"1\":{\"187\":1}}],[\"但是在\",{\"1\":{\"142\":1}}],[\"但是在语句执行完毕之后不会立即释放\",{\"1\":{\"95\":1}}],[\"但是\",{\"1\":{\"138\":1}}],[\"但是这个命令只能去主动放弃事务的执行\",{\"1\":{\"129\":1}}],[\"但是现在处于等待状态\",{\"1\":{\"102\":1}}],[\"但是并没有什么区别\",{\"1\":{\"100\":1}}],[\"但是不可以对该记录加\",{\"1\":{\"99\":1}}],[\"但是超时重传和快速重传都具有一个问题\",{\"1\":{\"54\":1}}],[\"但是排名不会跳过\",{\"1\":{\"27\":1}}],[\"但相对不可靠的数据传输\",{\"1\":{\"51\":1}}],[\"但它不会去除重复的行\",{\"1\":{\"24\":1}}],[\"也省去了多线程之间切换带来的时间和性能上的开销\",{\"1\":{\"163\":1}}],[\"也放到队列中\",{\"1\":{\"162\":1}}],[\"也即每个列表支持超过\",{\"1\":{\"142\":1}}],[\"也即再次进入拥塞避免状态\",{\"1\":{\"58\":1}}],[\"也有缺点的\",{\"1\":{\"138\":1}}],[\"也不会中止后续命令的执行\",{\"1\":{\"129\":1}}],[\"也不可以对该记录加\",{\"1\":{\"99\":1}}],[\"也是比较耗时的\",{\"1\":{\"171\":1}}],[\"也是后面回去数据库直接查找数据\",{\"1\":{\"123\":1}}],[\"也是一个整数\",{\"1\":{\"21\":1}}],[\"也仅仅只是一会\",{\"1\":{\"122\":1}}],[\"也会因为并发问题\",{\"1\":{\"122\":1}}],[\"也会发生缓存穿透\",{\"1\":{\"119\":1}}],[\"也包含间隙锁\",{\"1\":{\"102\":1}}],[\"也就是即使从库中的\",{\"1\":{\"194\":1}}],[\"也就是内存可以被尽快地释放\",{\"1\":{\"192\":1}}],[\"也就是主服务器的所有数据全部同步到从服务器\",{\"1\":{\"174\":1}}],[\"也就是\",{\"1\":{\"162\":1,\"191\":1}}],[\"也就是说\",{\"1\":{\"129\":1}}],[\"也就是写锁\",{\"1\":{\"94\":1}}],[\"也就是读锁\",{\"1\":{\"94\":1}}],[\"也可以查看变量的数据类型\",{\"1\":{\"268\":1}}],[\"也可以省去as\",{\"1\":{\"79\":1}}],[\"也可能多个小的数据包会被合并成一个大数据包发送\",{\"1\":{\"56\":1}}],[\"也用于合并两个或多个查询的结果\",{\"1\":{\"24\":1}}],[\"并发传输\",{\"0\":{\"293\":1}}],[\"并删除已过期的\",{\"1\":{\"191\":1}}],[\"并删除其中的过期key\",{\"1\":{\"191\":1}}],[\"并将其转换为主节点\",{\"1\":{\"181\":1}}],[\"并把主节点的相关信息通知给从节点和客户端\",{\"1\":{\"178\":1}}],[\"并接受服务器同步过来写操作命令\",{\"1\":{\"173\":1}}],[\"并集计算\",{\"1\":{\"155\":1}}],[\"并集运算\",{\"1\":{\"151\":1}}],[\"并\",{\"1\":{\"152\":1}}],[\"并设置该key的过期时间为\",{\"1\":{\"139\":1}}],[\"并没有传统意义上的\",{\"1\":{\"129\":1}}],[\"并处理到期任务\",{\"1\":{\"127\":1}}],[\"并存到缓存中\",{\"1\":{\"123\":1}}],[\"并不是意味着事务成功获取到了锁\",{\"1\":{\"102\":1}}],[\"并不存在互斥关系\",{\"1\":{\"100\":1}}],[\"并根据入职天数倒序排序\",{\"1\":{\"86\":1}}],[\"并根据序列号进行排序和重新组装\",{\"1\":{\"55\":1}}],[\"并对查询结果按年龄升序排序\",{\"1\":{\"80\":1}}],[\"并获取人数大于三的工作地址\",{\"1\":{\"80\":1}}],[\"并计算年龄平均值\",{\"1\":{\"80\":1}}],[\"并计算总和\",{\"1\":{\"80\":1}}],[\"并跟据本端剩余缓冲区大小通告对方当前能接受数据的缓冲区大小\",{\"1\":{\"57\":1}}],[\"并在tcp连接建立之后开辟出一片缓冲区\",{\"1\":{\"57\":1}}],[\"并且每个元素的值小于\",{\"1\":{\"154\":1}}],[\"并且加锁时间没有超过锁的有效时间\",{\"1\":{\"131\":1}}],[\"并且事务中的命令不会执行\",{\"1\":{\"129\":1}}],[\"并且如果a的数据缓存更新在b删除缓存之前\",{\"1\":{\"123\":1}}],[\"并且清空缓存\",{\"1\":{\"123\":1}}],[\"并且年龄在20\",{\"1\":{\"80\":1}}],[\"并且\",{\"1\":{\"79\":1,\"138\":1}}],[\"并且在等最后的确认报文\",{\"1\":{\"69\":1}}],[\"并且在其中客户端还会选择一个isn\",{\"1\":{\"61\":1}}],[\"并且这个报文字段包含客户端收到的服务端的isn\",{\"1\":{\"63\":1}}],[\"并且重发这个包\",{\"1\":{\"54\":1}}],[\"并且结果集中的每行都是唯一的\",{\"1\":{\"23\":1}}],[\"并阻止后续的中间件和处理函数的执行\",{\"1\":{\"38\":1}}],[\"并合并结果集\",{\"1\":{\"23\":1,\"24\":1}}],[\"和独占表锁\",{\"1\":{\"96\":1}}],[\"和网络的负担\",{\"1\":{\"54\":1}}],[\"和\",{\"1\":{\"23\":1,\"24\":1,\"109\":1,\"119\":1,\"127\":1,\"133\":1,\"134\":1,\"159\":2,\"165\":1,\"169\":1}}],[\"示例\",{\"1\":{\"23\":1,\"24\":1,\"268\":1}}],[\"用了tcp传输数据就一定不会丢包吗\",{\"0\":{\"399\":1}}],[\"用for循环读取每一行\",{\"1\":{\"269\":1}}],[\"用for遍历\",{\"1\":{\"263\":1}}],[\"用三个空格补足\",{\"1\":{\"268\":1}}],[\"用key获取value\",{\"1\":{\"265\":1}}],[\"用while遍历元组\",{\"1\":{\"263\":1}}],[\"用补码的形式保存负数\",{\"0\":{\"251\":1}}],[\"用bit来进行0|1的设置\",{\"1\":{\"158\":1}}],[\"用一串连续的二进制数组\",{\"1\":{\"158\":1}}],[\"用字符串pad对str的右边进行填充\",{\"1\":{\"84\":1}}],[\"用字符串pad对str的左边进行填充\",{\"1\":{\"84\":1}}],[\"用来异步释放\",{\"1\":{\"162\":1}}],[\"用来记录\",{\"1\":{\"114\":2}}],[\"用来让两张表的数据之间建立连接\",{\"1\":{\"89\":1}}],[\"用来查询数据库中表的记录\",{\"1\":{\"79\":1}}],[\"用来对数据库表中的数据进行增删改查\",{\"1\":{\"77\":1}}],[\"用来创建数据库用户\",{\"1\":{\"73\":1}}],[\"用于主从服务器断连后\",{\"1\":{\"176\":1}}],[\"用于处理异步任务或消息传递\",{\"1\":{\"133\":1}}],[\"用于记录此数据的最后一次访问时间\",{\"1\":{\"113\":1}}],[\"用于限制存储在表中的数据\",{\"1\":{\"89\":1}}],[\"用于通知发送方哪些数据被重复接收了\",{\"1\":{\"54\":1}}],[\"用于合并两个或多个查询的结果\",{\"1\":{\"23\":1}}],[\"用户态和内核态\",{\"0\":{\"475\":1}}],[\"用户表\",{\"1\":{\"89\":1}}],[\"用户名\",{\"1\":{\"73\":6}}],[\"用户扫码是如何实现的\",{\"0\":{\"45\":1}}],[\"用户登录\",{\"0\":{\"42\":1}}],[\"用go语言实现jwt登录认证\",{\"1\":{\"36\":1}}],[\"用list的方法查询\",{\"1\":{\"261\":1}}],[\"用limit限制返回一行数据\",{\"1\":{\"28\":1}}],[\"用like查找含有diab1为前缀的conditions\",{\"1\":{\"18\":1}}],[\"用distinct去重\",{\"1\":{\"25\":1}}],[\"2个空格补足宽度\",{\"1\":{\"268\":1}}],[\"2f后\",{\"1\":{\"268\":1}}],[\"2f\",{\"1\":{\"268\":3}}],[\"2=\",{\"1\":{\"268\":1}}],[\"2输出结果\",{\"1\":{\"268\":1}}],[\"25ms\",{\"1\":{\"191\":1}}],[\"25\",{\"1\":{\"191\":2}}],[\"2^32\",{\"1\":{\"142\":1}}],[\"23\",{\"1\":{\"80\":1,\"87\":1}}],[\"23岁的员工信息\",{\"1\":{\"80\":1}}],[\"2356\",{\"0\":{\"25\":1},\"1\":{\"25\":1}}],[\"22\",{\"1\":{\"80\":2}}],[\"21\",{\"1\":{\"80\":2,\"123\":1}}],[\"2024\",{\"1\":{\"86\":1}}],[\"2018\",{\"1\":{\"86\":1}}],[\"20\",{\"1\":{\"79\":4,\"80\":1,\"87\":1,\"90\":2,\"123\":2,\"191\":3,\"264\":2}}],[\"2006\",{\"1\":{\"268\":1}}],[\"2004\",{\"1\":{\"90\":2}}],[\"2002\",{\"1\":{\"90\":1}}],[\"2005\",{\"1\":{\"90\":1}}],[\"2000\",{\"1\":{\"90\":2}}],[\"20000\",{\"1\":{\"24\":2,\"90\":1}}],[\"200\",{\"1\":{\"41\":1}}],[\"2msl\",{\"0\":{\"349\":1},\"1\":{\"68\":1}}],[\"2状态\",{\"1\":{\"66\":1}}],[\"24\",{\"1\":{\"40\":1,\"114\":2}}],[\"2\",{\"0\":{\"21\":1,\"44\":1,\"45\":1,\"52\":1,\"62\":1,\"66\":1,\"111\":1,\"141\":1,\"227\":1,\"285\":1,\"288\":1,\"297\":1,\"299\":1,\"301\":1,\"314\":1,\"321\":1,\"363\":1,\"374\":1,\"420\":1,\"483\":1,\"489\":1},\"1\":{\"26\":3,\"54\":1,\"56\":1,\"58\":2,\"73\":2,\"77\":1,\"79\":1,\"80\":1,\"85\":2,\"87\":1,\"90\":4,\"122\":4,\"125\":2,\"127\":1,\"131\":1,\"139\":1,\"142\":1,\"162\":2,\"260\":3,\"261\":11,\"262\":2,\"263\":3,\"264\":2,\"265\":1,\"266\":1,\"267\":7,\"268\":25,\"270\":8}}],[\"这是一个\",{\"1\":{\"268\":4}}],[\"这四类元素\",{\"1\":{\"268\":1}}],[\"这里使用子进程而不是线程\",{\"1\":{\"169\":1}}],[\"这里可以加入任务处理逻辑\",{\"1\":{\"134\":2}}],[\"这里的内容是\",{\"1\":{\"171\":1}}],[\"这里的\",{\"1\":{\"20\":1}}],[\"这意味着\",{\"1\":{\"129\":1}}],[\"这时候我们就可以采用消息队列重试机制\",{\"1\":{\"123\":1}}],[\"这时请求a\",{\"1\":{\"123\":1}}],[\"这时其他请求也一直拿不到锁\",{\"1\":{\"116\":1}}],[\"这就是两步\",{\"1\":{\"140\":1}}],[\"这就是穿透\",{\"1\":{\"119\":1}}],[\"这就会导致最终数据库中的数据和缓存中的数据不一致\",{\"1\":{\"123\":1}}],[\"这就要求该外键允许取null\",{\"1\":{\"90\":1}}],[\"这些被淘汰的数据是无法展示给数据库的\",{\"1\":{\"116\":1}}],[\"这会带来额外的空间开销\",{\"1\":{\"113\":1}}],[\"这两类策略\",{\"1\":{\"109\":1}}],[\"这类sql开发人员操作的比较少\",{\"1\":{\"73\":1}}],[\"这个缓冲区在创建\",{\"1\":{\"169\":1}}],[\"这个数据就会有丢失的风险\",{\"1\":{\"166\":1}}],[\"这个过程是由一个线程\",{\"1\":{\"162\":1}}],[\"这个命令仍然会执行\",{\"1\":{\"129\":1}}],[\"这个命令将失败\",{\"1\":{\"129\":1}}],[\"这个命令将成功\",{\"1\":{\"129\":1}}],[\"这个策略又可以分为\",{\"1\":{\"109\":1}}],[\"这个时候就会触发全量复制\",{\"1\":{\"187\":1}}],[\"这个时候就需要进行内存淘汰了\",{\"1\":{\"107\":1}}],[\"这个时候客户端就可以收到这条信息\",{\"1\":{\"181\":1}}],[\"这个时候在tcp报文段中\",{\"1\":{\"55\":1}}],[\"这个阀值就是我们设置的最大运行内存此值在\",{\"1\":{\"107\":1}}],[\"这个示例将从\",{\"1\":{\"23\":1,\"24\":1}}],[\"这样加载的时候速度会很快\",{\"1\":{\"171\":1}}],[\"这样的好处在于\",{\"1\":{\"171\":1}}],[\"这样可以避免主线程的阻塞\",{\"1\":{\"170\":1}}],[\"这样可以在后面解除锁的时候\",{\"1\":{\"131\":1}}],[\"这样可能会造成内存负担\",{\"1\":{\"116\":1}}],[\"这样哪怕出现数据不一致的问题\",{\"1\":{\"122\":1}}],[\"这样后续请求就可以从缓存中读取到空值或者默认值\",{\"1\":{\"119\":1}}],[\"这样也不能构建缓存\",{\"1\":{\"119\":1}}],[\"这样如果出现数据丢失\",{\"1\":{\"54\":1}}],[\"这样外层查询在无数据查询的情况下会返回一个null\",{\"1\":{\"19\":1}}],[\"这表示在每个分区内\",{\"1\":{\"27\":2}}],[\"这表示窗口函数将按\",{\"1\":{\"27\":2}}],[\"这种语法用于跳过查询结果的前\",{\"1\":{\"21\":1}}],[\"这种语法用于从查询结果的第\",{\"1\":{\"20\":1}}],[\"这种语法通常用于分页或获取某一个特定位置的记录\",{\"1\":{\"20\":1}}],[\"赋值\",{\"1\":{\"19\":1}}],[\"声明了一个变量\",{\"1\":{\"19\":1}}],[\"子进程带有主进程的数据副本\",{\"1\":{\"169\":1}}],[\"子进程进行\",{\"1\":{\"169\":1}}],[\"子表将外键列设置成一个默认的值\",{\"1\":{\"90\":1}}],[\"子句中使用\",{\"1\":{\"19\":1}}],[\"子查询找到最大的\",{\"1\":{\"19\":1}}],[\"在委托操作系统发送消息时必须提供\",{\"0\":{\"483\":1}}],[\"在time\",{\"0\":{\"450\":1}}],[\"在tcp连接建立完成之后\",{\"1\":{\"58\":1}}],[\"在tcp建立连接的时候\",{\"1\":{\"57\":1}}],[\"在tcp头部加一个sack字段在每次接收完数据之后\",{\"1\":{\"54\":1}}],[\"在集合1里面删除与集合2相同的元素\",{\"1\":{\"270\":1}}],[\"在已有文件后面追加写\",{\"1\":{\"269\":1}}],[\"在已下线主节点\",{\"1\":{\"181\":1}}],[\"在查就没有数据了\",{\"1\":{\"269\":1}}],[\"在执行的时候要把上面的读取注释掉\",{\"1\":{\"269\":1}}],[\"在原有的内容该后面追加\",{\"1\":{\"269\":1}}],[\"在字符串内\",{\"1\":{\"268\":2}}],[\"在函数内部定义的是局部变量\",{\"1\":{\"264\":1}}],[\"在函数外面定义的是全局变量\",{\"1\":{\"264\":1}}],[\"在0到\",{\"1\":{\"262\":1,\"268\":1}}],[\"在指定的下标处插入某个元素\",{\"1\":{\"261\":1}}],[\"在python中一个list可以保存多个数据类型不同的元素\",{\"1\":{\"261\":1}}],[\"在载入\",{\"1\":{\"193\":2}}],[\"在内存不紧张\",{\"1\":{\"192\":1}}],[\"在过期\",{\"1\":{\"192\":1}}],[\"在设置\",{\"1\":{\"192\":1}}],[\"在设置了过期时间的数据中进行淘汰\",{\"0\":{\"110\":1},\"1\":{\"109\":1}}],[\"在使用cluster\",{\"1\":{\"184\":1}}],[\"在使用日志恢复数据时\",{\"1\":{\"166\":1}}],[\"在进行每一轮考察的时候\",{\"1\":{\"181\":1}}],[\"在主从库中如何确定对方还活着\",{\"0\":{\"177\":1}}],[\"在主服务器进行命令传播时\",{\"1\":{\"176\":1}}],[\"在主节点崩溃后服务也可以正常运行\",{\"1\":{\"117\":1}}],[\"在网络断开之后恢复\",{\"1\":{\"176\":1}}],[\"在从服务器重新连接主服务器时\",{\"1\":{\"176\":1}}],[\"在从服务器完成rdb的载入之后\",{\"1\":{\"174\":1}}],[\"在从库中计算返回数据给主库\",{\"1\":{\"152\":1}}],[\"在通过\",{\"1\":{\"171\":1}}],[\"在快照期间\",{\"1\":{\"170\":1}}],[\"在重写aof\",{\"1\":{\"169\":1}}],[\"在还没来得及将命令写入到硬盘时\",{\"1\":{\"166\":1}}],[\"在启动的时候\",{\"1\":{\"162\":1}}],[\"在数据量较大的时候\",{\"1\":{\"152\":1}}],[\"在数据都是整数且小于512个使用整数集合\",{\"1\":{\"150\":1}}],[\"在数据库中加入数据的时候\",{\"1\":{\"119\":1}}],[\"在数据库中不需要直接加上元数据锁\",{\"1\":{\"95\":1}}],[\"在数据库被大量调用的时候\",{\"1\":{\"95\":1}}],[\"在resids中执行lua脚本是可以以原子性进行\",{\"1\":{\"140\":1}}],[\"在redis\",{\"1\":{\"184\":1}}],[\"在redis集群下\",{\"1\":{\"131\":1}}],[\"在redis宕机的时候\",{\"1\":{\"117\":1}}],[\"在redis中大体有两种策略\",{\"1\":{\"107\":1}}],[\"在此之前需要判断这个客户端是不是加锁的那个\",{\"1\":{\"140\":1}}],[\"在此期间会生成一个插入意向锁\",{\"1\":{\"102\":1}}],[\"在拼接字符串之前会检查sds\",{\"1\":{\"138\":1}}],[\"在微服务架构中\",{\"1\":{\"134\":1}}],[\"在任务量较大时\",{\"1\":{\"134\":1}}],[\"在加锁的时候\",{\"1\":{\"131\":1}}],[\"在管道中添加多个命令\",{\"1\":{\"129\":1}}],[\"在这个例子中\",{\"1\":{\"129\":2}}],[\"在这期间另一个请求去读取数据\",{\"1\":{\"123\":1}}],[\"在实际中缓存写入是远比数据库写入快的\",{\"1\":{\"123\":1}}],[\"在未写入缓存中时另一个请求\",{\"1\":{\"123\":1}}],[\"在删除缓存\",{\"1\":{\"123\":1}}],[\"在更新完缓存的时候\",{\"1\":{\"122\":1}}],[\"在缓存执行更新之前去加一个分布式锁\",{\"1\":{\"122\":1}}],[\"在缓存中设置一个空值或者默认值\",{\"1\":{\"119\":1}}],[\"在遇到并发的时候会出现问题\",{\"1\":{\"122\":1}}],[\"在布隆过滤器中标记一下\",{\"1\":{\"119\":1}}],[\"在一个哈希表key中存储多个键值对\",{\"1\":{\"147\":1}}],[\"在一个频繁访问的缓存过期\",{\"1\":{\"118\":1}}],[\"在一端\",{\"1\":{\"54\":1}}],[\"在业务刚刚上线的时候\",{\"1\":{\"116\":1}}],[\"在释放锁\",{\"1\":{\"116\":1}}],[\"在处理请求的时候如果发现redis中没有要查找的数据\",{\"1\":{\"116\":1}}],[\"在lfu\",{\"1\":{\"114\":1}}],[\"在所有数据范围内进行淘汰\",{\"0\":{\"111\":1},\"1\":{\"109\":1}}],[\"在插入数据时\",{\"1\":{\"97\":1}}],[\"在innodb对数据加锁之前会先在表级加上一个意向锁\",{\"1\":{\"96\":1}}],[\"在in之后的列表中的值\",{\"1\":{\"79\":1}}],[\"在语句执行的时候会立即加锁\",{\"1\":{\"95\":1}}],[\"在mysql中当我们进行curd时\",{\"1\":{\"95\":1}}],[\"在某个范围之内\",{\"1\":{\"79\":1}}],[\"在连接建立之后\",{\"1\":{\"57\":1}}],[\"在头部保存当前整个消息的长度\",{\"1\":{\"56\":1}}],[\"在发送之前\",{\"0\":{\"483\":1}}],[\"在发送数据的同时\",{\"1\":{\"56\":1}}],[\"在发送方接受到这些数据包的时候\",{\"1\":{\"55\":1}}],[\"在发送方\",{\"1\":{\"55\":1}}],[\"在传输层\",{\"1\":{\"56\":1}}],[\"在当使用tcp协议时\",{\"1\":{\"56\":1}}],[\"在断开时使用四次握手\",{\"1\":{\"52\":1}}],[\"在排序数组中查找元素的第一个位置和最后一个位置\",{\"0\":{\"26\":1},\"1\":{\"26\":1}}],[\"在\",{\"0\":{\"453\":1},\"1\":{\"19\":1,\"107\":1,\"113\":1,\"114\":1,\"129\":1,\"133\":1,\"134\":1,\"139\":1,\"146\":1,\"154\":1,\"162\":2,\"171\":1}}],[\"e类\",{\"0\":{\"341\":1}}],[\"embstr编码是专门用于保存短字符串的一种优化编码方式\",{\"1\":{\"138\":1}}],[\"embstr\",{\"1\":{\"138\":4}}],[\"emp\",{\"1\":{\"87\":1,\"90\":9}}],[\"employee\",{\"1\":{\"19\":5}}],[\"eval\",{\"1\":{\"131\":1}}],[\"everysec\",{\"1\":{\"162\":1}}],[\"every\",{\"1\":{\"38\":1}}],[\"event\",{\"1\":{\"27\":11}}],[\"entries\",{\"1\":{\"142\":1,\"146\":1}}],[\"entrydate\",{\"1\":{\"90\":2}}],[\"entrydates\",{\"1\":{\"86\":2}}],[\"encoding=\",{\"1\":{\"269\":4}}],[\"encoding\",{\"1\":{\"138\":1,\"260\":1,\"269\":2}}],[\"english\",{\"1\":{\"87\":2}}],[\"end=\",{\"1\":{\"262\":3,\"268\":3}}],[\"end`\",{\"1\":{\"131\":1}}],[\"end\",{\"1\":{\"19\":1,\"24\":3,\"87\":4,\"159\":2}}],[\"extend\",{\"1\":{\"261\":1}}],[\"ex\",{\"1\":{\"139\":1}}],[\"exists\",{\"1\":{\"139\":2}}],[\"exec\",{\"1\":{\"129\":12}}],[\"exectime\",{\"1\":{\"127\":2}}],[\"expire\",{\"1\":{\"139\":1}}],[\"expiresat\",{\"1\":{\"40\":1}}],[\"expr\",{\"1\":{\"86\":1,\"87\":1}}],[\"explain\",{\"0\":{\"81\":1,\"82\":1}}],[\"exceeded\",{\"1\":{\"38\":1}}],[\"elif\",{\"1\":{\"262\":1,\"268\":1}}],[\"elapsed\",{\"1\":{\"39\":3}}],[\"else\",{\"1\":{\"26\":7,\"29\":1,\"38\":2,\"40\":1,\"87\":4,\"125\":4,\"127\":1,\"131\":3,\"134\":2,\"262\":2,\"268\":2}}],[\"errors\",{\"1\":{\"38\":1}}],[\"error\",{\"1\":{\"38\":9,\"40\":4,\"41\":3,\"87\":1,\"125\":2,\"131\":2}}],[\"err\",{\"1\":{\"37\":2,\"38\":7,\"40\":11,\"41\":5,\"125\":23,\"127\":11,\"129\":9,\"131\":14,\"134\":11,\"260\":6}}],[\"msg\",{\"1\":{\"260\":6}}],[\"mset\",{\"1\":{\"139\":1}}],[\"mget\",{\"1\":{\"139\":1}}],[\"mymap\",{\"1\":{\"260\":4}}],[\"myprint\",{\"1\":{\"260\":1}}],[\"my\",{\"0\":{\"501\":1},\"1\":{\"125\":2,\"127\":1,\"131\":1,\"261\":36,\"264\":1,\"265\":11,\"266\":4,\"267\":12,\"270\":6}}],[\"myslice\",{\"1\":{\"260\":4}}],[\"mysql的锁\",{\"0\":{\"91\":1}}],[\"mysql中是limit\",{\"1\":{\"80\":1}}],[\"mysql\",{\"1\":{\"73\":3,\"102\":1}}],[\"mysecretkey\",{\"1\":{\"40\":1}}],[\"mesi\",{\"0\":{\"216\":1}}],[\"message\",{\"1\":{\"40\":1,\"41\":2}}],[\"meet\",{\"1\":{\"184\":1}}],[\"member\",{\"1\":{\"127\":1,\"151\":5,\"155\":6}}],[\"member是元素的值\",{\"1\":{\"127\":1}}],[\"members\",{\"1\":{\"127\":2}}],[\"memcached\",{\"1\":{\"105\":2}}],[\"memcached重启或者挂掉\",{\"1\":{\"105\":1}}],[\"mdl\",{\"0\":{\"95\":1}}],[\"month\",{\"1\":{\"86\":2}}],[\"model\",{\"1\":{\"269\":2}}],[\"mode\",{\"1\":{\"96\":1,\"98\":1}}],[\"mod\",{\"1\":{\"85\":3}}],[\"multi\",{\"1\":{\"129\":6}}],[\"mutex\",{\"1\":{\"39\":1}}],[\"mu\",{\"1\":{\"39\":3}}],[\"mac\",{\"0\":{\"493\":1}}],[\"map2\",{\"1\":{\"265\":1}}],[\"map1\",{\"1\":{\"265\":2}}],[\"map\",{\"1\":{\"260\":1,\"265\":3}}],[\"map的key只能是基本数据类型\",{\"1\":{\"260\":1}}],[\"marshal\",{\"1\":{\"260\":2}}],[\"master\",{\"1\":{\"181\":1}}],[\"managerid\",{\"1\":{\"90\":2}}],[\"math\",{\"1\":{\"87\":2}}],[\"main\",{\"1\":{\"29\":1,\"73\":2,\"125\":3,\"127\":4,\"129\":2,\"131\":2,\"134\":6,\"260\":2}}],[\"maxmemory\",{\"1\":{\"107\":1}}],[\"max\",{\"1\":{\"19\":2,\"27\":1,\"80\":2,\"127\":1,\"142\":2,\"146\":2,\"155\":3}}],[\"mian\",{\"1\":{\"73\":2}}],[\"missing\",{\"1\":{\"38\":1}}],[\"min\",{\"1\":{\"27\":2,\"80\":2,\"127\":1,\"155\":3}}],[\"middleware\",{\"0\":{\"38\":1}}],[\"mid+1\",{\"1\":{\"26\":1}}],[\"mid==len\",{\"1\":{\"26\":1}}],[\"mid==0\",{\"1\":{\"26\":1}}],[\"mid\",{\"1\":{\"26\":10}}],[\"m=n\",{\"1\":{\"19\":1}}],[\"m\",{\"1\":{\"19\":4,\"20\":2,\"268\":2}}],[\"b为10的20次方\",{\"1\":{\"268\":1}}],[\"b输出结果200\",{\"1\":{\"268\":1}}],[\"b输出结果\",{\"1\":{\"268\":1}}],[\"b=int\",{\"1\":{\"268\":1}}],[\"b=\",{\"1\":{\"263\":1}}],[\"b=list\",{\"1\":{\"261\":1}}],[\"bgrewriteaof子进程之后开始使用\",{\"1\":{\"169\":1}}],[\"bgrewriteaof\",{\"1\":{\"169\":1}}],[\"bio\",{\"1\":{\"162\":4}}],[\"bit\",{\"1\":{\"184\":1}}],[\"bit的值\",{\"1\":{\"184\":1}}],[\"bitpos\",{\"1\":{\"159\":1}}],[\"bitop\",{\"1\":{\"159\":2}}],[\"bitcount\",{\"1\":{\"159\":1}}],[\"bitmap间的运算\",{\"1\":{\"159\":1}}],[\"bitmap\",{\"0\":{\"157\":1}}],[\"bits\",{\"1\":{\"114\":2}}],[\"blpop\",{\"1\":{\"143\":1}}],[\"bufer缓冲区里\",{\"1\":{\"176\":1}}],[\"buffer缓冲区\",{\"1\":{\"176\":1}}],[\"buffer缓冲区里\",{\"1\":{\"174\":1,\"176\":2}}],[\"buffer中找到主从服务器差异\",{\"1\":{\"176\":1}}],[\"buffer\",{\"1\":{\"176\":2}}],[\"buffer内的操作命令发送给从服务器\",{\"1\":{\"174\":1}}],[\"buf\",{\"1\":{\"138\":1}}],[\"brand\",{\"1\":{\"262\":1,\"268\":1}}],[\"brpop\",{\"1\":{\"134\":5,\"143\":1,\"144\":1}}],[\"brpoplpush在每次读取的时候将元素加到另一个list\",{\"1\":{\"144\":1}}],[\"brpoplpush\",{\"1\":{\"127\":3}}],[\"break\",{\"1\":{\"26\":2,\"134\":1}}],[\"b\",{\"0\":{\"340\":1},\"1\":{\"122\":2,\"123\":1,\"268\":2}}],[\"body1\",{\"1\":{\"260\":2}}],[\"body\",{\"1\":{\"260\":2}}],[\"bob\",{\"1\":{\"77\":1}}],[\"bool\",{\"1\":{\"29\":1,\"39\":1,\"125\":1,\"131\":2,\"268\":2}}],[\"backlog\",{\"0\":{\"363\":1},\"1\":{\"176\":6}}],[\"background\",{\"1\":{\"38\":1,\"40\":1,\"41\":1,\"123\":2,\"125\":1,\"127\":2,\"131\":1,\"134\":3}}],[\"backspacecompare\",{\"1\":{\"29\":2}}],[\"bearer\",{\"1\":{\"38\":2}}],[\"between\",{\"1\":{\"24\":1,\"27\":2,\"79\":2}}],[\"begin\",{\"1\":{\"19\":1}}],[\"byte\",{\"1\":{\"40\":1,\"260\":2}}],[\"by子句定义的顺序\",{\"1\":{\"27\":1}}],[\"by\",{\"1\":{\"17\":2,\"19\":3,\"25\":1,\"27\":12,\"28\":2,\"73\":5,\"79\":2,\"80\":10,\"86\":1}}],[\"global\",{\"1\":{\"264\":1}}],[\"github\",{\"1\":{\"125\":1,\"127\":2,\"131\":2,\"134\":3}}],[\"gin\",{\"1\":{\"37\":1,\"38\":13,\"40\":5,\"41\":6}}],[\"gap\",{\"0\":{\"100\":1}}],[\"growth\",{\"1\":{\"268\":5}}],[\"growth=1\",{\"1\":{\"268\":1}}],[\"group\",{\"1\":{\"17\":1,\"25\":1,\"27\":1,\"28\":1,\"37\":1,\"79\":1,\"80\":5}}],[\"grant\",{\"1\":{\"73\":1}}],[\"grants\",{\"1\":{\"73\":1}}],[\"gender=\",{\"1\":{\"264\":5}}],[\"gender\",{\"1\":{\"89\":1,\"264\":5}}],[\"generate\",{\"1\":{\"40\":1}}],[\"generatetoken\",{\"1\":{\"40\":2}}],[\"get和post的方法都是安全和幂等的吗\",{\"0\":{\"278\":1}}],[\"get与post的区别\",{\"0\":{\"277\":1}}],[\"get与post请求\",{\"0\":{\"276\":1}}],[\"getbit\",{\"1\":{\"159\":1}}],[\"get2\",{\"1\":{\"129\":2}}],[\"get1\",{\"1\":{\"129\":2}}],[\"getrdb\",{\"1\":{\"125\":3,\"127\":2,\"131\":2}}],[\"getheader\",{\"1\":{\"38\":1}}],[\"get\",{\"1\":{\"37\":1,\"38\":1,\"41\":1,\"129\":2,\"131\":1,\"139\":1}}],[\"getindex\",{\"1\":{\"26\":1}}],[\"getnthhighestsalary\",{\"1\":{\"19\":2}}],[\"go基础\",{\"0\":{\"504\":1}}],[\"google\",{\"1\":{\"131\":1}}],[\"golang\",{\"1\":{\"127\":1}}],[\"go\",{\"0\":{\"37\":1,\"38\":1,\"39\":1,\"40\":1,\"41\":1},\"1\":{\"41\":2,\"125\":1,\"127\":2,\"131\":1,\"134\":4}}],[\"c类\",{\"0\":{\"340\":1}}],[\"c=float\",{\"1\":{\"268\":1}}],[\"c=tuple\",{\"1\":{\"263\":1}}],[\"cpu如何执行任务的\",{\"0\":{\"202\":1}}],[\"cpu不是制约redis性能表现的瓶颈\",{\"1\":{\"163\":1}}],[\"cpu\",{\"0\":{\"195\":1,\"197\":1,\"200\":1,\"205\":1,\"208\":1,\"211\":1},\"1\":{\"138\":1,\"190\":1,\"191\":2,\"192\":4}}],[\"cmdable\",{\"1\":{\"127\":1}}],[\"ctx\",{\"1\":{\"125\":3,\"127\":9,\"129\":5,\"131\":3,\"134\":6}}],[\"cheng\",{\"1\":{\"268\":1}}],[\"check\",{\"1\":{\"89\":2}}],[\"chinese\",{\"1\":{\"87\":2}}],[\"charlie\",{\"1\":{\"77\":1}}],[\"char\",{\"1\":{\"29\":3,\"89\":2}}],[\"ceil\",{\"1\":{\"85\":3}}],[\"cwnd\",{\"1\":{\"58\":5}}],[\"clear\",{\"1\":{\"261\":1,\"265\":1,\"270\":1}}],[\"cluster方案中\",{\"1\":{\"184\":1}}],[\"cluster方案采用哈希槽\",{\"1\":{\"184\":1}}],[\"cluster\",{\"1\":{\"184\":2}}],[\"close\",{\"0\":{\"348\":1,\"354\":1,\"365\":1},\"1\":{\"125\":4,\"127\":3,\"131\":3,\"162\":2,\"269\":4}}],[\"client\",{\"1\":{\"41\":1,\"125\":1,\"127\":1,\"131\":1}}],[\"claims\",{\"1\":{\"38\":6,\"40\":4}}],[\"cross\",{\"0\":{\"32\":1}}],[\"create\",{\"1\":{\"19\":1,\"73\":4,\"87\":1,\"89\":1,\"90\":3,\"184\":1}}],[\"c\",{\"1\":{\"29\":2,\"38\":24,\"40\":7,\"41\":9,\"127\":2,\"138\":1,\"268\":1}}],[\"cup的缓存一致性\",{\"0\":{\"210\":1}}],[\"cup是如何执行任务的\",{\"0\":{\"201\":1}}],[\"cup\",{\"0\":{\"196\":1}}],[\"curtime\",{\"1\":{\"86\":2}}],[\"curdate\",{\"1\":{\"86\":3}}],[\"current\",{\"1\":{\"27\":2}}],[\"customer\",{\"1\":{\"28\":2}}],[\"cume\",{\"1\":{\"27\":1}}],[\"cnt\",{\"1\":{\"25\":1}}],[\"cache\",{\"0\":{\"195\":1,\"196\":1,\"203\":1,\"211\":1}}],[\"call\",{\"1\":{\"131\":2}}],[\"cascade\",{\"1\":{\"90\":5}}],[\"case\",{\"1\":{\"24\":3,\"87\":4,\"127\":1}}],[\"capacity\",{\"1\":{\"39\":7}}],[\"category\",{\"1\":{\"24\":3}}],[\"cord\",{\"1\":{\"260\":4}}],[\"cors\",{\"0\":{\"32\":1}}],[\"cors策略\",{\"0\":{\"31\":1}}],[\"code=\",{\"1\":{\"268\":1}}],[\"code\",{\"1\":{\"260\":6,\"268\":1}}],[\"complex\",{\"1\":{\"268\":2}}],[\"compute\",{\"1\":{\"264\":6}}],[\"com\",{\"1\":{\"125\":1,\"127\":2,\"131\":2,\"134\":3}}],[\"comment\",{\"1\":{\"87\":6,\"89\":6,\"90\":12}}],[\"cookies方案为什么不直接取代半连接队列\",{\"0\":{\"371\":1}}],[\"cookie\",{\"1\":{\"38\":1,\"41\":2}}],[\"const\",{\"1\":{\"262\":1,\"268\":1}}],[\"const=const+1\",{\"1\":{\"262\":1,\"268\":1}}],[\"const=0\",{\"1\":{\"262\":1,\"268\":1}}],[\"constraint\",{\"1\":{\"90\":5}}],[\"consumer\",{\"1\":{\"133\":1,\"134\":1}}],[\"continue\",{\"1\":{\"127\":2,\"134\":2,\"262\":1,\"268\":1}}],[\"context\",{\"1\":{\"38\":4,\"40\":2,\"41\":3,\"123\":2,\"125\":2,\"127\":6,\"131\":2,\"134\":6}}],[\"concat\",{\"1\":{\"84\":1}}],[\"conditions\",{\"1\":{\"18\":3}}],[\"column\",{\"1\":{\"23\":2,\"24\":2,\"27\":2}}],[\"count+=1\",{\"1\":{\"262\":1,\"268\":1}}],[\"count=0\",{\"1\":{\"262\":1,\"268\":1}}],[\"counter\",{\"1\":{\"114\":1}}],[\"count\",{\"1\":{\"21\":2,\"24\":6,\"25\":1,\"27\":2,\"28\":1,\"80\":7,\"151\":2,\"155\":3,\"261\":1,\"262\":1,\"263\":1,\"264\":3,\"266\":2,\"268\":1}}],[\"ip协议还可以\",{\"0\":{\"479\":1}}],[\"ip协议的寻址作用\",{\"0\":{\"478\":1}}],[\"ip协议的相关技术\",{\"0\":{\"322\":1}}],[\"ipv6的首部改进\",{\"0\":{\"347\":1}}],[\"ipv6\",{\"0\":{\"346\":1}}],[\"ip分片与重组\",{\"0\":{\"345\":1}}],[\"ip\",{\"0\":{\"343\":2,\"344\":1,\"492\":1,\"508\":1}}],[\"ip的分类\",{\"0\":{\"339\":1}}],[\"ip的基础知识\",{\"0\":{\"338\":1}}],[\"ip基本认识\",{\"0\":{\"337\":1}}],[\"icmp\",{\"0\":{\"326\":1}}],[\"i+1\",{\"1\":{\"262\":1,\"268\":1}}],[\"i+=1\",{\"1\":{\"262\":2,\"268\":2}}],[\"i<=9\",{\"1\":{\"262\":1,\"268\":1}}],[\"i<10\",{\"1\":{\"262\":1,\"268\":1}}],[\"i=0\",{\"1\":{\"262\":2,\"268\":2}}],[\"i\",{\"1\":{\"261\":2,\"262\":14,\"263\":2,\"264\":1,\"268\":14,\"270\":2}}],[\"itcast\",{\"1\":{\"262\":1,\"268\":1}}],[\"itheima\",{\"1\":{\"262\":1,\"268\":1}}],[\"it\",{\"1\":{\"261\":3,\"263\":1}}],[\"import\",{\"1\":{\"125\":1,\"127\":2,\"129\":1,\"131\":1,\"134\":3,\"260\":1}}],[\"important\",{\"1\":{\"102\":1}}],[\"iru\",{\"1\":{\"111\":1}}],[\"issuedat\",{\"1\":{\"40\":1}}],[\"issuer\",{\"1\":{\"40\":1}}],[\"is\",{\"1\":{\"38\":2,\"77\":2,\"79\":2,\"262\":1,\"268\":1}}],[\"if\",{\"1\":{\"26\":10,\"29\":2,\"37\":1,\"38\":7,\"39\":3,\"40\":5,\"41\":2,\"87\":2,\"125\":11,\"127\":5,\"129\":3,\"131\":8,\"134\":4,\"260\":2,\"262\":4,\"268\":4}}],[\"ifnull\",{\"1\":{\"19\":2,\"87\":2}}],[\"input\",{\"1\":{\"262\":2,\"268\":2}}],[\"input语句会将所有输入的数据当成字符串\",{\"1\":{\"262\":1,\"268\":1}}],[\"index+=1\",{\"1\":{\"263\":1}}],[\"index=0\",{\"1\":{\"263\":1}}],[\"index=my\",{\"1\":{\"261\":1}}],[\"index<len\",{\"1\":{\"261\":1,\"263\":1}}],[\"index\",{\"1\":{\"261\":4,\"263\":1,\"266\":1}}],[\"info\",{\"1\":{\"264\":12}}],[\"inf\",{\"1\":{\"127\":1}}],[\"innodb\",{\"1\":{\"97\":1}}],[\"innodb不支持\",{\"1\":{\"90\":1}}],[\"incrby\",{\"1\":{\"139\":1}}],[\"incr\",{\"1\":{\"129\":1,\"139\":1}}],[\"increment\",{\"1\":{\"89\":1,\"90\":2,\"97\":3,\"155\":1}}],[\"inc\",{\"0\":{\"97\":1},\"1\":{\"97\":2}}],[\"income\",{\"1\":{\"24\":3}}],[\"in\",{\"0\":{\"376\":1},\"1\":{\"79\":2,\"80\":1,\"96\":1,\"98\":1,\"261\":1,\"262\":6,\"263\":1,\"264\":1,\"265\":2,\"268\":6,\"269\":2,\"270\":1}}],[\"insert\",{\"1\":{\"73\":1,\"77\":7,\"87\":1,\"90\":2,\"261\":1}}],[\"init\",{\"1\":{\"41\":1}}],[\"invalid\",{\"1\":{\"38\":3,\"40\":1}}],[\"integer\",{\"1\":{\"139\":10}}],[\"interval\",{\"1\":{\"86\":4}}],[\"interface\",{\"1\":{\"38\":1,\"260\":1}}],[\"int64\",{\"1\":{\"127\":1,\"131\":1,\"260\":1}}],[\"intcmd\",{\"1\":{\"127\":1}}],[\"into\",{\"1\":{\"77\":7,\"87\":1,\"90\":2}}],[\"int\",{\"1\":{\"19\":4,\"26\":12,\"39\":4,\"87\":4,\"89\":2,\"90\":6,\"138\":1,\"260\":9,\"268\":3}}],[\"identified\",{\"1\":{\"73\":5}}],[\"id\",{\"1\":{\"17\":6,\"18\":1,\"25\":3,\"27\":11,\"87\":4,\"89\":1,\"90\":14,\"181\":1}}],[\"nmksadsi\",{\"1\":{\"264\":1}}],[\"ni\",{\"1\":{\"263\":1,\"266\":2}}],[\"nil\",{\"1\":{\"37\":1,\"38\":5,\"40\":5,\"41\":2,\"125\":10,\"127\":4,\"129\":5,\"131\":7,\"134\":4,\"260\":2}}],[\"n2\",{\"1\":{\"260\":2}}],[\"n1\",{\"1\":{\"260\":2}}],[\"nx\",{\"1\":{\"140\":2}}],[\"nat\",{\"0\":{\"325\":1}}],[\"native\",{\"1\":{\"73\":2}}],[\"name=\",{\"1\":{\"77\":1,\"262\":2,\"264\":3,\"268\":6}}],[\"name\",{\"1\":{\"18\":1,\"23\":2,\"24\":2,\"77\":1,\"87\":2,\"89\":1,\"90\":4,\"94\":2,\"139\":7,\"260\":10,\"262\":2,\"264\":5,\"268\":21,\"269\":2}}],[\"none\",{\"1\":{\"264\":1}}],[\"none在if中使false\",{\"1\":{\"264\":1}}],[\"noeviction\",{\"1\":{\"108\":1}}],[\"not运算只能一个key\",{\"1\":{\"159\":1}}],[\"not\",{\"1\":{\"79\":2,\"89\":2,\"90\":2,\"139\":1,\"159\":1,\"498\":1}}],[\"notbefore\",{\"1\":{\"40\":1}}],[\"now\",{\"1\":{\"39\":5,\"40\":3,\"86\":6,\"127\":5}}],[\"no\",{\"1\":{\"38\":1,\"41\":1,\"90\":1,\"171\":1,\"181\":1}}],[\"net\",{\"1\":{\"127\":1}}],[\"new\",{\"1\":{\"129\":1,\"131\":1}}],[\"newticker\",{\"1\":{\"127\":1}}],[\"newtokenbucket\",{\"1\":{\"38\":1,\"39\":1}}],[\"newclient\",{\"1\":{\"41\":1,\"125\":1,\"127\":2,\"131\":1,\"134\":3}}],[\"newwithclaims\",{\"1\":{\"40\":1}}],[\"newnumericdate\",{\"1\":{\"40\":3}}],[\"next\",{\"0\":{\"101\":1},\"1\":{\"38\":3,\"101\":3,\"102\":1}}],[\"ntile\",{\"1\":{\"27\":1}}],[\"num3\",{\"1\":{\"264\":1}}],[\"num3=my\",{\"1\":{\"264\":1}}],[\"num1=my\",{\"1\":{\"264\":1}}],[\"num1\",{\"1\":{\"262\":1,\"264\":1,\"268\":4}}],[\"num=101\",{\"1\":{\"262\":1,\"268\":1}}],[\"num=random\",{\"1\":{\"262\":1,\"268\":1}}],[\"num=my\",{\"1\":{\"261\":1}}],[\"num2\",{\"1\":{\"261\":1,\"262\":1,\"264\":1,\"268\":4}}],[\"num2=my\",{\"1\":{\"261\":1,\"264\":1}}],[\"num\",{\"1\":{\"261\":1,\"262\":3,\"264\":4,\"268\":29}}],[\"numberkeys代表有多少个集合\",{\"1\":{\"155\":1}}],[\"numberkeys\",{\"1\":{\"155\":2}}],[\"number\",{\"1\":{\"27\":2,\"28\":2,\"139\":5,\"260\":2,\"268\":1}}],[\"nums\",{\"1\":{\"26\":19}}],[\"null\",{\"1\":{\"19\":3,\"77\":4,\"79\":2,\"89\":2,\"90\":4}}],[\"n\",{\"1\":{\"19\":2,\"26\":1,\"27\":1,\"84\":2,\"119\":4,\"123\":1,\"138\":1,\"147\":1,\"268\":2}}],[\"时候参数\",{\"0\":{\"363\":1}}],[\"时间用于删除和当前任务无关的过期键上\",{\"1\":{\"192\":1}}],[\"时间紧张的情况下\",{\"1\":{\"192\":1}}],[\"时间\",{\"1\":{\"192\":1}}],[\"时间戳\",{\"1\":{\"127\":1}}],[\"时间值加上一个时间间隔expr后的时间值\",{\"1\":{\"86\":1}}],[\"时的数据都已收到\",{\"1\":{\"58\":1}}],[\"时就将前面的字符顶出栈\",{\"1\":{\"29\":1}}],[\"时\",{\"1\":{\"19\":2,\"23\":1,\"58\":1,\"101\":1,\"129\":2,\"138\":1}}],[\"of\",{\"1\":{\"262\":1,\"268\":1}}],[\"offset之间的差距\",{\"1\":{\"176\":1}}],[\"offset和slave\",{\"1\":{\"176\":1}}],[\"offset发送给主服务器\",{\"1\":{\"176\":1}}],[\"offset来记录自己\",{\"1\":{\"176\":2}}],[\"offset\",{\"1\":{\"19\":6,\"21\":3,\"79\":1,\"155\":3,\"159\":2,\"174\":1,\"176\":1,\"177\":1}}],[\"o性能\",{\"1\":{\"163\":1}}],[\"o上\",{\"1\":{\"163\":1}}],[\"o多路复用处理大量的客户端socket请求\",{\"1\":{\"163\":1}}],[\"obi\",{\"1\":{\"162\":1}}],[\"open可以在执行之后自动对调用文件进行一个关闭\",{\"1\":{\"269\":1}}],[\"open\",{\"1\":{\"269\":5}}],[\"operations\",{\"1\":{\"159\":2}}],[\"options\",{\"1\":{\"41\":1,\"125\":1,\"127\":2,\"131\":1,\"134\":3}}],[\"o的多路复用\",{\"1\":{\"104\":1}}],[\"oauth\",{\"0\":{\"44\":1}}],[\"ok\",{\"1\":{\"38\":2,\"87\":2,\"139\":5}}],[\"one命令\",{\"1\":{\"181\":1}}],[\"on\",{\"1\":{\"27\":3,\"73\":2,\"90\":4}}],[\"over\",{\"1\":{\"27\":5}}],[\"org\",{\"1\":{\"127\":1}}],[\"origin\",{\"0\":{\"32\":1}}],[\"or\",{\"1\":{\"18\":1,\"79\":3,\"159\":1}}],[\"orders\",{\"1\":{\"28\":1}}],[\"order\",{\"1\":{\"17\":1,\"19\":3,\"27\":7,\"28\":1,\"79\":1,\"80\":5,\"86\":1}}],[\"dns服务器\",{\"0\":{\"484\":1}}],[\"dnsajknd\",{\"1\":{\"264\":1}}],[\"dhcp\",{\"0\":{\"324\":1}}],[\"d\",{\"1\":{\"268\":2}}],[\"dbau\",{\"1\":{\"264\":1}}],[\"db\",{\"1\":{\"123\":1,\"125\":1,\"127\":2,\"131\":1,\"134\":3}}],[\"dql数据查询语言\",{\"1\":{\"79\":1}}],[\"dql\",{\"0\":{\"79\":1}}],[\"dml数据库操作语言\",{\"1\":{\"77\":1}}],[\"dml\",{\"0\":{\"77\":1}}],[\"ddl\",{\"0\":{\"75\":1}}],[\"drop\",{\"1\":{\"73\":3,\"90\":2}}],[\"dcl数据控制语言\",{\"1\":{\"73\":1}}],[\"dcl\",{\"0\":{\"73\":1}}],[\"duplicated\",{\"1\":{\"58\":1}}],[\"duplicate\",{\"0\":{\"422\":1},\"1\":{\"54\":1}}],[\"duration\",{\"1\":{\"39\":2}}],[\"dasij\",{\"1\":{\"264\":1}}],[\"day=7\",{\"1\":{\"268\":1}}],[\"day\",{\"1\":{\"86\":3,\"268\":2}}],[\"days\",{\"1\":{\"27\":2}}],[\"data的长度\",{\"1\":{\"264\":1}}],[\"data\",{\"1\":{\"260\":8,\"264\":3}}],[\"database\",{\"1\":{\"73\":1}}],[\"date2\",{\"1\":{\"86\":1}}],[\"date1\",{\"1\":{\"86\":1}}],[\"datediff\",{\"1\":{\"86\":3}}],[\"date\",{\"1\":{\"27\":11,\"86\":10,\"90\":1}}],[\"destket\",{\"1\":{\"159\":1}}],[\"destkey\",{\"1\":{\"155\":2}}],[\"destination\",{\"1\":{\"151\":3}}],[\"desc\",{\"1\":{\"19\":3,\"28\":1,\"80\":3}}],[\"decrby\",{\"1\":{\"139\":1}}],[\"decr\",{\"1\":{\"139\":1}}],[\"decrementtime\",{\"1\":{\"114\":1}}],[\"declare\",{\"1\":{\"19\":2}}],[\"dept\",{\"1\":{\"90\":12}}],[\"de\",{\"1\":{\"86\":1}}],[\"delay\",{\"1\":{\"127\":5}}],[\"delete\",{\"1\":{\"73\":1,\"77\":2,\"90\":2}}],[\"del\",{\"1\":{\"41\":1,\"123\":2,\"125\":1,\"131\":1,\"139\":1,\"193\":1,\"194\":2,\"261\":1}}],[\"def\",{\"1\":{\"261\":2,\"264\":9}}],[\"defer\",{\"1\":{\"39\":1,\"125\":2,\"127\":1,\"131\":1}}],[\"default\",{\"1\":{\"37\":1,\"87\":3,\"89\":2,\"90\":1}}],[\"dense\",{\"1\":{\"27\":1}}],[\"difference\",{\"1\":{\"270\":2}}],[\"dias\",{\"1\":{\"264\":1}}],[\"diab1\",{\"1\":{\"18\":2}}],[\"dictionary\",{\"1\":{\"268\":1}}],[\"dict\",{\"1\":{\"162\":1,\"265\":15}}],[\"discard\",{\"1\":{\"129\":5}}],[\"dist\",{\"1\":{\"27\":1}}],[\"distinct\",{\"1\":{\"19\":3,\"25\":1,\"27\":1,\"79\":3}}],[\"<class\",{\"1\":{\"268\":4}}],[\"<目标服务器ip地址>\",{\"1\":{\"175\":1}}],[\"<服务器a的redis端口号>\",{\"1\":{\"174\":1}}],[\"<服务器a的ip地址>\",{\"1\":{\"174\":1}}],[\"<>\",{\"1\":{\"79\":1}}],[\"<=\",{\"1\":{\"79\":1,\"89\":1}}],[\"<target\",{\"1\":{\"26\":3}}],[\"<\",{\"1\":{\"19\":1,\"24\":1,\"79\":2,\"80\":2,\"127\":1,\"262\":1,\"268\":1}}],[\"syn非法\",{\"0\":{\"452\":1}}],[\"syn合法\",{\"0\":{\"451\":1}}],[\"syn报文在什么情况下会被丢弃\",{\"0\":{\"396\":1}}],[\"syn延时和泛洪攻击\",{\"0\":{\"355\":1}}],[\"sync\",{\"1\":{\"39\":1}}],[\"s次循环\",{\"1\":{\"262\":1,\"268\":1}}],[\"slot\",{\"1\":{\"184\":1}}],[\"slave\",{\"1\":{\"177\":1}}],[\"sleep\",{\"1\":{\"123\":1,\"125\":2,\"131\":1}}],[\"skiplist\",{\"1\":{\"162\":1}}],[\"sdiffstore\",{\"1\":{\"151\":1}}],[\"sdiff\",{\"1\":{\"151\":1}}],[\"sds\",{\"1\":{\"138\":8}}],[\"sds不仅可以保存文本数据\",{\"1\":{\"138\":1}}],[\"sds相比于原生的c字符串l\",{\"1\":{\"138\":1}}],[\"srandmember\",{\"1\":{\"151\":1}}],[\"srem\",{\"1\":{\"151\":1}}],[\"sinterstore\",{\"1\":{\"151\":1}}],[\"sinter\",{\"1\":{\"151\":1}}],[\"sismember\",{\"1\":{\"151\":1}}],[\"signedstring\",{\"1\":{\"40\":1}}],[\"signingmethodhs256\",{\"1\":{\"40\":1}}],[\"smembers\",{\"1\":{\"151\":1}}],[\"scard\",{\"1\":{\"151\":1}}],[\"script\",{\"1\":{\"131\":2}}],[\"score代表元素的分数\",{\"1\":{\"127\":1}}],[\"score\",{\"1\":{\"87\":2,\"127\":1,\"155\":2,\"265\":4}}],[\"spilt分割字符串\",{\"1\":{\"266\":1}}],[\"spop\",{\"1\":{\"151\":1}}],[\"split\",{\"1\":{\"127\":1,\"266\":1}}],[\"sprintf\",{\"1\":{\"127\":1}}],[\"sorted给数据容器排序\",{\"1\":{\"265\":1}}],[\"sorted\",{\"1\":{\"127\":1,\"265\":1}}],[\"s锁\",{\"1\":{\"98\":1}}],[\"sn拼接成一个字符串\",{\"1\":{\"84\":1}}],[\"sn\",{\"1\":{\"84\":1}}],[\"s2\",{\"1\":{\"84\":2}}],[\"s1\",{\"1\":{\"84\":1}}],[\"sql\",{\"0\":{\"501\":1}}],[\"sql的约束\",{\"0\":{\"88\":1}}],[\"sql的dql\",{\"0\":{\"78\":1}}],[\"sql的dml\",{\"0\":{\"76\":1}}],[\"sql的ddl\",{\"0\":{\"74\":1}}],[\"sql的dcl\",{\"0\":{\"72\":1}}],[\"sql中的函数\",{\"0\":{\"83\":1}}],[\"ssthresh\",{\"1\":{\"58\":2}}],[\"sha\",{\"1\":{\"270\":1}}],[\"share\",{\"1\":{\"96\":1,\"98\":1}}],[\"sharing\",{\"0\":{\"32\":1}}],[\"show\",{\"1\":{\"73\":1}}],[\"shouldbindjson\",{\"1\":{\"40\":1}}],[\"shouldbindjson直接将json数据解析到req\",{\"1\":{\"40\":1}}],[\"stock\",{\"1\":{\"268\":11}}],[\"stop\",{\"1\":{\"143\":1,\"155\":2}}],[\"studey\",{\"1\":{\"266\":1}}],[\"stud\",{\"1\":{\"265\":2}}],[\"step\",{\"1\":{\"262\":1,\"268\":1}}],[\"strip\",{\"1\":{\"266\":2}}],[\"strip去除前后的空格\",{\"1\":{\"266\":1}}],[\"strings\",{\"1\":{\"38\":1,\"127\":2}}],[\"string\",{\"0\":{\"137\":1},\"1\":{\"29\":5,\"40\":5,\"41\":1,\"105\":1,\"127\":1,\"131\":2,\"138\":1,\"148\":1,\"260\":10,\"266\":2,\"268\":2}}],[\"str=\",{\"1\":{\"266\":2}}],[\"str3\",{\"1\":{\"264\":1}}],[\"str3=\",{\"1\":{\"264\":1}}],[\"str2\",{\"1\":{\"264\":1}}],[\"str2=\",{\"1\":{\"264\":1}}],[\"str1\",{\"1\":{\"264\":1}}],[\"str1=\",{\"1\":{\"264\":1}}],[\"strlen\",{\"1\":{\"139\":1}}],[\"strconv\",{\"1\":{\"127\":2}}],[\"str\",{\"1\":{\"84\":6,\"266\":7,\"267\":5,\"268\":2}}],[\"struct\",{\"1\":{\"39\":1,\"40\":2,\"260\":3}}],[\"status\",{\"1\":{\"89\":1}}],[\"statusok\",{\"1\":{\"40\":1,\"41\":1}}],[\"statusinternalservererror\",{\"1\":{\"38\":1,\"41\":1}}],[\"statusunauthorized\",{\"1\":{\"38\":5,\"41\":1}}],[\"statustoomanyrequests\",{\"1\":{\"38\":1}}],[\"start\",{\"0\":{\"37\":1},\"1\":{\"37\":1,\"84\":1,\"143\":1,\"155\":2,\"159\":2}}],[\"stack\",{\"1\":{\"29\":8}}],[\"stddev\",{\"1\":{\"27\":2}}],[\"sadd\",{\"1\":{\"151\":1}}],[\"sack方法\",{\"0\":{\"421\":1}}],[\"sack\",{\"0\":{\"422\":1},\"1\":{\"54\":3}}],[\"samp\",{\"1\":{\"27\":2}}],[\"salary\",{\"1\":{\"19\":9,\"24\":3,\"90\":2}}],[\"sunionstore\",{\"1\":{\"151\":1}}],[\"sunion\",{\"1\":{\"151\":1}}],[\"successful\",{\"1\":{\"40\":1}}],[\"substring\",{\"1\":{\"84\":1}}],[\"sub\",{\"1\":{\"39\":1,\"86\":2}}],[\"subject\",{\"1\":{\"25\":1,\"40\":1}}],[\"sum\",{\"1\":{\"27\":3,\"80\":2}}],[\"s\",{\"1\":{\"23\":2,\"24\":2,\"29\":4,\"99\":8,\"100\":1,\"262\":2,\"268\":6}}],[\"sentinel\",{\"1\":{\"182\":1}}],[\"sent状态\",{\"1\":{\"61\":1,\"62\":1}}],[\"server\",{\"1\":{\"38\":1,\"41\":1}}],[\"secretkey\",{\"1\":{\"38\":1,\"40\":2}}],[\"second\",{\"1\":{\"26\":2,\"38\":2,\"40\":1,\"125\":3,\"127\":2,\"131\":2,\"134\":1}}],[\"secondhighestsalary\",{\"1\":{\"19\":3}}],[\"searchrange\",{\"1\":{\"26\":2}}],[\"set1\",{\"1\":{\"270\":4}}],[\"set1=\",{\"1\":{\"270\":3}}],[\"set3\",{\"1\":{\"270\":2}}],[\"set3=set1\",{\"1\":{\"270\":2}}],[\"set2\",{\"1\":{\"270\":3}}],[\"set2=\",{\"1\":{\"270\":2}}],[\"setn\",{\"1\":{\"270\":1}}],[\"setnx加锁\",{\"1\":{\"140\":1}}],[\"setnx\",{\"1\":{\"125\":1,\"131\":2,\"139\":1}}],[\"setbit\",{\"1\":{\"159\":1}}],[\"set的交\",{\"1\":{\"152\":1}}],[\"set的底层是哈希表或整数集合\",{\"1\":{\"150\":1}}],[\"set类型是一个无序并唯一的键值集合\",{\"1\":{\"150\":1}}],[\"setex\",{\"1\":{\"139\":1}}],[\"sets\",{\"1\":{\"127\":1}}],[\"setcookie\",{\"1\":{\"40\":1,\"41\":1}}],[\"set\",{\"0\":{\"149\":1},\"1\":{\"19\":2,\"38\":2,\"40\":1,\"77\":1,\"84\":1,\"90\":2,\"105\":1,\"129\":11,\"139\":3,\"140\":2,\"265\":2,\"268\":3,\"270\":8}}],[\"select\",{\"1\":{\"17\":1,\"18\":1,\"19\":8,\"23\":1,\"24\":5,\"25\":1,\"27\":2,\"28\":1,\"73\":2,\"79\":15,\"80\":22,\"85\":6,\"86\":10,\"87\":4,\"96\":2,\"98\":2,\"127\":1}}],[\"第\",{\"1\":{\"262\":1,\"268\":1}}],[\"第四步\",{\"1\":{\"181\":1}}],[\"第四次挥手丢失\",{\"0\":{\"445\":1}}],[\"第四次挥手\",{\"0\":{\"68\":1}}],[\"第三步\",{\"1\":{\"181\":1}}],[\"第三轮考察\",{\"1\":{\"181\":1}}],[\"第三阶段是主服务器发送新的写操作命令给从服务器\",{\"1\":{\"174\":1}}],[\"第三种方案\",{\"1\":{\"119\":1}}],[\"第三次挥手丢失\",{\"0\":{\"444\":1}}],[\"第三次挥手\",{\"0\":{\"67\":1}}],[\"第三次握手丢失\",{\"0\":{\"431\":1}}],[\"第三次握手之后\",{\"1\":{\"63\":1}}],[\"第三次握手\",{\"0\":{\"63\":1,\"490\":1}}],[\"第一轮考察\",{\"1\":{\"181\":1}}],[\"第一\",{\"1\":{\"180\":1}}],[\"第一阶段建立连接\",{\"1\":{\"174\":1}}],[\"第一步\",{\"1\":{\"119\":1,\"181\":1}}],[\"第一种方案\",{\"1\":{\"119\":2}}],[\"第一个减第二个时间\",{\"1\":{\"86\":1}}],[\"第一点\",{\"1\":{\"69\":1}}],[\"第一次同步时\",{\"1\":{\"174\":1}}],[\"第一次同步的时候由于不知道主服务器的runid所以设置为\",{\"1\":{\"174\":1}}],[\"第一次挥手丢失\",{\"0\":{\"442\":1}}],[\"第一次挥手\",{\"0\":{\"65\":1}}],[\"第一次握手丢失\",{\"0\":{\"429\":1}}],[\"第一次握手之后\",{\"1\":{\"61\":1}}],[\"第一次握手\",{\"0\":{\"61\":1,\"488\":1}}],[\"第二个read将会从第一个read后面继续查询\",{\"1\":{\"269\":1}}],[\"第二轮考察\",{\"1\":{\"181\":1}}],[\"第二\",{\"1\":{\"180\":1}}],[\"第二阶段是主服务器同步数据给从服务器\",{\"1\":{\"174\":1}}],[\"第二步\",{\"1\":{\"119\":2,\"181\":1}}],[\"第二种方案缓存空值或者默认值\",{\"1\":{\"119\":1}}],[\"第二种方案\",{\"1\":{\"119\":2}}],[\"第二点\",{\"1\":{\"69\":1}}],[\"第二次挥手丢失\",{\"0\":{\"443\":1}}],[\"第二次挥手\",{\"0\":{\"66\":1}}],[\"第二次握手丢失\",{\"0\":{\"430\":1}}],[\"第二次握手之后\",{\"1\":{\"62\":1}}],[\"第二次握手\",{\"0\":{\"62\":1,\"489\":1}}],[\"第二高的薪水\",{\"1\":{\"19\":1}}],[\"第n高的薪水\",{\"1\":{\"19\":1}}],[\"第n高的数据\",{\"0\":{\"19\":1}}],[\"l\",{\"1\":{\"270\":1}}],[\"l=\",{\"1\":{\"270\":1}}],[\"lrange\",{\"1\":{\"143\":1}}],[\"lru算法是什么\",{\"1\":{\"113\":1}}],[\"lru算法\",{\"0\":{\"113\":1}}],[\"lru算法和lfu算法\",{\"0\":{\"112\":1}}],[\"lru\",{\"1\":{\"110\":1,\"113\":4,\"114\":3}}],[\"lpop\",{\"1\":{\"143\":1}}],[\"lpush\",{\"1\":{\"127\":1,\"133\":1,\"134\":3,\"143\":1}}],[\"lpad\",{\"1\":{\"84\":2,\"85\":1}}],[\"lfu算法\",{\"0\":{\"114\":1}}],[\"lfu\",{\"1\":{\"110\":1,\"111\":1,\"113\":1,\"114\":3}}],[\"lua脚本\",{\"1\":{\"131\":1}}],[\"lua\",{\"1\":{\"105\":1}}],[\"lambda\",{\"1\":{\"264\":2}}],[\"lazy\",{\"1\":{\"162\":2}}],[\"lazyfree\",{\"1\":{\"162\":1}}],[\"lastfill\",{\"1\":{\"39\":4}}],[\"last\",{\"1\":{\"27\":1,\"114\":1}}],[\"lag\",{\"1\":{\"27\":1}}],[\"len\",{\"1\":{\"29\":2,\"84\":1,\"138\":2,\"261\":1,\"263\":1,\"264\":4,\"265\":1,\"266\":2,\"270\":1}}],[\"leader\",{\"1\":{\"180\":1}}],[\"lead\",{\"1\":{\"27\":1}}],[\"left<right\",{\"1\":{\"26\":1}}],[\"left<=right\",{\"1\":{\"26\":2}}],[\"left=right\",{\"1\":{\"26\":1}}],[\"left=mid+1\",{\"1\":{\"26\":4}}],[\"left\",{\"1\":{\"26\":6}}],[\"leetcode\",{\"0\":{\"30\":1},\"1\":{\"17\":1,\"18\":1,\"19\":1,\"24\":1,\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"29\":1}}],[\"localhost\",{\"1\":{\"40\":1,\"41\":2,\"73\":2,\"127\":1,\"134\":3}}],[\"lockedagain\",{\"1\":{\"125\":2}}],[\"locked\",{\"1\":{\"125\":4,\"131\":2}}],[\"lockkey\",{\"1\":{\"125\":4,\"127\":1,\"131\":3}}],[\"lock\",{\"0\":{\"99\":1,\"100\":1,\"101\":1},\"1\":{\"39\":1,\"92\":1,\"94\":2,\"96\":3,\"98\":1,\"99\":1,\"101\":3,\"102\":1,\"125\":2,\"127\":1,\"131\":1,\"140\":1}}],[\"logistic\",{\"1\":{\"114\":1}}],[\"loginrequest\",{\"1\":{\"40\":2}}],[\"loginhandler\",{\"1\":{\"37\":1,\"40\":1}}],[\"login\",{\"1\":{\"27\":2,\"37\":1,\"40\":1}}],[\"logc\",{\"1\":{\"114\":1}}],[\"log\",{\"1\":{\"26\":1}}],[\"lower\",{\"1\":{\"84\":1}}],[\"low\",{\"1\":{\"24\":1}}],[\"line\",{\"1\":{\"269\":4}}],[\"lines=f\",{\"1\":{\"269\":1}}],[\"linux内存布局\",{\"0\":{\"232\":1}}],[\"lin\",{\"1\":{\"139\":2}}],[\"listen\",{\"0\":{\"363\":1}}],[\"list2\",{\"1\":{\"261\":5}}],[\"list2=\",{\"1\":{\"261\":1}}],[\"list=\",{\"1\":{\"261\":1,\"266\":1}}],[\"listpack\",{\"1\":{\"146\":1,\"154\":1}}],[\"list本身不会生成\",{\"1\":{\"144\":1}}],[\"list本身就是先进先出的顺序对数据进行存取lpush\",{\"1\":{\"144\":1}}],[\"list\",{\"0\":{\"141\":1,\"261\":1},\"1\":{\"105\":1,\"127\":2,\"133\":2,\"134\":1,\"142\":7,\"146\":2,\"261\":37,\"266\":1,\"267\":5,\"268\":1}}],[\"limit\",{\"1\":{\"19\":5,\"28\":1,\"38\":1,\"79\":1,\"80\":4,\"155\":3}}],[\"like\",{\"1\":{\"18\":2,\"79\":2,\"80\":1}}],[\"患有某种疾病的患者\",{\"0\":{\"18\":1},\"1\":{\"18\":1}}],[\"1和localhost和0\",{\"0\":{\"335\":1}}],[\"1吗\",{\"0\":{\"331\":1}}],[\"1d\",{\"1\":{\"268\":1}}],[\"1+1\",{\"1\":{\"268\":1}}],[\"14复数\",{\"1\":{\"268\":1}}],[\"14\",{\"1\":{\"268\":1}}],[\"13\",{\"1\":{\"268\":2}}],[\"132\",{\"1\":{\"264\":1}}],[\"130\",{\"1\":{\"125\":1,\"131\":1}}],[\"16384\",{\"1\":{\"184\":2}}],[\"16\",{\"1\":{\"184\":1}}],[\"16bit\",{\"1\":{\"114\":1}}],[\"16版本之后\",{\"1\":{\"89\":1}}],[\"19\",{\"1\":{\"90\":1,\"268\":1}}],[\"1907\",{\"0\":{\"22\":1},\"1\":{\"24\":1}}],[\"127\",{\"0\":{\"335\":1}}],[\"123\",{\"1\":{\"268\":1}}],[\"1234\",{\"1\":{\"73\":1}}],[\"123456\",{\"1\":{\"73\":2}}],[\"128个\",{\"1\":{\"154\":1}}],[\"124\",{\"1\":{\"125\":1,\"131\":1}}],[\"12500\",{\"1\":{\"90\":1}}],[\"120\",{\"1\":{\"89\":1}}],[\"12\",{\"1\":{\"86\":1,\"90\":2,\"260\":1,\"261\":1,\"268\":2}}],[\"1内的随机数\",{\"1\":{\"85\":1}}],[\"1号员工的工号应该为00001\",{\"1\":{\"84\":1}}],[\"18\",{\"1\":{\"79\":2,\"86\":1,\"260\":4,\"262\":2,\"268\":2}}],[\"15\",{\"1\":{\"79\":2}}],[\"1527\",{\"0\":{\"18\":1},\"1\":{\"18\":1}}],[\"11000\",{\"1\":{\"90\":1}}],[\"11\",{\"0\":{\"70\":1},\"1\":{\"90\":1,\"139\":1,\"268\":7}}],[\"1148\",{\"0\":{\"17\":1},\"1\":{\"17\":1}}],[\"1状态\",{\"1\":{\"65\":1}}],[\"10浮点数\",{\"1\":{\"268\":1}}],[\"100\",{\"1\":{\"264\":1}}],[\"10000\",{\"1\":{\"140\":1}}],[\"100000000000000000000\",{\"1\":{\"268\":1}}],[\"1000000\",{\"1\":{\"85\":1}}],[\"10内的随机数\",{\"1\":{\"262\":1,\"268\":1}}],[\"10秒后执行\",{\"1\":{\"127\":1}}],[\"10580\",{\"1\":{\"90\":1}}],[\"10\",{\"0\":{\"69\":1,\"371\":1},\"1\":{\"38\":2,\"80\":4,\"89\":1,\"90\":1,\"127\":1,\"139\":5,\"177\":1,\"262\":2,\"268\":4,\"269\":1}}],[\"17\",{\"1\":{\"125\":1,\"131\":1}}],[\"177\",{\"1\":{\"19\":1}}],[\"176\",{\"1\":{\"19\":1}}],[\"176`177\",{\"0\":{\"19\":1}}],[\"1\",{\"0\":{\"20\":1,\"43\":1,\"51\":1,\"61\":1,\"65\":1,\"110\":1,\"137\":1,\"221\":1,\"224\":2,\"227\":1,\"231\":1,\"284\":1,\"287\":1,\"288\":1,\"295\":1,\"296\":1,\"300\":1,\"305\":1,\"313\":1,\"320\":1,\"332\":1,\"334\":1,\"362\":1,\"373\":1,\"419\":1,\"482\":1,\"488\":1},\"1\":{\"19\":9,\"24\":3,\"26\":13,\"28\":1,\"29\":1,\"38\":1,\"41\":1,\"54\":1,\"56\":1,\"58\":3,\"73\":2,\"79\":1,\"80\":3,\"85\":3,\"87\":1,\"89\":3,\"90\":7,\"119\":1,\"122\":4,\"125\":1,\"127\":2,\"131\":5,\"134\":1,\"138\":2,\"139\":6,\"142\":1,\"159\":3,\"174\":1,\"191\":1,\"260\":3,\"261\":15,\"262\":7,\"263\":3,\"264\":3,\"265\":1,\"267\":10,\"268\":17,\"270\":6}}],[\"=getindex\",{\"1\":{\"26\":2}}],[\"==0\",{\"1\":{\"262\":1,\"268\":1}}],[\"==\",{\"1\":{\"26\":1,\"29\":2,\"38\":1,\"40\":2,\"131\":2,\"134\":1,\"262\":1,\"268\":1}}],[\"=mid\",{\"1\":{\"26\":2}}],[\"=target\",{\"1\":{\"26\":3}}],[\"=left+\",{\"1\":{\"26\":3}}],[\"=len\",{\"1\":{\"26\":2}}],[\"=0\",{\"1\":{\"26\":2}}],[\"=\",{\"1\":{\"17\":1,\"19\":1,\"26\":1,\"29\":3,\"37\":4,\"38\":10,\"39\":5,\"40\":11,\"41\":6,\"58\":1,\"77\":2,\"79\":2,\"80\":2,\"84\":1,\"125\":20,\"127\":18,\"129\":9,\"131\":15,\"134\":13,\"260\":10,\"261\":6,\"262\":2,\"263\":3,\"264\":4,\"265\":9,\"267\":12,\"268\":33,\"269\":3,\"270\":2}}],[\"found\",{\"1\":{\"498\":1}}],[\"format\",{\"1\":{\"264\":2,\"268\":1}}],[\"for循环\",{\"1\":{\"262\":1,\"268\":1}}],[\"fork\",{\"1\":{\"171\":3}}],[\"foreign\",{\"1\":{\"89\":1,\"90\":7}}],[\"for\",{\"1\":{\"26\":3,\"29\":1,\"73\":1,\"96\":1,\"98\":1,\"127\":3,\"134\":2,\"261\":3,\"262\":6,\"263\":1,\"264\":1,\"265\":2,\"268\":6,\"269\":2,\"270\":1}}],[\"fullresync命令意图时全量复制\",{\"1\":{\"174\":1}}],[\"func\",{\"1\":{\"26\":3,\"29\":3,\"37\":1,\"38\":7,\"39\":3,\"40\":2,\"41\":3,\"125\":6,\"127\":5,\"129\":1,\"131\":5,\"134\":3,\"260\":3,\"264\":4}}],[\"function\",{\"1\":{\"19\":1}}],[\"fsync\",{\"1\":{\"162\":2,\"171\":3}}],[\"fd\",{\"1\":{\"162\":2}}],[\"fk\",{\"1\":{\"90\":3}}],[\"f\",{\"1\":{\"87\":1,\"127\":1,\"262\":3,\"265\":2,\"266\":1,\"267\":6,\"268\":8,\"269\":15}}],[\"float\",{\"1\":{\"268\":3}}],[\"float32\",{\"1\":{\"260\":1}}],[\"float64\",{\"1\":{\"127\":2,\"260\":1}}],[\"floor\",{\"1\":{\"85\":3}}],[\"flush刷新\",{\"1\":{\"269\":1}}],[\"flush\",{\"1\":{\"92\":1,\"269\":1}}],[\"flipped\",{\"1\":{\"40\":1,\"77\":1,\"260\":4,\"266\":2}}],[\"flipped1001\",{\"1\":{\"40\":1,\"262\":1,\"268\":1}}],[\"flipped的个人介绍页\",{\"0\":{\"1\":1}}],[\"failed\",{\"1\":{\"40\":1}}],[\"false记作0\",{\"1\":{\"268\":1}}],[\"false表示假\",{\"1\":{\"268\":1}}],[\"false\",{\"1\":{\"39\":1,\"40\":1,\"41\":1,\"125\":1,\"131\":2}}],[\"finally\",{\"1\":{\"268\":2}}],[\"file\",{\"1\":{\"162\":1}}],[\"filltokens\",{\"1\":{\"39\":2}}],[\"fillinterval\",{\"1\":{\"39\":6}}],[\"field代表商品id\",{\"1\":{\"148\":1}}],[\"field\",{\"1\":{\"147\":9,\"148\":1}}],[\"fieldn\",{\"1\":{\"146\":1}}],[\"field1\",{\"1\":{\"146\":1}}],[\"fifo\",{\"1\":{\"133\":1}}],[\"first\",{\"1\":{\"27\":7}}],[\"fmt\",{\"1\":{\"29\":1,\"38\":1,\"125\":19,\"127\":11,\"129\":6,\"131\":9,\"134\":10,\"260\":7}}],[\"frame\",{\"0\":{\"462\":1}}],[\"free\",{\"1\":{\"162\":5}}],[\"frequently\",{\"1\":{\"114\":1}}],[\"frist>=len\",{\"1\":{\"26\":1}}],[\"frist\",{\"1\":{\"26\":3}}],[\"from\",{\"1\":{\"17\":1,\"18\":1,\"19\":5,\"23\":2,\"24\":5,\"25\":1,\"27\":2,\"28\":1,\"73\":2,\"77\":2,\"79\":15,\"80\":22,\"86\":1,\"87\":2}}],[\"args\",{\"1\":{\"264\":3}}],[\"argv\",{\"1\":{\"131\":1}}],[\"a=str\",{\"1\":{\"268\":1}}],[\"a=\",{\"1\":{\"261\":1,\"263\":1}}],[\"any\",{\"1\":{\"260\":2}}],[\"and\",{\"1\":{\"24\":1,\"27\":2,\"79\":4,\"80\":4,\"89\":1,\"159\":1}}],[\"aof持久化大key的影响\",{\"1\":{\"171\":1}}],[\"aof重写机制\",{\"0\":{\"168\":1},\"1\":{\"168\":1}}],[\"aof日志不可以过大\",{\"1\":{\"167\":1}}],[\"aof的写回策略\",{\"0\":{\"167\":1}}],[\"aof刷盘任务队列\",{\"1\":{\"162\":1}}],[\"aof\",{\"0\":{\"166\":1},\"1\":{\"134\":1,\"162\":6,\"165\":2,\"166\":3,\"168\":3,\"169\":6,\"171\":13,\"193\":11,\"194\":1}}],[\"apr\",{\"0\":{\"323\":1}}],[\"api\",{\"1\":{\"119\":1,\"138\":2}}],[\"append\",{\"1\":{\"29\":1,\"261\":1}}],[\"age=30\",{\"1\":{\"264\":1}}],[\"age=20\",{\"1\":{\"264\":4}}],[\"age=int\",{\"1\":{\"262\":1,\"268\":1}}],[\"age=input\",{\"1\":{\"262\":2,\"268\":2}}],[\"age\",{\"1\":{\"89\":3,\"90\":2,\"260\":9,\"262\":4,\"264\":6,\"268\":4}}],[\"auto\",{\"0\":{\"97\":1},\"1\":{\"89\":1,\"90\":2,\"97\":5}}],[\"authheader\",{\"1\":{\"38\":3}}],[\"authmiddleware\",{\"1\":{\"37\":1,\"38\":1}}],[\"auth\",{\"0\":{\"40\":1},\"1\":{\"37\":6}}],[\"authorization\",{\"1\":{\"38\":3}}],[\"author\",{\"1\":{\"17\":3}}],[\"always\",{\"1\":{\"171\":1}}],[\"alice\",{\"1\":{\"77\":3}}],[\"alter\",{\"1\":{\"73\":3,\"90\":6}}],[\"allkeys\",{\"1\":{\"111\":3}}],[\"all\",{\"0\":{\"24\":1},\"1\":{\"24\":7,\"73\":2}}],[\"administrator\",{\"1\":{\"73\":1}}],[\"addslots\",{\"1\":{\"184\":1}}],[\"address\",{\"0\":{\"376\":1}}],[\"addr\",{\"1\":{\"41\":1,\"125\":1,\"127\":2,\"131\":1,\"134\":3}}],[\"add\",{\"1\":{\"40\":1,\"86\":2,\"90\":4,\"127\":1,\"270\":1}}],[\"ad\",{\"1\":{\"29\":1}}],[\"abort\",{\"1\":{\"38\":7}}],[\"ab\",{\"1\":{\"29\":1}}],[\"avg\",{\"1\":{\"27\":1,\"80\":3}}],[\"average\",{\"1\":{\"24\":1}}],[\"amount\",{\"1\":{\"27\":1}}],[\"a\",{\"0\":{\"44\":1},\"1\":{\"27\":12,\"122\":4,\"123\":1,\"262\":2,\"264\":2,\"266\":1,\"268\":6,\"269\":2}}],[\"accept\",{\"0\":{\"364\":1}}],[\"accounts\",{\"1\":{\"24\":6}}],[\"acquirelock\",{\"1\":{\"125\":4,\"131\":2}}],[\"action\",{\"1\":{\"90\":2}}],[\"activity\",{\"1\":{\"27\":2}}],[\"ack状态\",{\"1\":{\"67\":1}}],[\"ack\",{\"1\":{\"58\":5,\"177\":1}}],[\"asc\",{\"1\":{\"80\":4}}],[\"as\",{\"1\":{\"17\":1,\"19\":4,\"24\":6,\"25\":1,\"27\":6,\"79\":3,\"86\":1,\"87\":2,\"269\":1}}],[\"游戏玩法分析\",{\"0\":{\"17\":1,\"27\":1},\"1\":{\"27\":1}}],[\"兴趣爱好\",{\"0\":{\"15\":1}}],[\"证书优化\",{\"0\":{\"308\":1}}],[\"证书\",{\"0\":{\"14\":1}}],[\"教育背景\",{\"0\":{\"13\":1}}],[\"项目经理\",{\"1\":{\"90\":1}}],[\"项目经验\",{\"0\":{\"10\":1}}],[\"项目名称2\",{\"0\":{\"12\":1}}],[\"项目名称1\",{\"0\":{\"11\":1}}],[\"前端技术\",{\"0\":{\"6\":1}}],[\"🎨\",{\"0\":{\"15\":1}}],[\"🎖️\",{\"0\":{\"14\":1}}],[\"🎓\",{\"0\":{\"13\":1}}],[\"🌐\",{\"0\":{\"6\":1}}],[\"🌟\",{\"0\":{\"1\":2}}],[\"技能\",{\"0\":{\"4\":1}}],[\"💬\",{\"0\":{\"16\":1}}],[\"📦\",{\"0\":{\"11\":1}}],[\"📚\",{\"0\":{\"10\":1}}],[\"🔧\",{\"0\":{\"9\":1}}],[\"🗄️\",{\"0\":{\"8\":1}}],[\"🛠️\",{\"0\":{\"7\":1}}],[\"🖥️\",{\"0\":{\"5\":1}}],[\"🚀\",{\"0\":{\"4\":1}}],[\"📝\",{\"0\":{\"3\":1,\"12\":1}}],[\"📋\",{\"0\":{\"2\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
